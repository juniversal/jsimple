<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>The Checker Framework: 
Custom pluggable types for Java
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
.lstframe{margin:auto;margin-bottom:2em}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: hevea -exec xxdate.exe urlhref.hva manual.tex -->
<!--CUT DEF chapter 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">The Checker Framework:<BR>
Custom pluggable types for Java</H1><H3 CLASS="titlerest"><A HREF="http://types.cs.washington.edu/checker-framework/"><TT>http://types.cs.washington.edu/checker-framework/</TT></A></H3><H3 CLASS="titlerest">Version 1.2.6 (18 Mar 2012)</H3></TD></TR>
</TABLE><P><B>For the impatient:</B>
Section&#XA0;<A HREF="#installation">1.2</A>
describes how to <B>install and use</B> pluggable type-checkers.</P><!--TOC chapter Contents-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Contents</H1><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#introduction">1&#XA0;&#XA0;Introduction</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#pluggable-types">1.1&#XA0;&#XA0;How it works: Pluggable types</A>
</LI><LI CLASS="li-toc"><A HREF="#installation">1.2&#XA0;&#XA0;Installation</A>
</LI><LI CLASS="li-toc"><A HREF="#example-use">1.3&#XA0;&#XA0;Example use: detecting a null pointer bug</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#using-a-checker">2&#XA0;&#XA0;Using a checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#writing-annotations">2.1&#XA0;&#XA0;Writing annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#running">2.2&#XA0;&#XA0;Running a checker</A>
</LI><LI CLASS="li-toc"><A HREF="#checker-guarantees">2.3&#XA0;&#XA0;What the checker guarantees</A>
</LI><LI CLASS="li-toc"><A HREF="#tips-about-writing-annotations">2.4&#XA0;&#XA0;Tips about writing annotations</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#nullness-checker">3&#XA0;&#XA0;Nullness checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#nullness-checks">3.1&#XA0;&#XA0;What the Nullness checker checks</A>
</LI><LI CLASS="li-toc"><A HREF="#nullness-annotations">3.2&#XA0;&#XA0;Nullness annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#writing-nullness-annotations">3.3&#XA0;&#XA0;Writing nullness annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#suppressing-warnings-nullness">3.4&#XA0;&#XA0;Suppressing nullness warnings</A>
</LI><LI CLASS="li-toc"><A HREF="#raw-partially-initialized">3.5&#XA0;&#XA0;<TT>@Raw</TT> annotation for partially-initialized objects</A>
</LI><LI CLASS="li-toc"><A HREF="#map-keys">3.6&#XA0;&#XA0;Map key annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#nullness-additional-details">3.7&#XA0;&#XA0;Additional details</A>
</LI><LI CLASS="li-toc"><A HREF="#nullness-example">3.8&#XA0;&#XA0;Examples</A>
</LI><LI CLASS="li-toc"><A HREF="#nullness-getting-started">3.9&#XA0;&#XA0;Tips for getting started</A>
</LI><LI CLASS="li-toc"><A HREF="#nullness-related-work">3.10&#XA0;&#XA0;Other tools for nullness checking</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#interning-checker">4&#XA0;&#XA0;Interning checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#interning-annotations">4.1&#XA0;&#XA0;Interning annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#annotating-with-interned">4.2&#XA0;&#XA0;Annotating your code with <TT>@Interned</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#interning-checks">4.3&#XA0;&#XA0;What the Interning checker checks</A>
</LI><LI CLASS="li-toc"><A HREF="#interning-example">4.4&#XA0;&#XA0;Examples</A>
</LI><LI CLASS="li-toc"><A HREF="#other-interning-annotations">4.5&#XA0;&#XA0;Other interning annotations</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#igj-checker">5&#XA0;&#XA0;IGJ immutability checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#igj-and-mutability">5.1&#XA0;&#XA0;IGJ and Mutability</A>
</LI><LI CLASS="li-toc"><A HREF="#igj-annotations">5.2&#XA0;&#XA0;IGJ Annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#igj-checks">5.3&#XA0;&#XA0;What the IGJ checker checks</A>
</LI><LI CLASS="li-toc"><A HREF="#igj-implicit-qualifiers">5.4&#XA0;&#XA0;Implicit and default qualifiers</A>
</LI><LI CLASS="li-toc"><A HREF="#annotation-igj-dialect">5.5&#XA0;&#XA0;Annotation IGJ Dialect</A>
</LI><LI CLASS="li-toc"><A HREF="#igj-library-annotations">5.6&#XA0;&#XA0;Iterators and their abstract state</A>
</LI><LI CLASS="li-toc"><A HREF="#igj-example">5.7&#XA0;&#XA0;Examples</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#javari-checker">6&#XA0;&#XA0;Javari immutability checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#javary-annotations">6.1&#XA0;&#XA0;Javari annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#writing-javari-annotations">6.2&#XA0;&#XA0;Writing Javari annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#javari-checks">6.3&#XA0;&#XA0;What the Javari checker checks</A>
</LI><LI CLASS="li-toc"><A HREF="#javari-library-annotations">6.4&#XA0;&#XA0;Iterators and their abstract state</A>
</LI><LI CLASS="li-toc"><A HREF="#javari-examples">6.5&#XA0;&#XA0;Examples</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#lock-checker">7&#XA0;&#XA0;Lock checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#lock-annotations">7.1&#XA0;&#XA0;Lock annotations</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#fenum-checker">8&#XA0;&#XA0;Fake Enum checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#fenum-annotations">8.1&#XA0;&#XA0;Fake enum annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#fenum-checks">8.2&#XA0;&#XA0;What the Fenum checker checks</A>
</LI><LI CLASS="li-toc"><A HREF="#fenum-running">8.3&#XA0;&#XA0;Running the Fenum checker</A>
</LI><LI CLASS="li-toc"><A HREF="#fenum-suppressing">8.4&#XA0;&#XA0;Suppressing warnings</A>
</LI><LI CLASS="li-toc"><A HREF="#fenum-example">8.5&#XA0;&#XA0;Example</A>
</LI><LI CLASS="li-toc"><A HREF="#fenum-references">8.6&#XA0;&#XA0;References</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#tainting-checker">9&#XA0;&#XA0;Tainting checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#tainting-annotations">9.1&#XA0;&#XA0;Tainting annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#writing-untainted">9.2&#XA0;&#XA0;Tips on writing <TT>@Untainted</TT> annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#tainting-many-uses">9.3&#XA0;&#XA0;<TT>@Tainted</TT> and <TT>@Untainted</TT> can be used for many purposes</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#linear-checker">10&#XA0;&#XA0;Linear checker for preventing aliasing</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#linear-annotations">10.1&#XA0;&#XA0;Linear annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#linear-limitations">10.2&#XA0;&#XA0;Limitations</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#regex-checker">11&#XA0;&#XA0;Regex checker for regular expression syntax</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#regex-annotations">11.1&#XA0;&#XA0;Regex annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#annotating-with-regex">11.2&#XA0;&#XA0;Annotating your code with <TT>@Regex</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#propkey-checker">12&#XA0;&#XA0;Property file checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#genpropkey-checker">12.1&#XA0;&#XA0;Generic property file checker</A>
</LI><LI CLASS="li-toc"><A HREF="#i18n-checker">12.2&#XA0;&#XA0;Internationalization checker</A>
</LI><LI CLASS="li-toc"><A HREF="#compilermsgs-checker">12.3&#XA0;&#XA0;Compiler Message Key checker</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#signature-checker">13&#XA0;&#XA0;Signature checker for string representations of types</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#signature-annotations">13.1&#XA0;&#XA0;Signature annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#signature-checks">13.2&#XA0;&#XA0;What the Signature Checker checks</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#units-checker">14&#XA0;&#XA0;Units checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#units-annotations">14.1&#XA0;&#XA0;Units annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#extending-units">14.2&#XA0;&#XA0;Extending the Units Checker</A>
</LI><LI CLASS="li-toc"><A HREF="#units-checks">14.3&#XA0;&#XA0;What the Units Checker checks</A>
</LI><LI CLASS="li-toc"><A HREF="#units-running">14.4&#XA0;&#XA0;Running the Units Checker</A>
</LI><LI CLASS="li-toc"><A HREF="#units-suppressing">14.5&#XA0;&#XA0;Suppressing warnings</A>
</LI><LI CLASS="li-toc"><A HREF="#units-references">14.6&#XA0;&#XA0;References</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#basic-checker">15&#XA0;&#XA0;Basic checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#basic-using">15.1&#XA0;&#XA0;Using the Basic checker</A>
</LI><LI CLASS="li-toc"><A HREF="#encrypted-example">15.2&#XA0;&#XA0;Basic checker example</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#typestate-checker">16&#XA0;&#XA0;Typestate checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#typestate-vs-type-refinement">16.1&#XA0;&#XA0;Comparison to flow-sensitive type refinement</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#external-checkers">17&#XA0;&#XA0;Third-party checkers</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#units-and-dimensions-checker">17.1&#XA0;&#XA0;Units and dimensions checker</A>
</LI><LI CLASS="li-toc"><A HREF="#loci-thread-locality-checker">17.2&#XA0;&#XA0;Thread locality checker</A>
</LI><LI CLASS="li-toc"><A HREF="#safety-critical-java-checker">17.3&#XA0;&#XA0;Safety-Critical Java checker</A>
</LI><LI CLASS="li-toc"><A HREF="#gut-checker">17.4&#XA0;&#XA0;Generic Universe Types checker</A>
</LI><LI CLASS="li-toc"><A HREF="#enerj-checker">17.5&#XA0;&#XA0;EnerJ checker</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#polymorphism">18&#XA0;&#XA0;Generics and polymorphism</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#generics">18.1&#XA0;&#XA0;Generics (parametric polymorphism or type polymorphism)</A>
</LI><LI CLASS="li-toc"><A HREF="#qualifier-polymorphism">18.2&#XA0;&#XA0;Qualifier polymorphism</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#advanced-type-system-features">19&#XA0;&#XA0;Advanced type system features</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#effective-qualifier">19.1&#XA0;&#XA0;The effective qualifier on a type (defaults and inference)</A>
</LI><LI CLASS="li-toc"><A HREF="#java-expressions-as-arguments">19.2&#XA0;&#XA0;Writing Java expressions as annotation arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#inexpressible-types">19.3&#XA0;&#XA0;Inexpressible types</A>
</LI><LI CLASS="li-toc"><A HREF="#unused-fields-and-dependent-types">19.4&#XA0;&#XA0;Unused fields and dependent types</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#warnings-and-legacy">20&#XA0;&#XA0;Handling warnings and legacy code</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#unannotated-code">20.1&#XA0;&#XA0;Checking partially-annotated programs: handling unannotated code</A>
</LI><LI CLASS="li-toc"><A HREF="#suppressing-warnings">20.2&#XA0;&#XA0;Suppressing warnings</A>
</LI><LI CLASS="li-toc"><A HREF="#backward-compatibility">20.3&#XA0;&#XA0;Backward compatibility with earlier versions of Java</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#annotating-libraries">21&#XA0;&#XA0;Annotating libraries</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#stub-vs-class-files">21.1&#XA0;&#XA0;Choosing between stub files and annotated <TT>.class</TT> files</A>
</LI><LI CLASS="li-toc"><A HREF="#stub-creating-and-using">21.2&#XA0;&#XA0;Using stub classes</A>
</LI><LI CLASS="li-toc"><A HREF="#skeleton">21.3&#XA0;&#XA0;Using distributed annotated JDKs</A>
</LI><LI CLASS="li-toc"><A HREF="#libraries-troubleshooting">21.4&#XA0;&#XA0;Troubleshooting/debugging annotated libraries</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#writing-a-checker">22&#XA0;&#XA0;How to create a new checker</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#tool-relationships">22.1&#XA0;&#XA0;Relationship of the Checker Framework to other tools</A>
</LI><LI CLASS="li-toc"><A HREF="#parts-of-a-checker">22.2&#XA0;&#XA0;The parts of a checker</A>
</LI><LI CLASS="li-toc"><A HREF="#writing-typequals">22.3&#XA0;&#XA0;Annotations: Type qualifiers and hierarchy</A>
</LI><LI CLASS="li-toc"><A HREF="#writing-type-introduction">22.4&#XA0;&#XA0;Type factory: Implicit annotations</A>
</LI><LI CLASS="li-toc"><A HREF="#extending-visitor">22.5&#XA0;&#XA0;Visitor: Type rules</A>
</LI><LI CLASS="li-toc"><A HREF="#writing-compiler-interface">22.6&#XA0;&#XA0;The checker class: Compiler interface</A>
</LI><LI CLASS="li-toc"><A HREF="#testing-framework">22.7&#XA0;&#XA0;Testing framework</A>
</LI><LI CLASS="li-toc"><A HREF="#debugging-options">22.8&#XA0;&#XA0;Debugging options</A>
</LI><LI CLASS="li-toc"><A HREF="#javac-tips">22.9&#XA0;&#XA0;javac implementation survival guide</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#external-tools">23&#XA0;&#XA0;Integration with external tools</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#javac-installation">23.1&#XA0;&#XA0;Javac Compiler</A>
</LI><LI CLASS="li-toc"><A HREF="#ant-task">23.2&#XA0;&#XA0;Ant task</A>
</LI><LI CLASS="li-toc"><A HREF="#maven-plugin">23.3&#XA0;&#XA0;Maven plugin</A>
</LI><LI CLASS="li-toc"><A HREF="#gradle">23.4&#XA0;&#XA0;Gradle</A>
</LI><LI CLASS="li-toc"><A HREF="#intellij">23.5&#XA0;&#XA0;IntelliJ IDEA</A>
</LI><LI CLASS="li-toc"><A HREF="#eclipse">23.6&#XA0;&#XA0;Eclipse</A>
</LI><LI CLASS="li-toc"><A HREF="#tide">23.7&#XA0;&#XA0;tIDE</A>
</LI><LI CLASS="li-toc"><A HREF="#type-inference-tools">23.8&#XA0;&#XA0;Type inference tools</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#faq">24&#XA0;&#XA0;Frequently Asked Questions (FAQs)</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#faq-ease-of-use">24.1&#XA0;&#XA0;Are type annotations easy to read and write?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-code-clutter">24.2&#XA0;&#XA0;Will my code become cluttered with type annotations?</A>
</LI><LI CLASS="li-toc"><A HREF="#never-make-type-errors">24.3&#XA0;&#XA0;I don&#X2019;t make type errors, so would pluggable type checking help me?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-handling-warnings">24.4&#XA0;&#XA0;What should I do if a checker issues a warning about my code?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-no-absolute-guarantee">24.5&#XA0;&#XA0;Can a pluggable type-checker give an absolute guarantee of correctness?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-awarns">24.6&#XA0;&#XA0;How do I make compilation succeed even if a checker issues errors?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-run-time-checking">24.7&#XA0;&#XA0;How can I do run-time monitoring of properties that were not statically checked?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-annotate-existing-program">24.8&#XA0;&#XA0;How do I get started annotating an existing program?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-shorten-command-line">24.9&#XA0;&#XA0;How do I shorten the command line when invoking a checker?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-qualifiers-vs-subclasses">24.10&#XA0;&#XA0;When should I use type qualifiers, and when should I use subclasses?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-create-a-checker">24.11&#XA0;&#XA0;How do I create a new checker?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-declarative-syntax-for-type-rules">24.12&#XA0;&#XA0;Why is there no declarative syntax for writing type rules?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-type-checking-vs-bug-detectors">24.13&#XA0;&#XA0;Why not just use a bug detector (like FindBugs)?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-jml">24.14&#XA0;&#XA0;How does pluggable type-checking compare with JML?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-no-annotation-on-types-and-declarations">24.15&#XA0;&#XA0;Why shouldn&#X2019;t a qualifier apply to both types and declarations?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-array-syntax-meaning">24.16&#XA0;&#XA0;What is the meaning of array annotations such as <TT>@NonNull Object @Nullable []</TT>?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-list-map-nonnull-typeargs">24.17&#XA0;&#XA0;Why are the type parameters to <TT>List</TT> and <TT>Map</TT> annotated as <TT>@NonNull</TT>?</A>
</LI><LI CLASS="li-toc"><A HREF="#faq-checker-framework-part-of-java">24.18&#XA0;&#XA0;Is the Checker Framework an official part of Java?</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#troubleshooting">25&#XA0;&#XA0;Troubleshooting and getting help</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#common-problems">25.1&#XA0;&#XA0;Common problems and solutions</A>
</LI><LI CLASS="li-toc"><A HREF="#reporting-bugs">25.2&#XA0;&#XA0;How to report problems (bug reporting)</A>
</LI><LI CLASS="li-toc"><A HREF="#build-source">25.3&#XA0;&#XA0;Building from source</A>
</LI><LI CLASS="li-toc"><A HREF="#learning-more">25.4&#XA0;&#XA0;Learning more</A>
</LI><LI CLASS="li-toc"><A HREF="#other-tools">25.5&#XA0;&#XA0;Comparison to other tools</A>
</LI><LI CLASS="li-toc"><A HREF="#credits">25.6&#XA0;&#XA0;Credits and changelog</A>
</LI></UL>
</LI></UL><HR><!--TOC chapter Introduction-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="introduction">Chapter&#XA0;1</A>&#XA0;&#XA0;Introduction</H1><!--SEC END --><P>The Checker Framework enhances Java&#X2019;s type system to make it more powerful
and useful.
This lets software developers detect and
prevent errors in their Java programs.</P><P>The Checker Framework comes with checkers for specific types of errors:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><A HREF="#nullness-checker">Nullness checker</A> for null pointer errors
(see Chapter&#XA0;<A HREF="#nullness-checker">3</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#interning-checker">Interning checker</A> for errors in equality
testing and interning (see Chapter&#XA0;<A HREF="#interning-checker">4</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#igj-checker">IGJ checker</A> for mutation errors (incorrect
side effects), based on the IGJ type system (see
Chapter&#XA0;<A HREF="#igj-checker">5</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#javari-checker">Javari checker</A> for mutation errors
(incorrect side effects), based on the Javari type system (see
Chapter&#XA0;<A HREF="#javari-checker">6</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#lock-checker">Lock checker</A> for concurrency and lock errors,
inspired by the Java Concurrency in Practice (JCIP) annotations (see
Chapter&#XA0;<A HREF="#lock-checker">7</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#fenum-checker">Fake enum checker</A> to allow type-safe fake enum
patterns (see Chapter&#XA0;<A HREF="#fenum-checker">8</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#tainting-checker">Tainting checker</A> for trust and security errors
(see Chapter&#XA0;<A HREF="#tainting-checker">9</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#linear-checker">Linear checker</A> to control aliasing and prevent
re-use (see Chapter&#XA0;<A HREF="#linear-checker">10</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#regex-checker">Regex checker</A> to prevent use of syntactically
invalid regular expressions (see Chapter&#XA0;<A HREF="#regex-checker">11</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#propkey-checker">Property file checker</A> to ensure that valid
keys are used for property files and resource bundles (see
Chapter&#XA0;<A HREF="#propkey-checker">12</A>).
Also includes a checker that code is properly internationalized.
</LI><LI CLASS="li-enumerate"><A HREF="#signature-checker">Signature string checker</A> to ensure that the
string representation of a type is properly used, for example in
<TT>Class.forName</TT> (see Chapter&#XA0;<A HREF="#signature-checker">13</A>).
Also includes a checker that code is properly internationalized.
</LI><LI CLASS="li-enumerate"><A HREF="#units-checker">Units checker</A> to ensure operations are
performed on correct units of measurement
(see Chapter&#XA0;<A HREF="#units-checker">14</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#basic-checker">Basic checker</A> for customized checking without
writing any code (see Chapter&#XA0;<A HREF="#basic-checker">15</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#typestate-checker">Typestate checker</A> to ensure operations are
performed on objects that are in the right state, such as only opened
files being read (see Chapter&#XA0;<A HREF="#typestate-checker">16</A>)
</LI><LI CLASS="li-enumerate"><A HREF="#third-party-checkers">Third-party checkers</A> that are distributed
separately from the Checker Framework
(see Chapter&#XA0;<A HREF="#third-party-checkers">17</A>)</LI></OL><P>These checkers are easy to use and are invoked as arguments to <TT>javac</TT>.</P><P>The Checker Framework also enables you to write new checkers of your
own; see Chapters&#XA0;<A HREF="#basic-checker">15</A> and&#XA0;<A HREF="#writing-a-checker">22</A>.</P><!--TOC section How it works: Pluggable types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="pluggable-types">1.1</A>&#XA0;&#XA0;How it works: Pluggable types</H2><!--SEC END --><P>The Checker Framework supports adding
pluggable type systems to the Java language in a backward-compatible way.
Java&#X2019;s built-in typechecker finds and prevents many errors &#X2014; but it
doesn&#X2019;t find and prevent <EM>enough</EM> errors. The Checker Framework lets you
run an additional typechecker as a plug-in to the javac compiler. Your
code stays completely backward-compatible: your code compiles with any
Java compiler, it runs on any JVM, and your coworkers don&#X2019;t have to use the
enhanced type system if they don&#X2019;t want to. You can check only part of
your program. Type inference tools exist to help you annotate your
code.</P><P>A type system designer uses the Checker Framework to define type qualifiers
and their semantics, and a
compiler plug-in (a &#X201C;checker&#X201D;) enforces the semantics. Programmers can
write the type qualifiers in their programs and use the plug-in to detect
or prevent errors. The Checker Framework is useful both to programmers who
wish to write error-free code, and to type system designers who wish to
evaluate and deploy their type systems.</P><P>This document uses the terms &#X201C;checker&#X201D;, &#X201C;checker plugin&#X201D;,
&#X201C;type-checking compiler plugin&#X201D;, and &#X201C;annotation processor&#X201D; as
synonyms.</P><!--TOC section Installation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="installation">1.2</A>&#XA0;&#XA0;Installation</H2><!--SEC END --><P>This section describes how to install the binary release of the Checker
Framework. The binary release contains everything that you need, both to
run checkers and to write your own checkers. As an alternative, you can
build the latest development version from source
(Section&#XA0;<A HREF="#build-source">25.3</A>).</P><P><B>Requirement:</B>
You must have <B>JDK 6</B> or later installed. You can get JDK 6 from
<A HREF="http://www.oracle.com/technetwork/java/javase/downloads/index.html">Oracle</A>
or elsewhere. If you are using Apple Mac OS X, you can use
<A HREF="http://developer.apple.com/search/index.php?q=java">Apple&#X2019;s implementation</A>,
<A HREF="http://landonf.bikemonkey.org/static/soylatte/">SoyLatte</A>,
or the <A HREF="http://openjdk.java.net/">OpenJDK</A>.</P><P>The installation process is simple! (For a set of commands that you can
copy and paste into your command shell, see
Section&#XA0;<A HREF="#javac-installation">23.1</A>.)
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Download the Checker Framework distribution
(<A HREF="http://types.cs.washington.edu/checker-framework/current/checkers.zip"><TT>http://types.cs.washington.edu/checker-framework/current/checkers.zip</TT></A>).
</LI><LI CLASS="li-enumerate">Unzip it to create a <TT>checker-framework</TT> directory.<P>Then, set the
<TT>CHECKERS</TT> environment variable to the
<TT>checker-framework/checkers</TT> directory. For instance, if you use
the bash shell, then add this to your <TT>.bashrc</TT> file (don&#X2019;t forget
to replace the &#X201C;<TT>...</TT>&#X201D;!):
</P><PRE CLASS="verbatim">  export CHECKERS=.../checker-framework/checkers
</PRE><P>Also execute it on the command line, or log out and back in.</P></LI><LI CLASS="li-enumerate">Optionally, update your execution path.<P>When doing pluggable type-checking, you need to use a compiler that
understands type annotations. You can do this in two ways:</P><OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
Use the &#X201C;Type Annotations compiler&#X201D;, which is an updated version of the
OpenJDK javac compiler. If you add directory
<TT>$CHECKERS/binary</TT> to your path, then whenever
you run <TT>javac</TT>, you will use the updated compiler.
Alternately, whenever this document tells you to run <TT>javac</TT>, you
can instead run <TT>$CHECKERS/binary/javac</TT>.
The Type Annotations compiler is
backward-compatible, so using it should have no negative consequences.</LI><LI CLASS="li-enumerate">Use any version of javac, but pass an extra <TT>-Xbootclasspath/p</TT> and
<TT>-jar</TT> argument. For
example:<PRE CLASS="verbatim">  # Unix
  java -Xbootclasspath/p:$CHECKERS/binary/jsr308-all.jar \
       -jar $CHECKERS/binary/jsr308-all.jar -version

  # Windows
  java -Xbootclasspath/p:%CHECKERS%\binary\jsr308-all.jar
       -jar %CHECKERS%\binary\jsr308-all.jar -version
</PRE><P>The command should be all on one line, and followed by the javac arguments
such as <TT>-processor</TT> and file names.</P></LI></OL></LI></OL><P>To ensure that it was installed properly, run <TT>javac -version</TT> (using the
full pathname to <TT>javac</TT> if you did not add it to your path).</P><P>The output should be:</P><PRE CLASS="verbatim">  javac 1.7.0-jsr308-1.2.6
</PRE><P>That&#X2019;s all there is to it! Now you are ready to start using the checkers.</P><P>Section&#XA0;<A HREF="#example-use">1.3</A> walks you through a simple example. More detailed
instructions for using a checker appear in Chapter&#XA0;<A HREF="#using-a-checker">2</A>.</P><!--TOC section Example use: detecting a null pointer bug-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="example-use">1.3</A>&#XA0;&#XA0;Example use: detecting a null pointer bug</H2><!--SEC END --><P>To run a checker on a source file, just run javac as usual, passing the
<TT>-processor</TT> flag. (You can also use an IDE or other build tool; see
Chapter&#XA0;<A HREF="#external-tools">23</A>.)</P><P>For instance, if you usually run the compiler like
this:</P><PRE CLASS="verbatim">  javac Foo.java Bar.java
</PRE><P>then you will instead use the command line:</P><PRE>
  javac -processor <I>ProcessorName</I> Foo.java Bar.java
</PRE><P>but take note that the <TT>javac</TT> command must refer to the Type
Annotations compiler (see Section&#XA0;<A HREF="#installation">1.2</A>).</P><P>If you usually do your coding within an IDE, you will need to configure
the IDE. This manual contains instructions for
Ant (Section&#XA0;<A HREF="#ant-task">23.2</A>),
Maven (Section&#XA0;<A HREF="#maven-plugin">23.3</A>),
IntelliJ IDEA (Section&#XA0;<A HREF="#intellij">23.5</A>),
Eclipse (Section&#XA0;<A HREF="#eclipse">23.6</A>), and
tIDE (Section&#XA0;<A HREF="#tide">23.7</A>).
Otherwise, see your IDE documentation for details.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Let&#X2019;s consider this very simple Java class. One local variable is
annotated as <TT>NonNull</TT>, indicating that <TT>ref</TT> must be a reference to a
non-null object. Save the file as <TT>GetStarted.java</TT>.<PRE CLASS="verbatim">import checkers.nullness.quals.*;

public class GetStarted {
    void sample() {
        @NonNull Object ref = new Object();
    }
}
</PRE></LI><LI CLASS="li-enumerate">Run the nullness checker on the class.
Either run this command:
<PRE CLASS="verbatim">  javac -processor checkers.nullness.NullnessChecker GetStarted.java
</PRE><P>or compile from within your IDE, which you have customized to use the JSR
308 compiler and to pass the extra arguments.</P><P>The compilation should complete without any errors.</P></LI><LI CLASS="li-enumerate">Let&#X2019;s introduce an error now. Modify <TT>ref</TT>&#X2019;s assignment to:
<PRE CLASS="verbatim">  @NonNull Object ref = null;
</PRE></LI><LI CLASS="li-enumerate">Run the nullness checker again, just as before. This run should emit
the following error:
<PRE CLASS="verbatim">GetStarted.java:5: incompatible types.
found   : @Nullable &lt;nulltype&gt;
required: @NonNull Object
        @NonNull Object ref = null;
                              ^
1 error
</PRE><P>The type qualifiers (e.g., <TT>@NonNull</TT>) are permitted anywhere
that would write a type, including generics and casts; see
Section&#XA0;<A HREF="#writing-annotations">2.1</A>.</P><PRE>
  <U>@Interned</U> String intern() <TT>{</TT> ... <TT>}</TT>             // return value
  int compareTo(<U>@NonNull</U> String other) <TT>{</TT> ... <TT>}</TT>  // parameter
  <U>@NonNull</U> List&lt;<U>@Interned</U> String&gt; messages;     // non-null list of interned Strings
</PRE></LI></OL><HR><!--TOC chapter Using a checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="using-a-checker">Chapter&#XA0;2</A>&#XA0;&#XA0;Using a checker</H1><!--SEC END --><P>A pluggable type-checker enables you to detect certain bugs in your code,
or to prove that they are not present. The verification happens at compile
time.</P><P>Finding bugs, or verifying their absence, with a checker plugin is a two-step process, whose steps are
described in Sections&#XA0;<A HREF="#writing-annotations">2.1</A> and <A HREF="#running">2.2</A>.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">The programmer writes annotations, such as <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> and
<TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A>, that specify additional information about Java types.
(Or, the programmer uses an inference tool to automatically insert
annotations in his code: see Sections&#XA0;<A HREF="#nullness-inference">3.3.4</A> and&#XA0;<A HREF="#javari-inference">6.2.2</A>.)
It is possible to annotate only part of your code: see
Section&#XA0;<A HREF="#unannotated-code">20.1</A>.</LI><LI CLASS="li-enumerate">The checker reports whether the program contains any erroneous code
&#X2014; that is, code that is inconsistent with the annotations.</LI></OL><P>This chapter is structured as follows:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Section&#XA0;<A HREF="#writing-annotations">2.1</A>: How to write annotations
</LI><LI CLASS="li-itemize">Section&#XA0;<A HREF="#running">2.2</A>: How to run a checker
</LI><LI CLASS="li-itemize">Section&#XA0;<A HREF="#checker-guarantees">2.3</A>: What the checker guarantees
</LI><LI CLASS="li-itemize">Section&#XA0;<A HREF="#tips-about-writing-annotations">2.4</A>: Tips about writing annotations
</LI></UL><P>Additional topics that apply to all checkers are covered later in the manual:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Chapter&#XA0;<A HREF="#advanced-type-system-features">19</A>: Advanced type system features
</LI><LI CLASS="li-itemize">Chapter&#XA0;<A HREF="#warnings-and-legacy">20</A>: Handling warnings and legacy code
</LI><LI CLASS="li-itemize">Chapter&#XA0;<A HREF="#annotating-libraries">21</A>: Annotating libraries
</LI><LI CLASS="li-itemize">Chapter&#XA0;<A HREF="#writing-a-checker">22</A>: How to create a new checker
</LI><LI CLASS="li-itemize">Chapter&#XA0;<A HREF="#external-tools">23</A>: Integration with external tools
</LI></UL><!--TOC section Writing annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-annotations">2.1</A>&#XA0;&#XA0;Writing annotations</H2><!--SEC END --><P>The syntax of type annotations in Java is specified by
<A HREF="http://types.cs.washington.edu/jsr308/">JSR 308</A>&#XA0;[<A HREF="#JSR308-2008-09-12">Ern08</A>]. Ordinary
Java permits annotations on declarations. JSR 308 permits annotations
anywhere that you would write a type, including generics and casts. You
can also write annotations to indicate type qualifiers for array levels and
receivers. Here are a few examples:</P><PRE>
  <U>@Interned</U> String intern() <TT>{</TT> ... <TT>}</TT>             // return value
  int compareTo(<U>@NonNull</U> String other) <TT>{</TT> ... <TT>}</TT>  // parameter
  String toString() <U>@ReadOnly</U> <TT>{</TT> ... <TT>}</TT>           // receiver ("this" parameter)
  <U>@NonNull</U> List&lt;<U>@Interned</U> String&gt; messages;     // generics:  non-null list of interned Strings
  <U>@Interned</U> String <U>@NonNull</U> [] messages;        // arrays:  non-null array of interned Strings
  myDate = (<U>@ReadOnly</U> Date) readonlyObject;     // cast
</PRE><P>You can also write the annotations within comments, as in
<TT>List&lt;/*@NonNull*/ String&gt;</TT>. The Type Annotations compiler, which is
distributed with the Checker Framework, will still process
the annotations.
However, your code will remain compilable by people who are not using the
Type Annotations compiler. For more details, see
Section&#XA0;<A HREF="#annotations-in-comments">20.3.1</A>.</P><!--TOC subsection Distributing your annotated project-->
<H3 CLASS="subsection"><A NAME="distributing"><!--SEC ANCHOR -->2.1.1&#XA0;&#XA0;Distributing your annotated project</A></H3><!--SEC END --><P>If your code contains annotations, then your code has a dependency on the
annotation declarations. People who want to compile or run your code may
need declarations of the annotations on their classpath.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
To perform pluggable type-checking, all of the Checker Framework (which
also contains the annotation declarations) is needed.
</LI><LI CLASS="li-itemize">To compile the code:
<UL CLASS="itemize"><LI CLASS="li-itemize">
If you wrote annotations in comments (see
Section&#XA0;<A HREF="#annotations-in-comments">20.3.1</A>) and used implicit import
statements (see Section&#XA0;<A HREF="#implicit-import-statements">20.3.2</A>), then the code
can be compiled by any Java compiler, without needing declarations of the
annotations.
</LI><LI CLASS="li-itemize">Otherwise, compiling the code requires a declaration of the annotations.
These appear in the full Checker Framework. Additionally, the Checker
Framework distribution <TT>.zip</TT> file contains a small jar file,
<TT>checkers-quals.jar</TT>, that only contains the definitions of the
distributed qualifiers, without any support for type-checking.
</LI></UL>
</LI><LI CLASS="li-itemize">To run the code:
<UL CLASS="itemize"><LI CLASS="li-itemize">
If you compiled the code without using the annotation declarations, then
no annotation declarations are needed.
</LI><LI CLASS="li-itemize">If you compiled the code using the annotation declarations, then users
may need to have the annotation declarations on their classpath.
</LI></UL>
</LI></UL><P>A simple rule of thumb is as follows. When distributing your source code,
you may wish to include either the Checker Framework jar file or the
<TT>checkers-quals.jar</TT> file. When distributing compiled binaries, you
may wish to compile them without using the annotations, or include the
contents of <TT>checkers-quals.jar</TT> in your distribution.</P><!--TOC section Running a checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="running">2.2</A>&#XA0;&#XA0;Running a checker</H2><!--SEC END --><P>To run a checker plugin, run the compiler <TT>javac</TT> as usual,
but pass the <TT>-processor </TT><TT><EM>plugin_class</EM></TT> command-line
option.
(You can run a checker from within your favorite IDE or build system. See
Chapter&#XA0;<A HREF="#external-tools">23</A> for details about
Ant (Section&#XA0;<A HREF="#ant-task">23.2</A>),
Maven (Section&#XA0;<A HREF="#maven-plugin">23.3</A>),
IntelliJ IDEA (Section&#XA0;<A HREF="#intellij">23.5</A>),
Eclipse (Section&#XA0;<A HREF="#eclipse">23.6</A>),
and
tIDE (Section&#XA0;<A HREF="#tide">23.7</A>), and about customizing other IDEs and build tools.)
Remember that you must be using the
Type Annotations version of <TT>javac</TT>, which you already installed (see Section&#XA0;<A HREF="#installation">1.2</A>).</P><P>Two concrete examples (using the Nullness checker) are:</P><PRE CLASS="verbatim">  javac -processor checkers.nullness.NullnessChecker MyFile.java
  javac -processor checkers.nullness.NullnessChecker -Xbootclasspath/p:checkers/jdk/jdk.jar MyFile.java
</PRE><P>For a discussion of the <TT>-Xbootclasspath/p</TT> argument, see
Section&#XA0;<A HREF="#skeleton-using">21.3</A>.</P><P>The checker is run only on any Java file that javac compiles.
This includes all Java files specified on the command line (or
created by another annotation processor). It may also include other of
your Java files (but not if a more recent <TT>.class</TT> file exists).
Even when the checker does not analyze a class (say, the class was
already compiled, or source code is not available), it does check
the <EM>uses</EM> of those classes in the source code being compiled.</P><P>You can always compile the code without the <TT>-processor</TT>
command-line option, but in that case no checking of the type
annotations is performed. The annotations are still written to the
resulting <TT>.class</TT> files, however.</P><!--TOC subsection Summary of command-line options-->
<H3 CLASS="subsection"><A NAME="checker-options"><!--SEC ANCHOR -->2.2.1&#XA0;&#XA0;Summary of command-line options</A></H3><!--SEC END --><P>You can pass command-line arguments to a checker via javac&#X2019;s standard <TT>-A</TT>
option (&#X201C;<TT>A</TT>&#X201D; stands for &#X201C;annotation&#X201D;). All of the distributed
checkers support the following command-line options:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>-AskipUses</TT> Suppress all errors and warnings at all uses of a
given class; see Section&#XA0;<A HREF="#suppressing-warnings">20.2</A>
</LI><LI CLASS="li-itemize"><TT>-AskipDefs</TT> Suppress all errors and warnings within the definition of a
given class; see Section&#XA0;<A HREF="#suppressing-warnings">20.2</A>
</LI><LI CLASS="li-itemize"><TT>-Astubs</TT> List of stub files or directories; see Section&#XA0;<A HREF="#stub-using">21.2.2</A>
</LI><LI CLASS="li-itemize"><TT>-Alint</TT> Enable or disable optional checks; see Section&#XA0;<A HREF="#lint-options">20.2.4</A>
</LI><LI CLASS="li-itemize"><TT>-Awarns</TT> Treat checker errors as warnings. If you use this, you
may wish to also supply <TT>-Xmaxwarns 10000</TT>, because by default
<TT>javac</TT> prints at most 100 warnings.
</LI><LI CLASS="li-itemize"><TT>-Afilenames</TT>, <TT>-Anomsgtext</TT>, <TT>-Ashowchecks</TT>, <TT>-AprintErrorStack</TT>, <TT>-AprintAllQualifiers</TT>, <TT>-Aignorejdkastub</TT> Aids for testing or debugging a checker; see Section&#XA0;<A HREF="#debugging-options">22.8</A>
</LI></UL><P>Some checkers support additional options, such as <TT>-Aquals</TT> for the Basic
Checker to check; see Chapter&#XA0;<A HREF="#basic-checker">15</A>.</P><P>Here are some standard javac command-line options that you may find useful.
Many of them contain the word &#X201C;processor&#X201D;, because in javac jargon, a
checker is a type of &#X201C;annotation processor&#X201D;.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>-processor</TT> Names the checker to be
run; see Section&#XA0;<A HREF="#running">2.2</A>
</LI><LI CLASS="li-itemize"><TT>-processorpath</TT> Indicates where to search for the
checker; should also contain any qualifiers used by the Basic
Checker; see Section&#XA0;<A HREF="#basic-example">15.2</A>
</LI><LI CLASS="li-itemize"><TT>-proc:</TT>{<TT>none</TT>,<TT>only</TT>} Controls whether checking
happens; <TT>-proc:none</TT>
means to skip checking; <TT>-proc:only</TT> means to do only
checking, without any subsequent compilation; see
Section&#XA0;<A HREF="#checker-auto-discovery">2.2.2</A>
</LI><LI CLASS="li-itemize"><TT>-Xbootclasspath/p:</TT> Indicates where to find the annotated JDK classes;
see Section&#XA0;<A HREF="#skeleton-using">21.3</A>
</LI><LI CLASS="li-itemize"><TT>-implicit:class</TT> Suppresses warnings about implicitly compiled files
(not named on the command line); see Section&#XA0;<A HREF="#ant-task">23.2</A>
</LI><LI CLASS="li-itemize"><TT>-XDTA:spacesincomments</TT> parse annotation comments even when they
contain spaces; applicable only to the Type Annotations compiler; see Section&#XA0;<A HREF="#annotations-in-comments">20.3.1</A>
</LI><LI CLASS="li-itemize"><TT>-J</TT> Supply an argument to the JVM that is running javac; example:
<TT>-J-Djsr308_imports=checkers.nullness.quals.*</TT>; see Section&#XA0;<A HREF="#implicit-import-statements">20.3.2</A>
</LI></UL><!--TOC subsection Checker auto-discovery-->
<H3 CLASS="subsection"><A NAME="checker-auto-discovery"><!--SEC ANCHOR -->2.2.2&#XA0;&#XA0;Checker auto-discovery</A></H3><!--SEC END --><P>&#X201C;Auto-discovery&#X201D; makes the <TT>javac</TT> compiler always run a checker
plugin, even if you do not explicitly pass the <TT>-processor</TT>
command-line option. This can make your command line shorter, and ensures
that your code is checked even if you forget the command-line option.</P><P>To enable auto-discovery, place a configuration file named
<TT>META-INF/services/javax.annotation.processing.Processor</TT>
in your classpath. The file contains the names of the checker plugins to
be used, listed one per line. For instance, to run the Nullness and the
Interning checkers automatically, the configuration file should contain:</P><PRE CLASS="verbatim">  checkers.nullness.NullnessChecker
  checkers.interning.InterningChecker
</PRE><P>You can disable this auto-discovery mechanism by passing the
<TT>-proc:none</TT> command-line option to <TT>javac</TT>, which disables all
annotation processing including all pluggable type-checking.</P><!--TOC section What the checker guarantees-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="checker-guarantees">2.3</A>&#XA0;&#XA0;What the checker guarantees</H2><!--SEC END --><P>A checker can guarantee that a particular property holds throughout the
code. For example, the Nullness checker (Chapter&#XA0;<A HREF="#nullness-checker">3</A>)
guarantees that every expression whose type is a <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type never
evaluates to null. The Interning checker (Chapter&#XA0;<A HREF="#interning-checker">4</A>)
guarantees that every expression whose type is an <TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> type
evaluates to an interned value. The checker makes its guarantee by
examining every part of your program and verifying that no part of the
program violates the guarantee.</P><P>There are some limitations to the guarantee.</P><UL CLASS="itemize"><LI CLASS="li-itemize">A compiler plugin can check only those parts of your program that you run
it on. If you compile some parts of your program without running the
checker, then there is no guarantee that the entire program satisfies the
property being checked. Some examples of un-checked code are:<UL CLASS="itemize"><LI CLASS="li-itemize">
Code compiled without the <TT>-processor</TT> switch, including any
external library supplied as a <TT>.class</TT> file.
</LI><LI CLASS="li-itemize">Code compiled with the <TT>-AskipUses</TT> or <TT>-AskipDefs</TT>
properties (see Section&#XA0;<A HREF="#suppressing-warnings">20.2</A>).
</LI><LI CLASS="li-itemize">Suppression of warnings, such as via the <TT>@SuppressWarnings</TT>
annotation (see Section&#XA0;<A HREF="#suppressing-warnings">20.2</A>).
</LI><LI CLASS="li-itemize">Native methods (because the implementation is not Java code, it cannot
be checked).
</LI></UL><P>In each of these cases, any <EM>use</EM> of the code is checked &#X2014; for
example, a call to a native method must be compatible with any
annotations on the native method&#X2019;s signature.
However, the annotations on the un-checked code are trusted; there is no
verification that the implementation of the native method satisfies the
annotations.</P></LI><LI CLASS="li-itemize">Reflection can violate the Java type system, and
the checkers are not sophisticated enough to reason about the possible
effects of reflection. Similarly, deserialization and cloning can
create objects that could not result from normal constructor calls, and
that therefore may violate the property being checked.</LI><LI CLASS="li-itemize">Your code should pass the Java compiler without errors or warnings. In
particular, your code should use generic types, with no uses of raw types.
Misuse of generics, including casting away generic types, can cause other
errors to be missed.</LI><LI CLASS="li-itemize">
The Checker Framework does not yet support annotations on intersection
types (see
<A HREF="http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.9">JLS &#XA7;4.9</A>). As a result, checkers cannot provide guarantees about
intersection types.</LI><LI CLASS="li-itemize">Specific checkers may have other limitations; see their documentation for
details.</LI></UL><P>A checker can be useful in finding bugs or in verifying part of a
program, even if the checker is unable to verify the correctness of an
entire program.</P><P>In order to avoid a flood of unhelpful warnings, many of the checkers avoid
issuing the same warning multiple times. For example, in this code:</P><PRE CLASS="verbatim">  @Nullable Object x = ...;
  x.toString();                 // warning
  x.toString();                 // no warning
</PRE><P>In this case, the second call to <TT>toString</TT> cannot possibly throw a null
pointer warning &#X2014; <TT>x</TT> is non-null if control flows to the second
statement.
In other cases, a checker avoids issuing later warnings with the same cause
even when later code in a method might also fail.
This does not
affect the soundness guarantee, but a user may need to examine more
warnings after fixing the first ones identified. (More often, at least in
our experience to date, a single fix corrects all the warnings.)</P><P>If you find that a checker fails to issue a warning that it
should, then please report a bug (see Section&#XA0;<A HREF="#reporting-bugs">25.2</A>).</P><!--TOC section Tips about writing annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="tips-about-writing-annotations">2.4</A>&#XA0;&#XA0;Tips about writing annotations</H2><!--SEC END --><!--TOC subsection How to get started annotating legacy code-->
<H3 CLASS="subsection"><A NAME="get-started-with-legacy-code"><!--SEC ANCHOR -->2.4.1&#XA0;&#XA0;How to get started annotating legacy code</A></H3><!--SEC END --><P>Annotating an entire existing program may seem like a daunting task. But,
if you approach it systematically and do a little bit at a time, you will
find that it is manageable.</P><P>You should start with a property that matters to you, to achieve the best
benefits. It is easiest to add annotations if you know the code or the
code contains documentation; you will find that you spend most of your time
understanding the code, and very little time actually writing annotations
or running the checker.</P><P>Don&#X2019;t get discouraged if you see many type-checker warnings at first.
Often, adding just a few missing annotations will eliminate many warnings,
and you&#X2019;ll be surprised how fast the process goes overall.</P><P>It is best to annotate one package at a time,
and to annotate the entire package so that you don&#X2019;t forget any classes
(failing to annotate a class can lead to unexpected results).
Start as close to the leaves of the call tree as possible, such as with
libraries &#X2014; that is,
start with methods/classes/packages that have few dependences on other
code or, equivalently, start with code that a lot of your other code
depends on. The reason for this is that it is
easiest to annotate a class if the code it calls has already been
annotated.</P><P>For each class, read its Javadoc. For instance, if you are adding
annotations for the Nullness Checker (Section&#XA0;<A HREF="#nullness-checker">3</A>), then
you can search the documentation for &#X201C;null&#X201D; and then add <TT>@Nullable</TT>
anywhere appropriate. Do not annotate the method bodies yet &#X2014;
first, get the signatures and fields annotated. The only reason to even
<EM>read</EM> the method bodies yet is to determine signature annotations for
undocumented methods &#X2014;
for example, if the method returns null, you know its return type should be
annotated <TT>@Nullable</TT>, and a parameter that is compared against <TT>null</TT>
may need to be annotated <TT>@Nullable</TT>. If you are only annotating
signatures (say, for a library you do not maintain and do not wish to
check), you are now done.</P><P>If you wish to check the implementation, then after the signatures are
annotated, run the checker. Then, add method body annotations (usually,
few are necessary), fix bugs in code, and add annotations to signatures
where necessary. If signature annotations are necessary, then you may want
to fix the documentation that did not indicate the property; but this isn&#X2019;t
strictly necessary, since the annotations that you wrote provide that
documentation.</P><P>You may wonder about the effect of adding a given annotation &#X2014; how many
other annotations it will require, or whether it conflicts with other code.
Suppose you have added an annotation to a method parameter. You could
manually examine all callees. A better way can be to save the checker
output before adding the annotation, and to compare it to the checker
output after adding the annotation. This helps you to focus on the
specific consequences of your change.</P><P>Also see Chapter&#XA0;<A HREF="#warnings-and-legacy">20</A>, which tells you what to do when
you are unable to eliminate checker warnings.</P><!--TOC subsection Do not annotate local variables unless necessary-->
<H3 CLASS="subsection"><A NAME="tips-local-inference"><!--SEC ANCHOR -->2.4.2&#XA0;&#XA0;Do not annotate local variables unless necessary</A></H3><!--SEC END --><P>The checker infers annotations for local variables (see
Section&#XA0;<A HREF="#type-refinement">19.1.2</A>). Usually, you only need to annotate fields
and method signatures. After doing those, you can add annotations inside
method bodies if the checker is unable to infer the correct annotation, if
you need to suppress a warning (see Section&#XA0;<A HREF="#suppressing-warnings">20.2</A>),
etc.</P><!--TOC subsection Annotations indicate normal behavior-->
<H3 CLASS="subsection"><A NAME="annotate-normal-behavior"><!--SEC ANCHOR -->2.4.3&#XA0;&#XA0;Annotations indicate normal behavior</A></H3><!--SEC END --><P>You should use annotations to indicate <EM>normal</EM> behavior. The
annotations indicate all the values that you <EM>want</EM> to flow to
reference &#X2014; not every value that might possibly flow there if your
program has a bug.</P><P>Many methods are guaranteed to throw an exception if they are passed <TT>null</TT>
as an argument. Examples include</P><PRE CLASS="verbatim">  java.lang.Double.valueOf(String)
  java.lang.String.contains(CharSequence)
  org.junit.Assert.assertNotNull(Object)
  com.google.common.base.Preconditions.checkNotNull(Object)
</PRE><P><TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A> (see Section&#XA0;<A HREF="#nullness-annotations">3.2</A>)
might seem like a reasonable annotation for the parameter,
for two reasons. First, <TT>null</TT> is a legal argument with a
well-defined semantics: throw an exception. Second, <TT>@Nullable</TT>
describes a possible program execution: it might be possible for
<TT>null</TT> to flow there, if your program has a bug.</P><P>However, it is never useful for a programmer to pass <TT>null</TT>. It is
the programmer&#X2019;s intention that <TT>null</TT> never flows there. If
<TT>null</TT> does flow there, the program will not continue normally.</P><P>Therefore, you should mark such parameters as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>, indicating
the intended use of the method. When you use the <TT>@NonNull</TT>
annotation, the checker is able to issue compile-time warnings about
possible run-time exceptions, which is its purpose. Marking the parameter
as <TT>@Nullable</TT> would suppress such warnings, which is undesirable.</P><!--TOC subsection Subclasses must respect superclass annotations-->
<H3 CLASS="subsection"><A NAME="annotations-are-a-contract"><!--SEC ANCHOR -->2.4.4&#XA0;&#XA0;Subclasses must respect superclass annotations</A></H3><!--SEC END --><P>An annotation indicates a guarantee that a client can depend upon. A subclass
is not permitted to <EM>weaken</EM> the contract; for example,
if a method accepts <TT>null</TT> as an argument, then every overriding
definition must also accept <TT>null</TT>.
A subclass is permitted to <EM>strengthen</EM> the contract; for example,
if a method does <EM>not</EM> accept <TT>null</TT> as an argument, then an
overriding definition is permitted to accept <TT>null</TT>.</P><P>As a bad example, consider an erroneous <TT>@Nullable</TT> annotation at
line 141 of <A HREF="http://code.google.com/p/google-collections/source/browse/trunk/src/com/google/common/collect/Multiset.java"><TT>com/google/common/collect/Multiset.java</TT></A>, version r78:</P><PRE CLASS="verbatim">101  public interface Multiset&lt;E&gt; extends Collection&lt;E&gt; {
...
122    /**
123     * Adds a number of occurrences of an element to this multiset.
...
129     * @param element the element to add occurrences of; may be {@code null} only
130     *     if explicitly allowed by the implementation
...
137     * @throws NullPointerException if {@code element} is null and this
138     *     implementation does not permit null elements. Note that if {@code
139     *     occurrences} is zero, the implementation may opt to return normally.
140     */
141    int add(@Nullable E element, int occurrences);
</PRE><P>There exist implementations of Multiset that permit <TT>null</TT> elements,
and implementations of Multiset that do not permit <TT>null</TT> elements. A
client with a variable <TT>Multiset ms</TT> does not know which variety of
Multiset <TT>ms</TT> refers to. However, the <TT>@Nullable</TT> annotation
promises that <TT>ms.add(null, 1)</TT> is permissible. (Recall from
Section&#XA0;<A HREF="#annotate-normal-behavior">2.4.3</A> that annotations should indicate
normal behavior.)</P><P>If parameter <TT>element</TT> on line 141 were to be annotated, the correct
annotation would be <TT>@NonNull</TT>. Suppose a client has a reference to
same Multiset <TT>ms</TT>. The only way the client can be sure not to throw an exception is to pass
only non-<TT>null</TT> elements to <TT>ms.add()</TT>. A particular class
that implements Multiset could declare <TT>add</TT> to take a
<TT>@Nullable</TT> parameter. That still satisfies the original contract.
It strengthens the contract by promising even more: a client with such a
reference can pass any non-<TT>null</TT> value to <TT>add()</TT>, and may also
pass <TT>null</TT>.</P><P><B>However</B>, the best annotation for line 141 is no annotation at all.
The reason is that each implementation of the Multiset interface should
specify its own nullness properties when it specifies the type parameter
for Multiset. For example, two clients could be written as</P><PRE CLASS="verbatim">  class MyNullPermittingMultiset implements Multiset&lt;@Nullable Object&gt; { ... }
  class MyNullProhibitingMultiset implements Multiset&lt;@NonNull Object&gt; { ... }
</PRE><P>or, more generally, as</P><PRE CLASS="verbatim">  class MyNullPermittingMultiset&lt;E extends @Nullable Object&gt; implements Multiset&lt;E&gt; { ... }
  class MyNullProhibitingMultiset&lt;E extends @NonNull Object&gt; implements Multiset&lt;E&gt; { ... }
</PRE><P>Then, the specification is more informative, and the Checker Framework is
able to do more precise checking, than if line 141 has an annotation.</P><P>It is a pleasant feature of the Checker Framework that in many cases, no
annotations at all are needed on type parameters such as <TT>E</TT> in <TT>MultiSet</TT>.</P><!--TOC subsection Annotations on constructor invocations-->
<H3 CLASS="subsection"><A NAME="annotations-on-constructor-invocations"><!--SEC ANCHOR -->2.4.5&#XA0;&#XA0;Annotations on constructor invocations</A></H3><!--SEC END --><P>In the checkers distributed with the Checker Framework, an annotation on a
constructor invocation is equivalent to a cast on a constructor result.
That is, the following two expressions have identical semantics: one is
just shorthand for the other.</P><PRE CLASS="verbatim">  new @ReadOnly Date()
  (@ReadOnly Date) new Date()
</PRE><P>However, you should rarely have to use this. The Checker Framework will
determine the qualifier on the result, based on the &#X201C;return value&#X201D;
annotation on the constructor definition. The &#X201C;return value&#X201D; annotation
appears before the constructor name, for example:</P><PRE CLASS="verbatim">  class MyClass {
    @ReadOnly MyClass() { ... }
  }
</PRE><P>In general, you should only use an annotation on a constructor invocation
when you know that the cast is
guaranteed to succeed. An example from the IGJ checker
(Chapter&#XA0;<A HREF="#igj-checker">5</A>) is <TT>new @Immutable MyClass()</TT> or <TT>new
@Mutable MyClass()</TT>, where you know that every other reference to the class
is annotated <TT>@ReadOnly</TT>.</P><!--TOC subsection When to use (and not use) type qualifiers-->
<H3 CLASS="subsection"><A NAME="when-to-use-type-qualifiers"><!--SEC ANCHOR -->2.4.6&#XA0;&#XA0;When to use (and not use) type qualifiers</A></H3><!--SEC END --><P>For some programming tasks, you can use either a Java subclass or a type
qualifier. For instance, suppose that your code currently uses
<TT>String</TT> to represent an address. You could create a new <TT>Address</TT>
class and refactor your code to use it, or you could create a
<TT>@Address</TT> annotation and apply it to some uses of <TT>String</TT> in
your code. If both of these are truly possible, then it is probably more
foolproof to use the Java class. We do not encourage you to use type
qualifiers as a poor substitute for classes. However, sometimes type
qualifiers are a better choice.</P><P>Using a new class may make your code incompatible with existing libraries or
clients. Brian Goetz expands on this issues in an article on the
pseudo-typedef antipattern&#XA0;[<A HREF="#Goetz2006:typedef">Goe06</A>]. Even if compatibility
is not a concern, a code change may introduce bugs, whereas adding
annotations does not change the run-time behavior. It is possible to add
annotations to existing code, including code you do not maintain or cannot
change. It is possible to annotate primitive types without converting them
to wrappers, which would make the code both uglier and slower.</P><P>Type qualifiers can be applied to any type, including final classes that
cannot be subclassed.</P><P>Type qualifiers permit you to remove operations, with a compile-time
guarantee. An example is mutating methods that are forbidden by immutable
types (see Chapters&#XA0;<A HREF="#igj-checker">5</A> and&#XA0;<A HREF="#javari-checker">6</A>). More
generally, type qualifiers permit creating a new supertype, not just a
subtype, of an existing Java type.</P><P>A final reason is efficiency. Type qualifiers can be more
efficient, since there is no run-time representation such as a wrapper
or a separate class, nor introduction of dynamic dispatch for methods that
could otherwise be statically dispatched.</P><!--TOC subsection What to do if a checker issues a warning about your code-->
<H3 CLASS="subsection"><A NAME="handling-warnings"><!--SEC ANCHOR -->2.4.7&#XA0;&#XA0;What to do if a checker issues a warning about your code</A></H3><!--SEC END --><P>When you first run a type-checker on your code, it is likely to issue
warnings or errors. For each warning, try to understand why the checker
issues it. (For example, if you are using the
<A HREF="#nullness-checker">Nullness checker</A>
(Chapter&#XA0;<A HREF="#nullness-checker">3</A>), try to understand why it cannot prove
that no null pointer exception ever occurs.) The reason will sometimes be
an actually possible null dereference, sometimes be a weakness of the
annotations, and sometimes be a weakness of the checker. You will need to
examine your code, and possibly write test cases, to understand the reason.</P><P>If there is an actual possible null dereference, then fix your code to
prevent that crash.</P><P>If there is a weakness in the annotations, then improve the annotations.
For example, continuing the Nullness Checker example, if a particular
variable is annotated as <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A> but it
actually never contains <TT>null</TT> at run time, then change the annotation to 
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>. The weakness might be in the
annotations in your code, or in the annotations in a library that your code
calls. Another possible problem is that a library is unannotated (see
Chapter&#XA0;<A HREF="#annotating-libraries">21</A>).</P><P>If there is a weakness in the checker, then your code is safe &#X2014; it never
suffers the specific run-time error &#X2014; but the checker cannot prove this
fact. This is most often because the checker is not omniscient, and some
tricky coding paradigms are beyond its analysis capabilities; in this
case, you should suppress the warning (see
Chapter&#XA0;<A HREF="#suppressing-warnings">20.2</A>). In other cases, the problem is a
bug in the checker; in this case, please report the bug (see
Chapter&#XA0;<A HREF="#reporting-bugs">25.2</A>).</P><HR><!--TOC chapter Nullness checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="nullness-checker">Chapter&#XA0;3</A>&#XA0;&#XA0;Nullness checker</H1><!--SEC END --><P>If the Nullness checker issues no warnings for a given program, then
running that program will never throw a null pointer exception. This
guarantee enables a programmer to prevent errors from occurring when a
program is run. See Section&#XA0;<A HREF="#nullness-checks">3.1</A> for more details about
the guarantee and what is checked.</P><P>The most important annotations supported by the Nullness Checker are 
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> and 
<TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>.
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> is rarely written, because it is
the default. All of the annotations are explained in
Section&#XA0;<A HREF="#nullness-annotations">3.2</A>.</P><P>To run the Nullness Checker, supply the <TT>-processor
checkers.nullness.NullnessChecker</TT> command-line option to javac. For
examples, see Section&#XA0;<A HREF="#nullness-example">3.8</A>.</P><!--TOC section What the Nullness checker checks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="nullness-checks">3.1</A>&#XA0;&#XA0;What the Nullness checker checks</H2><!--SEC END --><P>The checker issues a warning in these cases:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">When an expression of non-<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type
is dereferenced, because it might cause a null pointer exception.
Dereferences occur not only when a field is accessed, but when an array
is indexed, an exception is thrown, a lock is taken in a synchronized
block, and more. For a complete description of all checks performed by
the Nullness checker, see the Javadoc for
<A HREF="doc/checkers/nullness/NullnessVisitor.html"><TT>NullnessVisitor</TT></A>.</LI><LI CLASS="li-enumerate">When an expression of <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type
might become null, because it
is a misuse of the type: the null value could flow to a dereference that
the checker does not warn about.<P>As a special case of an of <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>
type becoming null, the checker also warns whenever a field of
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type is not initialized in a
constructor. Also see the discussion of the <TT>-Alint=uninitialized</TT>
command-line option below.</P></LI></OL><P>This example illustrates the programming errors that the checker detects:</P><PRE CLASS="verbatim">  @Nullable Object   obj;  // might be null
  @NonNull  Object nnobj;  // never null
  ...
  obj.toString()         // checker warning:  dereference might cause null pointer exception
  nnobj = obj;           // checker warning:  nnobj may become null
  if (nnobj == null)     // checker warning:  redundant test
</PRE><P>Parameter passing and return values are checked analogously to assignments.</P><P>The Nullness Checker also checks the correctness, and correct use, of
rawness annotations for checking initialization (see
Section&#XA0;<A HREF="#raw-partially-initialized">3.5</A>) and of map key annotations (see
Section&#XA0;<A HREF="#map-keys">3.6</A>).</P><P>The checker performs additional checks if certain <TT>-Alint</TT>
command-line options are provided. (See
Section&#XA0;<A HREF="#alint">20.2.4</A> for more details about the <TT>-Alint</TT>
command-line option.)</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<A NAME="lint-nulltest"></A>If you supply the <TT>-Alint=nulltest</TT> command-line option, then the
checker warns when a null check is performed against a value that is
guaranteed to be non-null, as in <TT>("m" == null)</TT>. Such a check is
unnecessary and might indicate a programmer error or misunderstanding.
The lint option is disabled by default because sometimes such checks are
part of ordinary defensive programming. </LI><LI CLASS="li-enumerate"><A NAME="lint-uninitialized"></A>If you supply the <TT>-Alint=uninitialized</TT> command-line option, then
the checker warns if a constructor fails to initialize any field,
including <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A> types and primitive
types. Such a warning is unrelated to whether your code might throw a
null pointer exception. However, you might want to enable this warning
because it is better code style to supply an explicit initializer, even
if there is a default value such as <TT>0</TT> or <TT>false</TT>.
This command-line option does not affect the Nullness Checker&#X2019;s tests
that fields of <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type are
initialized &#X2014; such initialization is mandatory, not optional.</LI></OL><!--TOC section Nullness annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="nullness-annotations">3.2</A>&#XA0;&#XA0;Nullness annotations</H2><!--SEC END --><P>The Nullness checker uses three separate type hierarchies: one for nullness,
one for rawness (Section&#XA0;<A HREF="#raw-partially-initialized">3.5</A>),
and one for map keys (Section&#XA0;<A HREF="#map-keys">3.6</A>)
The Nullness checker has four varieties of annotations: nullness
type qualifiers, nullness method annotations, rawness type qualifiers, and
map key type
qualifiers.</P><!--TOC subsection Nullness qualifiers-->
<H3 CLASS="subsection"><A NAME="nullness-qualifiers"><!--SEC ANCHOR -->3.2.1&#XA0;&#XA0;Nullness qualifiers</A></H3><!--SEC END --><P>The nullness hierarchy contains these qualifiers:</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/Nullable.html"><B><TT>Nullable</TT></B></A></DT><DD CLASS="dd-description">
indicates a type that includes the null value. For example, the type <TT>Boolean</TT>
is nullable: a variable of type <TT>Boolean</TT> always has one of the
values <TT>TRUE</TT>, <TT>FALSE</TT>, or <TT>null</TT>.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/NonNull.html"><B><TT>NonNull</TT></B></A></DT><DD CLASS="dd-description">
indicates a type that does not include the null value. The type
<TT>boolean</TT> is non-null; a variable of type <TT>boolean</TT> always has
one of the values <TT>true</TT> or <TT>false</TT>. The type <TT>@NonNull
Boolean</TT> is also non-null: a variable of type <TT>@NonNull Boolean</TT>
always has one of the values <TT>TRUE</TT> or <TT>FALSE</TT> &#X2014; never
<TT>null</TT>. Dereferencing an expression of non-null type can never cause
a null pointer exception.<P>The <TT>@NonNull</TT> annotation is rarely written in a program, because it is
the default (see Section&#XA0;<A HREF="#null-defaults">3.3.2</A>).</P></DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/PolyNull.html"><B><TT>PolyNull</TT></B></A></DT><DD CLASS="dd-description">
indicates qualifier polymorphism. For a description of
<TT>@</TT><A HREF="doc/checkers/nullness/quals/PolyNull.html"><TT>PolyNull</TT></A>, see
Section&#XA0;<A HREF="#qualifier-polymorphism">18.2</A>.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/LazyNonNull.html"><B><TT>LazyNonNull</TT></B></A></DT><DD CLASS="dd-description">
indicates a reference that may be <TT>null</TT>, but if it ever becomes
non-<TT>null</TT>, then it never becomes <TT>null</TT> again. This is
appropriate for lazily-initialized fields, among other uses. When the
variable is read, its type is treated as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>, but when the variable is
assigned, its type is treated as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>.<P>Because the Nullness checker works intraprocedurally (it analyzes one
method at a time), when a <TT>LazyNonNull</TT> field is first read within a
method, the field cannot be assumed to be non-null. The benefit of
LazyNonNull over Nullable is its different interaction with
flow-sensitive type qualifier refinement (Section&#XA0;<A HREF="#type-refinement">19.1.2</A>).
After a check of a LazyNonNull
field, all subsequent accesses <EM>within that method</EM> can be assumed
to be NonNull, even after arbitrary external method calls that have
access to the given field.</P></DD></DL><P>Figure&#XA0;<A HREF="#fig:nonnull-hierarchy">3.1</A> shows part of the type hierarchy for the
Nullness type system.
(The annotations exist only at compile time; at run time, Java has no
multiple inheritance.)</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<DIV CLASS="center">
<IMG SRC="nullness-and-raw.png" ALT="nullness-and-raw.png"></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3.1: Partial type hierarchy for the Nullness type system.
Java&#X2019;s <TT>Object</TT> is expressed as <TT>@Nullable Object</TT>. Programmers can omit
most type qualifiers, because the default annotation
(Section&#XA0;<A HREF="#null-defaults">3.3.2</A>) is usually correct. Also shown is the
type hierarchy for rawness (Section&#XA0;<A HREF="#raw-partially-initialized">3.5</A>), which
indicates whether
initialization has completed. The two type hierarchies are independent but
inter-related. The Nullness Checker verifies both of these, as well as
another type hierarchy for map keys (Section&#XA0;<A HREF="#map-key-qualifiers">3.2.4</A>).</TD></TR>
</TABLE></DIV>
<A NAME="fig:nonnull-hierarchy"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection Nullness method annotations-->
<H3 CLASS="subsection"><A NAME="nullness-non-qualifiers"><!--SEC ANCHOR -->3.2.2&#XA0;&#XA0;Nullness method annotations</A></H3><!--SEC END --><P>The Nullness checker supports several annotations that specify method
behavior. These are declaration annotations, not type annotations: they
apply to the method itself rather than to some particular type.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/NonNullOnEntry.html"><B><TT>NonNullOnEntry</TT></B></A></DT><DD CLASS="dd-description">
indicates a method precondition: The annotated method expects the
specified variables (typically field references) to be non-null when the
method is invoked.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/AssertNonNullAfter.html"><B><TT>AssertNonNullAfter</TT></B></A></DT><DD CLASS="dd-description">
</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/AssertNonNullIfTrue.html"><B><TT>AssertNonNullIfTrue</TT></B></A></DT><DD CLASS="dd-description">
</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/AssertNonNullIfFalse.html"><B><TT>AssertNonNullIfFalse</TT></B></A></DT><DD CLASS="dd-description">
indicates a method postcondition. With <TT>@AssertNonNullAfter</TT>, the given
expressions are non-null after the method returns; this is useful for a
method that initializes a field, for example. With
<TT>@AssertNonNullIfTrue</TT> and <TT>@AssertNonNullIfFalse</TT>, if the annotated
method returns the given boolean value (true or false), then the given
expressions are non-null. See Section&#XA0;<A HREF="#conditional-nullness">3.3.3</A> and the
Javadoc for examples of their use.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/Pure.html"><B><TT>Pure</TT></B></A></DT><DD CLASS="dd-description">
indicates that the method has no (visible) side effects.
Furthermore, if the method is called multiple times with the same
arguments, then it returns the same result.<P>For example, consider the
following declaration and uses:</P><PRE CLASS="verbatim">        @Nullable Object getField(Object arg) { ... }

        ...
        if (x.getField(y) != null) {
          x.getField(y).toString();
        }
</PRE><P>Ordinarily, the Nullness Checker would issue a warning regarding the
<TT>toString()</TT> call, because the receiver <TT>x.getField(y)</TT> might
be <TT>null</TT>, according to the <TT>@Nullable</TT> annotation in the
declaration of <TT>getField</TT>. If you change the declaration of
<TT>getField</TT> to</P><PRE CLASS="verbatim">        @Pure @Nullable Object getField(Object arg) { ... }
</PRE><P>then the Nullness Checker issues no warnings, because it can reason that
the two invocations <TT>x.getField(y)</TT> have the same value, and
therefore that <TT>x.getField(y)</TT> is non-null within the then branch
of the if statement.</P><P>If a method is pure, then it would be legal to annotate its receiver and
every parameter as <TT>@ReadOnly</TT>, in the IGJ (Chapter&#XA0;<A HREF="#igj-checker">5</A>) or
Javari (Chapter&#XA0;<A HREF="#javari-checker">6</A>) type systems. The reverse is not
true, both because the method might side-effect a global variable and
because the method might not be deterministic.</P></DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/AssertParametersNonNull.html"><B><TT>AssertParametersNonNull</TT></B></A></DT><DD CLASS="dd-description">
is used for suppressing warnings, in very rare cases. See the Javadoc for
details.</DD></DL><!--TOC subsection Rawness qualifiers-->
<H3 CLASS="subsection"><A NAME="rawness-qualifiers-overview"><!--SEC ANCHOR -->3.2.3&#XA0;&#XA0;Rawness qualifiers</A></H3><!--SEC END --><P>The Nullness Checker supports rawness annotations that indicate whether
an object is fully initialized &#X2014; that is, whether its fields have all
been assigned.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/Raw.html"><B><TT>Raw</TT></B></A></DT><DD CLASS="dd-description">
</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/NonRaw.html"><B><TT>NonRaw</TT></B></A></DT><DD CLASS="dd-description">
</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/PolyRaw.html"><B><TT>PolyRaw</TT></B></A></DT><DD CLASS="dd-description">
</DD></DL><P>Use of these annotations can help you to type-check more
code. Figure&#XA0;<A HREF="#fig:nonnull-hierarchy">3.1</A> shows its type hierarchy. For
details, see Section&#XA0;<A HREF="#raw-partially-initialized">3.5</A>.</P><!--TOC subsection Map key qualifiers-->
<H3 CLASS="subsection"><A NAME="map-key-qualifiers"><!--SEC ANCHOR -->3.2.4&#XA0;&#XA0;Map key qualifiers</A></H3><!--SEC END --><P>The Nullness Checker supports a map key annotation, <TT>@</TT><A HREF="doc/checkers/nullness/quals/KeyFor.html"><TT>KeyFor</TT></A> that indicates whether
a value is a key for a given map &#X2014; that is, whether
<TT>map.containsKey(value)</TT> would evaluate to <TT>true</TT>.</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/KeyFor.html"><B><TT>KeyFor</TT></B></A></DT><DD CLASS="dd-description">
</DD></DL><P>Use of this annotation can help you to type-check more code. For details,
see Section&#XA0;<A HREF="#map-keys">3.6</A>.</P><!--TOC section Writing nullness annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-nullness-annotations">3.3</A>&#XA0;&#XA0;Writing nullness annotations</H2><!--SEC END --><!--TOC subsection Implicit qualifiers-->
<H3 CLASS="subsection"><A NAME="nullness-implicit-qualifiers"><!--SEC ANCHOR -->3.3.1&#XA0;&#XA0;Implicit qualifiers</A></H3><!--SEC END --><P>As described in Section&#XA0;<A HREF="#effective-qualifier">19.1</A>, the Nullness checker
adds implicit qualifiers, reducing the number of annotations that must
appear in your code.
For example, enum types are implicitly non-null, so you never need to write
<TT>@NonNull MyEnumType</TT>.</P><P>For a complete description of all implicit nullness qualifiers, see the
Javadoc for <A HREF="doc/checkers/nullness/NullnessAnnotatedTypeFactory.html"><TT>NullnessAnnotatedTypeFactory</TT></A>.</P><!--TOC subsection Default annotation-->
<H3 CLASS="subsection"><A NAME="null-defaults"><!--SEC ANCHOR -->3.3.2&#XA0;&#XA0;Default annotation</A></H3><!--SEC END --><P>Unannotated references are treated as if they had a default annotation,
using the NNEL (non-null except locals) rule described below.
A user may choose a different rule for defaults using the
<TT>@</TT><A HREF="doc/checkers/quals/DefaultQualifier.html"><TT>DefaultQualifier</TT></A> annotation; see
Section&#XA0;<A HREF="#defaults">19.1.1</A>.</P><P>Here are three possible default rules you may wish to use. Other rules are
possible but are not as useful.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>: Unannotated types are regarded as possibly-null, or
nullable. This default is backward-compatible with Java, which permits
any reference to be null. You can activate this default by writing
a <TT>@DefaultQualifier("Nullable")</TT> annotation on a
class or method
declaration.
</LI><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>: Unannotated types are treated as non-null.
You can activate this
default via the
<TT>@DefaultQualifier("NonNull")</TT> annotation.
</LI><LI CLASS="li-itemize">Non-null except locals (NNEL): Unannotated types are treated as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>, <EM>except</EM> that the
unannotated raw type of a local variable is treated as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>. (Any generic arguments to a
local variable still default to
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>.) This is the standard
behavior. You can explicitly activate this default via the
<TT>@DefaultQualifier(value="NonNull",
locations={DefaultLocation.ALL_EXCEPT_LOCALS})</TT>
annotation.<P>The NNEL default leads to the smallest number of explicit annotations in
your code&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>]. It is what we recommend. If you do not
explicitly specify a different default, then NNEL is the default.
</P></LI></UL><!--TOC subsection Conditional nullness-->
<H3 CLASS="subsection"><A NAME="conditional-nullness"><!--SEC ANCHOR -->3.3.3&#XA0;&#XA0;Conditional nullness</A></H3><!--SEC END --><P>The Nullness Checker supports a form of conditional nullness types, via the
<TT>@</TT><A HREF="doc/checkers/nullness/quals/AssertNonNullIfTrue.html"><TT>AssertNonNullIfTrue</TT></A> and <TT>@</TT><A HREF="doc/checkers/nullness/quals/AssertNonNullIfFalse.html"><TT>AssertNonNullIfFalse</TT></A> method annotations.
The annotation on a method declares that some expressions are non-null, if
the method returns true (false, respectively).</P><P>Consider <A HREF="http://docs.oracle.com/javase/7/docs/api/java/io/File.html"><TT>java.io.File</TT></A>.
Method
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/io/File.html#listFiles()"><TT>File.listFiles()</TT></A> may
return null, but is specified to return a non-null value if
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/io/File.html#isDirectory()"><TT>File.isDirectory()</TT></A> is
true. The same holds for method
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/io/File.html#listFiles()"><TT>File.list()</TT></A>.
You could declare this relationship in the following way (this particular
example is already
done for you in the annotated JDK that comes with the Checker Framework):</P><PRE CLASS="verbatim">  class File {

    @AssertNonNullIfTrue({"list()", "listFiles()"})
    public boolean isDirectory() { ... }

    public File @Nullable [] listFiles();
  }
</PRE><P>A client that checks that a <TT>File</TT> reference is indeed that of a directory,
can then de-reference <TT>File.isDirectory</TT> safely without any nullness check.</P><PRE CLASS="verbatim">  static void analyze(File file) {
    if (file.isDirectory()) {
      for (File child : file.listFiles()) {  // no possible null dereference
        analyze(child);
      }
    } else {
        ... analyze file ...
    }
  }
</PRE><P>The argument to <TT>@AssertNonNullIfTrue</TT> and
<TT>@AssertNonNullIfFalse</TT> is a Java expression, including method calls
(as shown above), method formal parameters, fields, etc.; for details, see
Section&#XA0;<A HREF="#java-expressions-as-arguments">19.2</A>.
More examples of the use of these annotations appear in the Javadoc for
<TT>@</TT><A HREF="doc/checkers/nullness/quals/AssertNonNullIfTrue.html"><TT>AssertNonNullIfTrue</TT></A> and
<TT>@</TT><A HREF="doc/checkers/nullness/quals/AssertNonNullIfFalse.html"><TT>AssertNonNullIfFalse</TT></A>.</P><!--TOC subsection Inference of <TT>@NonNull</TT> and <TT>@Nullable</TT> annotations-->
<H3 CLASS="subsection"><A NAME="nullness-inference"><!--SEC ANCHOR -->3.3.4&#XA0;&#XA0;Inference of <TT>@NonNull</TT> and <TT>@Nullable</TT> annotations</A></H3><!--SEC END --><P>It can be tedious to write annotations in your code. Tools exist that
can automatically infer annotations and insert them in your source code.
(This is different than type qualifier refinement for local variables
(Section&#XA0;<A HREF="#type-refinement">19.1.2</A>), which infers a more specific type for
local variables and uses them during type-checking but does not insert them
in your source code. Type qualifier refinement is always enabled, no
matter how annotations on signatures got inserted in your source code.)</P><P>Your choice of tool depends on what default annotation (see
Section&#XA0;<A HREF="#null-defaults">3.3.2</A>) your code uses. You only need one of these tools.</P><UL CLASS="itemize"><LI CLASS="li-itemize">Inference of <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>:
If your code uses the standard NNEL (non-null-except-locals) default or
the <A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> default, then use the
<A HREF="http://groups.csail.mit.edu/pag/daikon/download/doc/daikon.html#AnnotateNullable">AnnotateNullable</A>
tool of the <A HREF="http://pag.csail.mit.edu/daikon/">Daikon invariant
detector</A>.</LI><LI CLASS="li-itemize">Inference of <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>:
If your code uses the Nullable default, use one of these tools:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<A HREF="http://julia.scienze.univr.it/">Julia analyzer</A>,
</LI><LI CLASS="li-itemize"><A HREF="http://nit.gforge.inria.fr">Nit: Nullability Inference Tool</A>,
</LI><LI CLASS="li-itemize"><A HREF="http://jastadd.org/jastadd-tutorial-examples/non-null-types-for-java/">Non-null
checker and inferencer</A> of the <A HREF="http://jastadd.org/">JastAdd
Extensible Compiler</A>.
</LI></UL></LI></UL><!--TOC section Suppressing nullness warnings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="suppressing-warnings-nullness">3.4</A>&#XA0;&#XA0;Suppressing nullness warnings</H2><!--SEC END --><P>The Checker Framework supplies several ways to suppress warnings, most
notably the <TT>@SuppressWarnings("nullness")</TT> annotation (see
Section&#XA0;<A HREF="#suppressing-warnings">20.2</A>). An example use is</P><PRE CLASS="verbatim">    // might return null
    @Nullable Object getObject() { ... }

    void myMethod() {
      // The programmer knows that this partucular call never returns null.
      @SuppressWarnings("nullness")
      @NonNull Object o2 = getObject();
</PRE><P>The Nullness Checker supports an additional warning suppression key,
<TT>nullness:generic.argument</TT>.
Use of <TT>@SuppressWarnings("nullness:generic.argument")</TT> causes the Nullness
Checker to suppress warnings related to misuse of generic type
arguments. One use for this key is when a class is declared to take only
<TT>@NonNull</TT> type arguments, but you want to instantiate the class with a
<TT>@Nullable</TT> type argument, as in <TT>List&lt;@Nullable Object&gt;</TT>. For a more
complete explanation of this example, see
Section&#XA0;<A HREF="#faq-list-map-nonnull-typeargs">24.17</A>.</P><P>The Nullness Checker also permits you to use assertions or method calls to
suppress warnings; see below.</P><!--TOC subsection Suppressing warnings with assertions and method calls-->
<H3 CLASS="subsection"><A NAME="suppressing-warnings-with-assertions"><!--SEC ANCHOR -->3.4.1&#XA0;&#XA0;Suppressing warnings with assertions and method calls</A></H3><!--SEC END --><P>Occasionally, it is inconvenient or
verbose to use the <TT>@SuppressWarnings</TT> annotation. For example, Java does
not permit annotations such as <TT>@SuppressWarnings</TT> to appear on statements.</P><P>For situations when the <TT>@SuppressWarnings</TT> annotation is inconvenient,
the Nullness Checker provides three additional ways to suppress warnings:
via an <TT>assert</TT> statement, the <TT>castNonNull</TT> method, and the
<TT>@AssertParametersNonNull</TT> annotation. These are
appropriate when the Nullness Checker issues a warning, but the programmer
knows for sure that the warning is a false positive, because the value
cannot ever be null at run time.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Use an assertion. If the string &#X201C;<TT>nullness</TT>&#X201D;
appears in the message body, then the Nullness Checker treats the
assertion as suppressing a warning and assumes that the assertion always
succeeds. For example, the checker assumes that no null pointer
exception can occur in code such as
<PRE CLASS="verbatim">  assert x != null : "@SuppressWarnings(nullness)";
  ... x.f ...
</PRE><P>If the string &#X201C;<TT>nullness</TT>&#X201D; does not appear in the
assertion message, then the Nullness Checker treats the assertion as being
used for defensive programming, and it warns if the method might throw a
nullness-related exception.</P><P>A downside of putting the string in the assertion message is that if the
assertion ever fails, then a user might see the string and be confused.
But the string should only be used if the programmer has reasoned that
the assertion can never fail.</P></LI><LI CLASS="li-enumerate">Use the <A HREF="doc/checkers/nullness/NullnessUtils.html#castNonNull(T)"><TT>NullnessUtils.castNonNull</TT></A> method.<P>The Nullness
Checker considers both the return value, and also the argument, to
be non-null after the method call. Therefore, the
<TT>castNonNull</TT> method can be used either as a cast expression or
as a statement. The Nullness Checker issues no warnings in any of
the following code:</P><PRE CLASS="verbatim">  // one way to use as a cast:
  @NonNull String s = castNonNull(possiblyNull1);

  // another way to use as a cast:
  castNonNull(possiblyNull2).toString();

  // one way to use as a statement:
  castNonNull(possiblyNull3);
  possiblyNull3.toString();`
</PRE><P>The method also throws <TT>AssertionError</TT> if Java assertions are enabled and
the argument is <TT>null</TT>. However, it is not intended for general defensive
programming; see Section&#XA0;<A HREF="#defensive-programming">3.4.2</A>.</P><P>A potential disadvantage of using the <TT>castNonNull</TT> method is that your
code becomes dependent on the Checker Framework at run time as well as at
compile time. You can avoid this by copying the implementation of
<TT>castNonNull</TT> into your own code, and possibly renaming it if you do not
like the name. Be sure to retain the documentation that indicates that
your copy is intended for use only to suppress warnings and not for
defensive programming. See Section&#XA0;<A HREF="#defensive-programming">3.4.2</A> for an
explanation of the distinction.</P></LI><LI CLASS="li-enumerate">Use the <TT>@</TT><A HREF="doc/checkers/nullness/quals/AssertParametersNonNull.html"><TT>AssertParametersNonNull</TT></A>
annotation. It is used on <TT>castNonNull</TT>, and may be used on other
methods with the same semantics; it should probably never be used in any
other situation.</LI></OL><!--TOC subsection Suppressing warnings on nullness-checking routines and defensive programming-->
<H3 CLASS="subsection"><A NAME="defensive-programming"><!--SEC ANCHOR -->3.4.2&#XA0;&#XA0;Suppressing warnings on nullness-checking routines and defensive programming</A></H3><!--SEC END --><P>One way to suppress warnings in the Nullness Checker is to use
method <TT>castNonNull</TT>.
(Section&#XA0;<A HREF="#suppressing-warnings-with-assertions">3.4.1</A> gives other techniques.)</P><P>This section explains why the Nullness Checker introduces a new method
rather than re-using the <TT>assert</TT> statement (as in
<TT>assert x != null</TT>) or an existing method such as:</P><PRE CLASS="verbatim">  org.junit.Assert.assertNotNull(Object)
  com.google.common.base.Preconditions.checkNotNull(Object)
</PRE><P>In each case, the assertion or method indicates an application invariant &#X2014; a
fact that should always be true. There are two distinct reasons a
programmer may have written the invariant, depending on whether the
programmer is 100% sure that the application invariant holds.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
A programmer might write it as <B>defensive programming</B>. This causes
the program to throw an exception, which is useful for debugging because
it gives an earlier run-time indication of the error.
A programmer would use an assertion in this way if the programmer is not
100% sure that the application invariant holds.</LI><LI CLASS="li-enumerate">A programmer might write it to <B>suppress</B> false positive
<B>warning messages</B> from a checker. A programmer would use an
assertion this way if the programmer is 100% sure that the application
invariant holds, and the reference can never be null at run time.</LI></OL><P>With assertions and existing methods like JUnit&#X2019;s <TT>assertNotNull</TT>, there
is no way of knowing the programmer&#X2019;s intent in using the method.
Different programmers or codebases may use them in different ways.
Guessing wrong would make the Nullness Checker less useful, because it
would either miss real errors or issue warnings where there is no real
error. Also, different checking tools issue different false warnings that
need to be suppressed, so warning suppression needs to be customized for
each tool rather than inferred from general-purpose code.</P><P>As an example of using assertions for defensive programming, some style
guides suggest using assertions or method calls to indicate nullness. A
programmer might write</P><PRE CLASS="verbatim">    String s = ...
    assert s != null;    // or:  assertNotNull(s);   or: checkNotNull(s);
    ... Double.valueOf(s) ...
</PRE><P>A programming error might cause <TT>s</TT> to be null, in which case the code
would throw an exception at run time.
If the assertion caused the Nullness Checker to assume that <TT>s</TT> is not
<TT>null</TT>, then the Nullness Checker would issue no warning for this code.
That would be undesirable, because the whole purpose of the Nullness
Checker is to give a compile-time warning about possible run-time
exceptions. Furthermore, if the programmer uses assertions for defensive
programming systematically throughout the codebase, then many useful
Nullness Checker warnings would be suppressed.</P><P>Because it is important to distinguish between the two uses of assertions
(defensive programming vs.&#XA0;suppressing warnings), the Checker Framework
introduces the <A HREF="doc/checkers/nullness/NullnessUtils.html#castNonNull(T)"><TT>NullnessUtils.castNonNull</TT></A> method.
Unlike existing assertions and
methods, <TT>castNonNull</TT> is intended only to suppress false warnings that are
issued by the Nullness Checker, not for defensive programming.</P><P>If you know that a particular codebase uses
a nullness-checking method not for defensive programming but to indicate
facts that are guaranteed to be true (that is, these assertions will never
fail at run time), then you can cause the Nullness Checker to suppress
warnings related to them, just as it does for <TT>castNonNull</TT>.
Annotate its definition just as
<A HREF="doc/checkers/nullness/NullnessUtils.html#castNonNull(T)"><TT>NullnessUtils.castNonNull</TT></A> is annotated (see the
source code for the Checker Framework).
Also, be sure to document the intention in the method&#X2019;s Javadoc, so that
programmers do not
accidentally misuse it for defensive programming.</P><P>If you are annotating a codebase that already contains precondition checks,
such as:</P><PRE CLASS="verbatim">  public String get(String key, String def) {
    checkNotNull(key, "key"); //NOI18N
    ...
  }
</PRE><P>then you should mark the appropriate parameter as <TT>@NonNull</TT> (which is the
default). This will prevent the checker from issuing a warning about the
<TT>checkNotNull</TT> call.</P><!--TOC section <TT>@Raw</TT> annotation for partially-initialized objects-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="raw-partially-initialized">3.5</A>&#XA0;&#XA0;<TT>@Raw</TT> annotation for partially-initialized objects</H2><!--SEC END --><P>An object is
<EM>raw</EM> from the time that its constructor starts until its constructor
finishes. This is relevant to the Nullness Checker because while the
constructor is executing &#X2014; that is, before initialization completes &#X2014;
a <TT>@NonNull</TT>
field may be observed to be null, until that field is set. In
particular, the Nullness Checker issues a warning for code like this:</P><PRE CLASS="verbatim">  public class MyClass {
    private @NonNull Object f;
    public MyClass(int x, int y) {
      // Error because constructor contains no assignment to this.f.
      // By the time the constructor exits, f must be initialized to a non-null value.
    }
    public MyClass(int x) {
      // Error because this.f is accessed before f is initialized.
      // At the beginning of the constructor's execution, accessing this.f
      // yields null, even though field f has a non-null type.
      this.f.toString();
    }
    public MyClass(int x, int y, int z) {
      m();
    }
    public void m() {
      // Error because this.f is accessed before f is initialized,
      // even though the access is not in a constructor.
      // When m is called from the constructor, accessing f yields null,
      // even though field f has a non-null type.
      this.f.toString();
    }
</PRE><P>In general, code can depend that field <TT>f</TT> is not <TT>null</TT>, because the
field is declared with a <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type.
However, this guarantee does not hold for a partially-initialized object.</P><P>The Nullness Checker uses the <TT>@Raw</TT> annotation to indicate that an object
is not yet fully initialized &#X2014; that is, not all its <TT>@NonNull</TT> fields have been
assigned. Rawness is mostly relevant within the constructor, or for
references to <TT>this</TT> that escape the constructor (say, by being stored
in a field or passed to a method before initialization is complete). 
Use of rawness annotations in rare in most code.</P><!--TOC subsection Rawness qualifiers-->
<H3 CLASS="subsection"><A NAME="rawness-qualifiers"><!--SEC ANCHOR -->3.5.1&#XA0;&#XA0;Rawness qualifiers</A></H3><!--SEC END --><P>The rawness hierarchy is shown in Figure&#XA0;<A HREF="#fig:nonnull-hierarchy">3.1</A>.
The rawness hierarchy contains these qualifiers:</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/Raw.html"><B><TT>Raw</TT></B></A></DT><DD CLASS="dd-description">
indicates a type that may contain a partially-initialized object. In a
partially-initialized object, fields that are annotated as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> may be null because the field
has not yet been assigned. Within the constructor,
<TT>this</TT> has <TT>@</TT><A HREF="doc/checkers/nullness/quals/Raw.html"><TT>Raw</TT></A> type until all
the <TT>@NonNull</TT> fields have been assigned.
A partially-initialized object (<TT>this</TT> in a constructor) may be
passed to a helper method or stored in a variable; if so, the method
receiver, or the field, would have to be annotated as <TT>@Raw</TT>.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/NonRaw.html"><B><TT>NonRaw</TT></B></A></DT><DD CLASS="dd-description">
indicates a type that contains a fully-initialized object. <TT>NonRaw</TT>
is the default, so there is little need for a programmer to write this
explicitly.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/nullness/quals/PolyRaw.html"><B><TT>PolyRaw</TT></B></A></DT><DD CLASS="dd-description">
indicates qualifier polymorphism over rawness (see
Section&#XA0;<A HREF="#qualifier-polymorphism">18.2</A>).</DD></DL><P>If a reference has
<TT>@Raw</TT> type, then all of its <TT>@NonNull</TT> fields are treated as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/LazyNonNull.html"><TT>LazyNonNull</TT></A>: when read, they are
treated as being <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>, but when
written, they are treated as being
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>.</P><P>The rawness hierarchy is orthogonal to the nullness hierarchy. It
is legal for a reference to be <TT>@NonNull @Raw</TT>, <TT>@Nullable @Raw</TT>,
<TT>@NonNull @NonRaw</TT>, or <TT>@Nullable @NonRaw</TT>. The nullness hierarchy tells
you about the reference itself: might the reference be null? The rawness
hierarchy tells you about the <TT>@NonNull</TT> fields in the referred-to object:
might those fields be temporarily null in contravention of their
type annotation?
Figure&#XA0;<A HREF="#fig:rawness-examples">3.2</A> contains some examples.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>Declarations</TD><TD ALIGN=left NOWRAP>Expression</TD><TD ALIGN=left NOWRAP>Expression&#X2019;s nullness type, or checker error</TD></TR>
<TR><TD ALIGN=left NOWRAP><DIV CLASS="minipage">
<PRE CLASS="verbatim">class C {
  @NonNull Object f;
  @Nullable Object g;
  ...
}
</PRE></DIV></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>@NonNull @NonRaw C a;</TT></TD><TD ALIGN=left NOWRAP><TT>a</TT></TD><TD ALIGN=left NOWRAP><TT>@NonNull</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TT>a.f</TT></TD><TD ALIGN=left NOWRAP><TT>@NonNull</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TT>a.g</TT></TD><TD ALIGN=left NOWRAP><TT>@Nullable</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>@NonNull @Raw C b;</TT></TD><TD ALIGN=left NOWRAP><TT>b</TT></TD><TD ALIGN=left NOWRAP><TT>@NonNull</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TT>b.f</TT></TD><TD ALIGN=left NOWRAP><TT>@LazyNonNull</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TT>b.g</TT></TD><TD ALIGN=left NOWRAP><TT>@Nullable</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>@Nullable @NonRaw C c;</TT></TD><TD ALIGN=left NOWRAP><TT>c</TT></TD><TD ALIGN=left NOWRAP><TT>@Nullable</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TT>c.f</TT></TD><TD ALIGN=left NOWRAP>error: deref of nullable</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TT>c.g</TT></TD><TD ALIGN=left NOWRAP>error: deref of nullable</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>@Nullable @Raw C d;</TT></TD><TD ALIGN=left NOWRAP><TT>d</TT></TD><TD ALIGN=left NOWRAP><TT>@Nullable</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TT>d.f</TT></TD><TD ALIGN=left NOWRAP>error: deref of nullable</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TT>d.g</TT></TD><TD ALIGN=left NOWRAP>error: deref of nullable</TD></TR>
</TABLE>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3.2: Examples of the interaction between nullness and rawness.
Declarations are shown at the left for reference, but the focus of the
table is the expressions and their nullness type or error.</TD></TR>
</TABLE></DIV>
<A NAME="fig:rawness-examples"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection How an object becomes non-raw-->
<H3 CLASS="subsection"><A NAME="becoming-non-raw"><!--SEC ANCHOR -->3.5.2&#XA0;&#XA0;How an object becomes non-raw</A></H3><!--SEC END --><P>Within the constructor,
<TT>this</TT> starts out with <TT>@</TT><A HREF="doc/checkers/nullness/quals/Raw.html"><TT>Raw</TT></A> type.
As soon as all of the <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> fields
have been initialized, then <TT>this</TT> is treated as non-raw.
</P><P>The Nullness checker issues an error if the constructor fails to initialize
any <TT>@NonNull</TT> field. This ensures that the object is in a legal (non-raw)
state by the time that the constructor exits.


This is different than Java&#X2019;s test for definite assignment (see
<A HREF="http://java.sun.com/docs/books/jls/third_edition/html/defAssign.html">JLS ch.16</A>),
which does not apply to fields (except blank final ones, defined in
<A HREF="http://java.sun.com/docs/books/jls/third_edition/html/defAssign.html">JLS &#XA7;4.12.4</A>) because fields
have a default value of null.</P><P>All <TT>@NonNull</TT> fields must either have a
default in the field declaration, or be assigned in the constructor or in a
helper method that the constructor calls. If
your code initializes (some) fields in a helper method, you will need to
annotate the helper method with an annotation such as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/AssertNonNullAfter.html"><TT>AssertNonNullAfter</TT></A><TT>({"field1", "field2"})</TT>
for all the fields that the helper method assigns.
It&#X2019;s a bit odd, but you use that same annotation, <TT>@AssertNonNullAfter</TT>,
to indicate that a primitive field has its value set in a helper method,
which is relevant when you supply the <TT>-Alint=uninitialized</TT>
command-line option (see Section&#XA0;<A HREF="#lint-uninitialized">2</A>).</P><!--TOC subsection More details about rawness checking-->
<H3 CLASS="subsection"><A NAME="rawness-checking"><!--SEC ANCHOR -->3.5.3&#XA0;&#XA0;More details about rawness checking</A></H3><!--SEC END --><!--TOC paragraph Suppressing warnings-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Suppressing warnings</H5><!--SEC END --><P>You can suppress warnings related to partially-initialized objects with
<TT>@SuppressWarnings("rawness")</TT>. Do not confuse this with the unrelated
<TT>@SuppressWarnings("rawtypes")</TT> annotation for non-instantiated generic types!</P><!--TOC paragraph Checking initialization of all fields, not just <TT>@NonNull</TT> ones-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Checking initialization of all fields, not just <TT>@NonNull</TT> ones</H5><!--SEC END --><P>When the <TT>-Alint=uninitialized</TT> command-line option is provided, then
an object is considered raw until <EM>all</EM> its fields are assigned, not
just the <TT>@NonNull</TT> ones. See Section&#XA0;<A HREF="#lint-uninitialized">2</A>.</P><!--TOC paragraph The terminology &#X201C;raw&#X201D;-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->The terminology &#X201C;raw&#X201D;</H5><!--SEC END --><P>The name &#X201C;raw&#X201D; comes from a research paper that proposed this
approach&#XA0;[<A HREF="#FahndrichL2003">FL03</A>].
A better name might have been &#X201C;not yet initialized&#X201D; or &#X201C;partially
initialized&#X201D;, but the term &#X201C;raw&#X201D; is now well-known.
The <TT>@</TT><A HREF="doc/checkers/nullness/quals/Raw.html"><TT>Raw</TT></A>
annotation has nothing to do with the raw types of Java Generics.</P><!--TOC section Map key annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="map-keys">3.6</A>&#XA0;&#XA0;Map key annotations</H2><!--SEC END --><P>Java&#X2019;s
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/util/Map.html#get(java.lang.Object)"><TT>Map.get</TT></A>
method always has the possibility to return null, if the key is not in the
map. Thus, to guarantee that the value returned from <TT>Map.get</TT> is
non-null, it is necessary that the map contains only non-null values,
<EM>and</EM> the key is in the map.
The <TT>@</TT><A HREF="doc/checkers/nullness/quals/KeyFor.html"><TT>KeyFor</TT></A> annotation states the latter
property.</P><P>If a type is annotated as <TT>@KeyFor("m")</TT>, then any value v with that type
is a key in Map m. Another way of saying this is that the expression
<TT>m.containsKey(v)</TT> evaluates to true.</P><P>You usually do not have to write <TT>@KeyFor</TT> explicitly, because the
checker infers it based on usage patterns, such as calls to
<TT>containsKey</TT> or iteration over a map&#X2019;s
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/util/Map.html#keySet()">key set</A>.</P><P>One usage pattern where you <EM>do</EM> have to write <TT>@KeyFor</TT> is for a
user-managed collection that is a subset of the key set:</P><PRE CLASS="verbatim">Map&lt;String, Object&gt; m;
Set&lt;@KeyFor("m") String&gt; matchingKeys; // keys that match some criterion
for (@KeyFor("m") String k : matchingKeys) {
  ... m.get(k) ...  // known to be non-null
}
</PRE><P>As with any annotation, use of the <TT>@KeyFor</TT> annotation may force you to
slightly refactor your code. For example, this would be illegal:</P><PRE CLASS="verbatim">  Map&lt;K,V&gt; m;
  Collection&lt;@KeyFor("m") K&gt; coll;
  coll.add(x);   // compiler error, because the @KeyFor annotation is violated
  m.put(x, ...);
</PRE><P>but this would be OK (no compiler error):</P><PRE CLASS="verbatim">  Collection&lt;@KeyFor("m") K&gt; coll;
  m.put(x, ...);
  coll.add(x);
</PRE><P>Because the <TT>@KeyFor</TT> type hierarchy is independent from the nullness and
rawness hierarchies, it uses a different warning suppression key.
You can suppress warnings related to map keys with
<TT>@SuppressWarnings("keyfor")</TT>.</P><!--TOC section Additional details-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="nullness-additional-details">3.7</A>&#XA0;&#XA0;Additional details</H2><!--SEC END --><P>The Nullness Checker does some special checks in certain circumstances, in
order to soundly reduce the number of warnings that it produces.</P><P>For example, a call to 
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#getProperty(java.lang.String)"><TT>System.getProperty(String)</TT></A>
can return null in general, but it will not return null if the argument is
one of the built-in-keys listed in the documentation of 
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/lang/System.html#getProperties()"><TT>System.getProperties()</TT></A>.
The Nullness Checker is aware of this fact, so you do not have to suppress
a warning for a call like <TT>System.getProperty("line.separator")</TT>. The
warning is still issued for code like this:</P><PRE CLASS="verbatim">  final String s = "line.separator";
  nonNullvar = System.getProperty(s);
</PRE><P>though that case could be handled as well, if desired.
(Suppression of the warning is, strictly speaking, not sound, because a
library that your code calls, or your code itself, could perversely change
the system properties; the Nullness Checker assumes this bizarre coding
pattern does not happen.)</P><!--TOC section Examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="nullness-example">3.8</A>&#XA0;&#XA0;Examples</H2><!--SEC END --><!--TOC subsection Tiny examples-->
<H3 CLASS="subsection"><A NAME="nullness-tiny-examples"><!--SEC ANCHOR -->3.8.1&#XA0;&#XA0;Tiny examples</A></H3><!--SEC END --><P>To try the Nullness checker on a source file that uses the <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> qualifier,
use the following command (where <TT>javac</TT> is the JSR 308 compiler that
is distributed with the Checker Framework):</P><PRE CLASS="verbatim">  javac -processor checkers.nullness.NullnessChecker examples/NullnessExample.java
</PRE><P>Compilation will complete without warnings.</P><P>To see the checker warn about incorrect usage of annotations (and therefore the
possibility of a null pointer exception at run time), use the following command:</P><PRE CLASS="verbatim">  javac -processor checkers.nullness.NullnessChecker examples/NullnessExampleWithWarnings.java
</PRE><P>The compiler will issue three warnings regarding violation of the semantics of
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>.
</P><!--TOC subsection Annotated library-->
<H3 CLASS="subsection"><A NAME="nullness-annotated-library"><!--SEC ANCHOR -->3.8.2&#XA0;&#XA0;Annotated library</A></H3><!--SEC END --><P>Some libraries that are annotated with nullness qualifiers are:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The Nullness checker itself.</LI><LI CLASS="li-itemize">The
<A HREF="http://code.google.com/p/plume-lib/">Plume-lib library</A>.
Run the command <TT>make check-nullness</TT>.</LI><LI CLASS="li-itemize">The
<A HREF="http://groups.csail.mit.edu/pag/daikon/">Daikon invariant detector</A>.
Run the command <TT>make check-nullness</TT>.</LI></UL><!--TOC section Tips for getting started-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="nullness-getting-started">3.9</A>&#XA0;&#XA0;Tips for getting started</H2><!--SEC END --><P>Here are some tips about getting started using the Nullness Checker on a
legacy codebase. For more generic advice (not specific to the Nullness
Checker), see Section&#XA0;<A HREF="#get-started-with-legacy-code">2.4.1</A>.</P><P>Your goal is to add <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A> annotations
to the types of any variables that can be null. (The default is to assume
that a variable is non-null unless it has a <TT>@Nullable</TT> annotation.)
Then, you will run the Nullness Checker. Each of its errors indicates
either a possible null pointer exception, or a wrong/missing annotation.
When there are no more warnings from the checker, you are done!</P><P>We recommend that you start by searching the code for occurrences of
<TT>null</TT> in the following locations; when you find one, write the
corresponding annotation:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
in Javadoc: add <TT>@Nullable</TT> annotations to method signatures (parameters and return types).
</LI><LI CLASS="li-itemize"><TT>return null</TT>: add a <TT>@Nullable</TT> annotation to the return type
of the given method.
</LI><LI CLASS="li-itemize"><TT><EM>param</EM></TT><TT> == null</TT>: when a formal parameter is compared to
<TT>null</TT>, then in most cases you can add a <TT>@Nullable</TT> annotation
to the formal parameter&#X2019;s type
</LI><LI CLASS="li-itemize"><TT><EM>TypeName</EM></TT><TT> </TT><TT><EM>field</EM></TT><TT> = null;</TT>: when a field is initialized to
<TT>null</TT> in its declaration, then it needs either a
<TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A> or a
<TT>@</TT><A HREF="doc/checkers/nullness/quals/LazyNonNull.html"><TT>LazyNonNull</TT></A> annotation. If the field
is always set to a non-null value in the constructor, then you can just
change the declaration to <TT><EM>Type</EM></TT><TT> </TT><TT><EM>field</EM></TT><TT>;</TT>, without an
initializer, and write no type annotation (because the default is
<TT>@NonNull</TT>).
</LI><LI CLASS="li-itemize">declarations of <TT>contains</TT>, <TT>containsKey</TT>, <TT>containsValue</TT>, <TT>equals</TT>,
<TT>get</TT>, <TT>indexOf</TT>, <TT>lastIndexOf</TT>, and <TT>remove</TT> (with <TT>Object</TT> as the
argument type):
change the argument type to <TT>@Nullable Object</TT>; for <TT>remove</TT>, also change
the return type to <TT>@Nullable Object</TT>.
</LI></UL><P>You should ignore all other occurrences of <TT>null</TT> within a method
body. In particular, you (almost) never need to annotate local variables.</P><P>Only after this step should you run <TT>ant</TT> to invoke
the Nullness Checker. The reason is that it is quicker to search for
places to change than to repeatedly run the checker and fix the errors it
tells you about, one at a time.</P><P>Here are some other tips:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
In any file where you write an annotation such as <TT>@Nullable</TT>,
don&#X2019;t forget to add <TT>import checkers.nullness.quals.*;</TT>.
</LI><LI CLASS="li-itemize">To indicate an array that can be null, write, for example: <TT>int
@Nullable []</TT>.<BR>
 By contrast, <TT>@Nullable Object []</TT> means a non-null array that
contains possibly-null objects.
</LI><LI CLASS="li-itemize">If you know that a particular variable is definitely not null, but the
Nullness Checker cannot figure it out, then you can tell it by writing
an assertion (see Section&#XA0;<A HREF="#suppressing-warnings">20.2</A>):
<PRE CLASS="verbatim">assert var != null : "@SuppressWarnings(nullness)";
</PRE></LI><LI CLASS="li-itemize">To indicate that a routine returns the same value every time it is
called, use <TT>@</TT><A HREF="doc/checkers/nullness/quals/Pure.html"><TT>Pure</TT></A> (see Section&#XA0;<A HREF="#nullness-non-qualifiers">3.2.2</A>).
</LI><LI CLASS="li-itemize">To indicate a method precondition (a contract stating the conditions
under which a client is allowed to call it), you can use annotations
such as <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNullOnEntry.html"><TT>NonNullOnEntry</TT></A> (see Section&#XA0;<A HREF="#nullness-non-qualifiers">3.2.2</A>.
</LI></UL><!--TOC section Other tools for nullness checking-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="nullness-related-work">3.10</A>&#XA0;&#XA0;Other tools for nullness checking</H2><!--SEC END --><P>The Checker Framework&#X2019;s nullness annotations are similar to annotations used
in IntelliJ IDEA, FindBugs, JML, the JSR 305 proposal, NetBeans, and other tools. Also
see Section&#XA0;<A HREF="#other-tools">25.5</A> for a comparison to other tools.</P><P>You might prefer to use the Checker Framework because it has a more
powerful analysis that can warn you about more null pointer errors in your
code.</P><P>If your code is already annotated with a different nullness
annotation, you can reuse that effort by converting them to the Checker
Framework&#X2019;s nullness annotations. Perform the refactoring described in
Figure&#XA0;<A HREF="#fig:nullness-refactoring">3.3</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> &#XA0;com.sun.istack.NotNull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;edu.umd.cs.findbugs.annotations.NonNull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;javax.annotation.Nonnull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&#XA0;org.jetbrains.annotations.NotNull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;org.netbeans.api.annotations.common.NonNull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;org.jmlspecs.annotation.NonNull&#XA0;</TD></TR>
</TABLE></TD><TD ALIGN=left NOWRAP>&#X21D2;
&#XA0;checkers.nullness.quals.NonNull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> &#XA0;com.sun.istack.Nullable&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;edu.umd.cs.findbugs.annotations.Nullable&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;edu.umd.cs.findbugs.annotations.CheckForNull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;edu.umd.cs.findbugs.annotations.UnknownNullness&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;javax.annotation.Nullable&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;javax.annotation.CheckForNull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;javax.validation.constraints.NotNull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP>&#XA0;org.jetbrains.annotations.Nullable&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;org.netbeans.api.annotations.common.CheckForNull&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;org.netbeans.api.annotations.common.NullAllowed&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;org.netbeans.api.annotations.common.NullUnknown&#XA0;</TD></TR>
<TR><TD ALIGN=left NOWRAP> &#XA0;org.jmlspecs.annotation.Nullable&#XA0;</TD></TR>
</TABLE></TD><TD ALIGN=left NOWRAP>&#X21D2;
&#XA0;checkers.nullness.quals.Nullable&#XA0;</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3.3: Refactoring for converting other nullness annotations to the
Checker Framework&#X2019;s annotations.</TD></TR>
</TABLE></DIV>
<A NAME="fig:nullness-refactoring"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Alternately, the Checker Framework can process those other annotations (as
well as its own, if they also appear in your program). The Checker
Framework has its own definition of the annotations on the left side of
Figure&#XA0;<A HREF="#fig:nullness-refactoring">3.3</A>, so that they can be used as type
qualifiers. The Checker Framework interprets them according to the right
side of Figure&#XA0;<A HREF="#fig:nullness-refactoring">3.3</A>.</P><P>The Checker Framework may issue more or fewer errors than another tool.
This is expected, since each tool uses a different analysis. Remember that
the Checker Framework aims at soundness: it aims to never miss a possible
null dereference, while at the same time limiting false reports. Also,
note FindBugs&#X2019;s non-standard meaning for <TT>@Nullable</TT>
(Section&#XA0;<A HREF="#findbugs-nullable">3.10.2</A>).</P><P>Because some of the names are the same (<TT>NonNull</TT>, <TT>Nullable</TT>), you can
import at most one of the annotations with
conflicting names; the other(s) must be written out fully rather than
imported.</P><!--TOC subsection Which tool is right for you?-->
<H3 CLASS="subsection"><A NAME="choosing-nullness-tool"><!--SEC ANCHOR -->3.10.1&#XA0;&#XA0;Which tool is right for you?</A></H3><!--SEC END --><P>Different tools are appropriate in different circumstances. Here is a
brief comparison with FindBugs, but similar points apply to other tools.</P><P>The Checker Framework has a more powerful nullness analysis; FindBugs misses
some real
errors. However, FindBugs does not require you to annotate your code as
thoroughly as the Checker Framework does. Depending on the importance of
your code, you may desire: no nullness checking, the cursory checking of
FindBugs, or the thorough checking of the Checker Framework. You might
even want to ensure that both tools run, for example if your coworkers or
some other organization are still using FindBugs. If you know that you
will eventually want to use the Checker Framework, there is no point using
FindBugs first; it is easier to go straight to using the Checker Framework.</P><P>FindBugs can find other errors in addition to nullness errors; here
we focus on its nullness checks. Even if you use FindBugs for its other
features, you may want to use the Checker Framework for analyses that can
be expressed as pluggable type-checking, such as detecting nullness errors.</P><P>Regardless of whether you wish to use the FindBugs nullness analysis, you
may continue running all of the other FindBugs analyses at the same time as
the Checker Framework; there are no interactions among them.</P><P>If FindBugs (or any other tool) discovers a nullness error that the Checker
Framework does not, please report it to us (see
Section&#XA0;<A HREF="#reporting-bugs">25.2</A>) so that we can enhance the Checker Framework.</P><!--TOC subsection Incompatibility note about FindBugs <TT>@Nullable</TT>-->
<H3 CLASS="subsection"><A NAME="findbugs-nullable"><!--SEC ANCHOR -->3.10.2&#XA0;&#XA0;Incompatibility note about FindBugs <TT>@Nullable</TT></A></H3><!--SEC END --><P>FindBugs has a non-standard definition of <TT>@Nullable</TT>. FindBugs&#X2019;s treatment is not
documented in its own
<A HREF="http://findbugs.sourceforge.net/api/edu/umd/cs/findbugs/annotations/Nullable.html">Javadoc</A>;
it is different from the definition of <TT>@Nullable</TT> in every other tool for
nullness analysis; it means the same thing as <TT>@NonNull</TT> when applied to a
formal parameter; and it invariably surprises programmers. Thus, FindBugs&#X2019;s
<TT>@Nullable</TT> is detrimental rather than useful as documentation.
In practice, your best bet is to not rely on FindBugs for nullness analysis,
even if you find FindBugs useful for other purposes.</P><P>You can skip the rest of this section unless you wish to learn more details.</P><P>FindBugs suppresses all warnings at uses of a <TT>@Nullable</TT> variable.
(You have to use <TT>@CheckForNull</TT> to
indicate a nullable variable that FindBugs should check.) For example:</P><PRE CLASS="verbatim">     // declare getObject() to possibly return null
     @Nullable Object getObject() { ... }

     void myMethod() {
       @Nullable Object o = getObject();
       // FindBugs issues no warning about calling toString on a possibly-null reference!
       o.toString();
     }
</PRE><P>The Checker Framework does not emulate this non-standard behavior of
FindBugs, even if the code uses FindBugs annotations.</P><P>With FindBugs, you annotate a declaration, which suppresses checking at
<EM>all</EM> client uses, even the places that you want to check.
It is better to suppress warnings at only the specific client uses
where the value is known to be non-null; the Checker Framework supports
this, if you write <TT>@SuppressWarnings</TT> at the client uses.
The Checker Framework also supports suppressing checking at all client uses,
by writing a <TT>@SuppressWarnings</TT> annotation at the declaration site.
Thus, the Checker Framework supports both use cases, whereas FindBugs
supports only one and gives the programmer less flexibility.</P><P>In general, the Checker Framework will issue more warnings than FindBugs,
and some of them may be about real bugs in your program.
See Section&#XA0;<A HREF="#suppressing-warnings-nullness">3.4</A> for information about
suppressing nullness warnings.</P><P>(FindBugs made a poor choice of names. The choice of names should make a
clear distinction between annotations that specify whether a reference is
null, and annotations that suppress false warnings. The choice of names
should also have been consistent for other tools, and intuitively clear to
programmers. The FindBugs choices make the FindBugs annotations less
helpful to people, and much less useful for other tools. As a separate
issue, the FindBugs
analysis is also very imprecise. For type-related analyses, it is best to
stay away from the FindBugs nullness annotations, and use a more capable
tool like the Checker Framework.)</P><HR><!--TOC chapter Interning checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="interning-checker">Chapter&#XA0;4</A>&#XA0;&#XA0;Interning checker</H1><!--SEC END --><P>If the Interning checker issues no warnings for a given program, then all
reference equality tests (i.e., all uses of &#X201C;<TT>==</TT>&#X201D;) are proper;
that is,
<TT>==</TT> is not misused where <TT>equals()</TT> should have been used instead.</P><P>Interning is a design pattern in which the same object is used whenever two
different objects would be considered equal. Interning is also known as
canonicalization or hash-consing, and it is related to the flyweight design
pattern.
Interning has two benefits: it can save memory, and it can speed up testing for
equality by permitting use of <TT>==</TT>.</P><P>The Interning checker prevents two types of errors in your code. First, 
<TT>==</TT> should be used
only on interned values; using <TT>==</TT> on
non-interned values can result in subtle bugs. For example:</P><PRE CLASS="verbatim">  Integer x = new Integer(22);
  Integer y = new Integer(22);
  System.out.println(x == y);  // prints false!
</PRE><P>The Interning checker helps programmers to prevent such bugs.
Second, 
the Interning checker also helps to prevent performance problems that result
from failure to use interning.
(See Section&#XA0;<A HREF="#checker-guarantees">2.3</A> for caveats to the checker&#X2019;s guarantees.)</P><P>Interning is such an important design pattern that Java builds it in for
strings. Every string literal in the program is guaranteed to be interned
(<A HREF="http://java.sun.com/docs/books/jls/third_edition/html/lexical.html#3.10.5">JLS
&#XA7;3.10.5</A>), and the
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#intern()"><TT>String.intern()</TT></A> method
performs interning for strings that are computed at run time.
Users can also write their own interning methods for other types.</P><P>It is a proper optimization to use <TT>==</TT>, rather than <TT>equals()</TT>,
whenever the comparison is guaranteed to produce the same result &#X2014; that
is, whenever the comparison is never provided with two different objects
for which <TT>equals()</TT> would return true. Here are three reasons that
this property could hold:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Interning. A factory method ensures that, globally, no two different
interned objects are <TT>equals()</TT> to one another. (In some cases
other, non-interned objects of the class might be <TT>equals()</TT> to one
another; in other cases, every object of the class is interned.)
Interned objects should always be immutable.
</LI><LI CLASS="li-enumerate">Global control flow. The program&#X2019;s control flow is such that the
constructor for class <I>C</I> is called a limited number of times, and with
specific values that ensure the results are not <TT>equals()</TT> to one
another. Objects of class <I>C</I> can always be compared with <TT>==</TT>.
Such objects may be mutable or immutable.
</LI><LI CLASS="li-enumerate">Local control flow. Even though not all objects of the given type may be
compared with <TT>==</TT>, the specific objects that can reach a given
comparison may be. For example, suppose that an array contains no
duplicates. Then testing to find the index of a given element that is
known to be in the array can use <TT>==</TT>.
</LI></OL><P>To eliminate Interning Checker warnings, you will need to annotate your
code regarding all legal uses of <TT>==</TT>. Thus, the Interning Checker
could also have been called the Reference Equality Checker. In the
future, the checker will include annotations that target the non-interning
cases above, but for now you need to use <TT>@Interned</TT>, <TT>@UsesObjectEquals</TT>
(which handles a surprising number of cases), and/or
<TT>@SuppressWarnings</TT>.</P><P>To run the Interning Checker, supply the <TT>-processor
checkers.interning.InterningChecker</TT> command-line option to javac. For
examples, see Section&#XA0;<A HREF="#interning-example">4.4</A>.</P><!--TOC section Interning annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="interning-annotations">4.1</A>&#XA0;&#XA0;Interning annotations</H2><!--SEC END --><P>These qualifiers are part of the Interning type system:</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/interning/quals/Interned.html"><B><TT>Interned</TT></B></A></DT><DD CLASS="dd-description">
indicates a type that includes only interned values (no non-interned
values).</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/interning/quals/PolyInterned.html"><B><TT>PolyInterned</TT></B></A></DT><DD CLASS="dd-description">
indicates qualifier polymorphism. For a description of
<TT>@</TT><A HREF="doc/checkers/interning/quals/PolyInterned.html"><TT>PolyInterned</TT></A>, see
Section&#XA0;<A HREF="#qualifier-polymorphism">18.2</A>.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/interning/quals/UsesObjectEquals.html"><B><TT>UsesObjectEquals</TT></B></A></DT><DD CLASS="dd-description">
is a class (not type) annotation that indicates that this class&#X2019;s
<TT>equals</TT> method is the same as that of <TT>Object</TT>. In other words,
neither this class nor any of its superclasses overrides the <TT>equals</TT>
method. Since <TT>Object.equals</TT> uses reference equality, this means that
for such a class, <TT>==</TT> and <TT>equals</TT> are equivalent, and so the
Interning Checker does not issue warnings for either one.</DD></DL><!--TOC section Annotating your code with <TT>@Interned</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="annotating-with-interned">4.2</A>&#XA0;&#XA0;Annotating your code with <TT>@Interned</TT></H2><!--SEC END --><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<DIV CLASS="center">
<IMG SRC="interning.png" ALT="interning.png"></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 4.1: Type hierarchy for the Interning type system.</TD></TR>
</TABLE></DIV>
<A NAME="fig:interning-hierarchy"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>In order to perform checking, you must annotate your code with the <TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A>
type annotation, which indicates a type for the canonical representation of an
object:</P><PRE CLASS="verbatim">            String s1 = ...;  // type is (uninterned) "String"
  @Interned String s2 = ...;  // Java type is "String", but checker treats it as "Interned String"
</PRE><P>The type system enforced by the checker plugin ensures that only interned
values can be assigned to <TT>s2</TT>.</P><P>To specify that <EM>all</EM> objects of a given type are interned, annotate the
class declaration:</P><PRE CLASS="verbatim">  public @Interned class MyInternedClass { ... }
</PRE><P>This is equivalent to annotating every use of <TT>MyInternedClass</TT>, in a
declaration or elsewhere. For example, <TT>enum</TT> classes are implicitly
so annotated.</P><!--TOC subsection Implicit qualifiers-->
<H3 CLASS="subsection"><A NAME="interning-implicit-qualifiers"><!--SEC ANCHOR -->4.2.1&#XA0;&#XA0;Implicit qualifiers</A></H3><!--SEC END --><P>As described in Section&#XA0;<A HREF="#effective-qualifier">19.1</A>, the Interning checker
adds implicit qualifiers, reducing the number of annotations that must
appear in your code.
For example, String literals and the null literal are always considered interned, and
object creation expressions (using <TT>new</TT>) are never considered
<TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> unless they are annotated as such, as in</P><PRE CLASS="verbatim">@Interned Double internedDoubleZero = new @Interned Double(0); // canonical representation for Double zero
</PRE><P>For a complete description of all implicit interning qualifiers, see the
Javadoc for <A HREF="doc/checkers/interning/InterningAnnotatedTypeFactory.html"><TT>InterningAnnotatedTypeFactory</TT></A>.</P><!--TOC section What the Interning checker checks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="interning-checks">4.3</A>&#XA0;&#XA0;What the Interning checker checks</H2><!--SEC END --><P>Objects of an <TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> type may be safely compared using the &#X201C;<TT>==</TT>&#X201D;
operator.</P><P>The checker issues a warning in two cases:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">When a reference (in)equality operator (&#X201C;<TT>==</TT>&#X201D; or &#X201C;<TT>!=</TT>&#X201D;)
has an operand of non-<TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> type.</LI><LI CLASS="li-enumerate">When a non-<TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> type is used where an <TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> type
is expected.</LI></OL><P>This example shows both sorts of problems:</P><PRE CLASS="verbatim">            Object  obj;
  @Interned Object iobj;
  ...
  if (obj == iobj) { ... }  // checker warning: reference equality test is unsafe
  iobj = obj;               // checker warning: iobj's referent may no longer be interned
</PRE><P><A NAME="lint-dotequals"></A></P><P>The checker also issues a warning when <TT>.equals</TT> is used where
<TT>==</TT> could be safely used. You can disable this behavior via the
javac <TT>-Alint</TT> command-line option, like so: <TT>-Alint=-dotequals</TT>.</P><P>For a complete description of all checks performed by
the checker, see the Javadoc for
<A HREF="doc/checkers/interning/InterningVisitor.html"><TT>InterningVisitor</TT></A>.</P><P><A NAME="checking-class"></A>
You can also restrict which types the checker should examine and type-check,
using the <TT>-Acheckclass</TT> option. For example, to find only the
interning errors related to uses of <TT>String</TT>, you can pass
<TT>-Acheckclass=java.lang.String</TT>. The Interning checker always checks all
subclasses and superclasses of the given class.</P><!--TOC section Examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="interning-example">4.4</A>&#XA0;&#XA0;Examples</H2><!--SEC END --><P>To try the Interning checker on a source file that uses the <TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A> qualifier,
use the following command (where <TT>javac</TT> is the JSR 308 compiler that
is distributed with the Checker Framework):</P><PRE CLASS="verbatim">  javac -processor checkers.interning.InterningChecker examples/InterningExample.java
</PRE><P>Compilation will complete without warnings.</P><P>To see the checker warn about incorrect usage of annotations, use the following
command:</P><PRE CLASS="verbatim">  javac -processor checkers.interning.InterningChecker examples/InterningExampleWithWarnings.java
</PRE><P>The compiler will issue a warning regarding violation of the semantics of
<TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A>.
</P><P>The Daikon invariant detector
(<A HREF="http://groups.csail.mit.edu/pag/daikon/"><TT>http://groups.csail.mit.edu/pag/daikon/</TT></A>) is also annotated with
<TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A>. From directory <TT>java</TT>,
run <TT>make check-interning</TT>.</P><!--TOC section Other interning annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="other-interning-annotations">4.5</A>&#XA0;&#XA0;Other interning annotations</H2><!--SEC END --><P>The Checker Framework&#X2019;s interning annotations are similar to annotations used
elsewhere.</P><P>If your code is already annotated with a different interning
annotation, you can reuse that effort by converting them to the Checker
Framework&#X2019;s nullness annotations. Perform the refactoring described in
Figure&#XA0;<A HREF="#fig:interning-refactoring">4.2</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> &#XA0;com.sun.istack.Interned&#XA0;</TD></TR>
</TABLE></TD><TD ALIGN=left NOWRAP>&#X21D2;
&#XA0;checkers.interning.quals.Interned&#XA0;</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 4.2: Refactoring for converting interning annotations from other tools
to the Checker Framework.</TD></TR>
</TABLE></DIV>
<A NAME="fig:interning-refactoring"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Alternately, the Checker Framework can process those other annotations (as
well as its own, if they also appear in your program). The Checker
Framework has its own definition of the annotations on the left side of
Figure&#XA0;<A HREF="#fig:interning-refactoring">4.2</A>, so that they can be used as type
qualifiers. The Checker Framework interprets them according to the right
side of Figure&#XA0;<A HREF="#fig:interning-refactoring">4.2</A>.</P><HR><!--TOC chapter IGJ immutability checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="igj-checker">Chapter&#XA0;5</A>&#XA0;&#XA0;IGJ immutability checker</H1><!--SEC END --><P>IGJ is a Java language extension that helps programmers to avoid mutation errors
(unintended side effects).
If the IGJ checker issues no warnings for a given program, then that program
will never change objects that should not be changed. This guarantee
enables a programmer to detect and prevent mutation-related errors.
(See Section&#XA0;<A HREF="#checker-guarantees">2.3</A> for caveats to the guarantee.)</P><P>To run the IGJ Checker, supply the <TT>-processor checkers.igj.IGJChecker</TT>
command-line option to javac. For examples, see Section&#XA0;<A HREF="#igj-example">5.7</A>.</P><!--TOC section IGJ and Mutability-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="igj-and-mutability">5.1</A>&#XA0;&#XA0;IGJ and Mutability</H2><!--SEC END --><P>IGJ&#XA0;[<A HREF="#ZibinPAAKE2007">ZPA<SUP>+</SUP>07</A>] permits a
programmer to express that a particular object should never be modified via any
reference (object immutability), or that a reference should never be used to
modify its referent (reference immutability). Once a programmer has expressed
these facts, an automatic checker analyzes the code to either locate mutability
bugs or to guarantee that the code contains no such bugs.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<DIV CLASS="center">
<IMG SRC="igj.png" ALT="igj.png"></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 5.1: Type hierarchy for three of IGJ&#X2019;s type qualifiers.</TD></TR>
</TABLE></DIV>
<A NAME="fig:igj-hierarchy"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>To learn more details of the IGJ language and type system, please see the
ESEC/FSE 2007 paper &#X201C;<A HREF="http://www.cs.washington.edu/homes/mernst/pubs/immutability-generics-fse2007-abstract.html">Object and reference immutability using Java
generics</A>&#X201D;&#XA0;[<A HREF="#ZibinPAAKE2007">ZPA<SUP>+</SUP>07</A>].
The IGJ checker supports Annotation IGJ (Section&#XA0;<A HREF="#annotation-igj-dialect">5.5</A>),
which is a slightly different dialect
of IGJ than that described in the ESEC/FSE paper.</P><!--TOC section IGJ Annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="igj-annotations">5.2</A>&#XA0;&#XA0;IGJ Annotations</H2><!--SEC END --><P>Each object is either immutable (it can never be modified) or mutable (it
can be modified). The following qualifiers are part of the IGJ type system.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/igj/quals/Immutable.html"><B><TT>Immutable</TT></B></A></DT><DD CLASS="dd-description">
An immutable reference always refers to an immutable object. Neither the
reference, nor any aliasing reference, may modify the object.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/igj/quals/Mutable.html"><B><TT>Mutable</TT></B></A></DT><DD CLASS="dd-description">
A mutable reference refers to a mutable object. The reference, or some
aliasing mutable reference, may modify the object.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/igj/quals/ReadOnly.html"><B><TT>ReadOnly</TT></B></A></DT><DD CLASS="dd-description">
A readonly reference cannot be used to modify its referent. The referent
may be an immutable or a mutable object. In other words, it is possible
for the referent to change via an aliasing mutable reference, even though
the referent cannot be changed via the readonly reference.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/igj/quals/Assignable.html"><B><TT>Assignable</TT></B></A></DT><DD CLASS="dd-description">
The annotated field may be re-assigned regardless of the
immutability of the enclosing class or object instance.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/igj/quals/AssignsFields.html"><B><TT>AssignsFields</TT></B></A></DT><DD CLASS="dd-description">
is similar to <TT>@Mutable</TT>, but permits only limited mutation &#X2014;
assignment of fields &#X2014; and is intended for use by constructor helper
methods.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/igj/quals/I.html"><B><TT>I</TT></B></A></DT><DD CLASS="dd-description">
simulates mutability overloading or the template behavior of generics.
It can be applied to classes, methods, and parameters. See
Section&#XA0;<A HREF="#igj-templating">5.5.3</A>.</DD></DL><P>For additional details, see&#XA0;[<A HREF="#ZibinPAAKE2007">ZPA<SUP>+</SUP>07</A>].</P><!--TOC section What the IGJ checker checks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="igj-checks">5.3</A>&#XA0;&#XA0;What the IGJ checker checks</H2><!--SEC END --><P>The IGJ checker issues an error whenever mutation happens through a
readonly reference, when fields of a readonly reference which are not
explicitly marked with <TT>@</TT><A HREF="doc/checkers/igj/quals/Assignable.html"><TT>Assignable</TT></A> are
reassigned, or when a readonly reference is assigned to a mutable
variable. The checker also emits a warning when casts increase the
mutability access of a reference.</P><!--TOC section Implicit and default qualifiers-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="igj-implicit-qualifiers">5.4</A>&#XA0;&#XA0;Implicit and default qualifiers</H2><!--SEC END --><P>As described in Section&#XA0;<A HREF="#effective-qualifier">19.1</A>, the IGJ checker
adds implicit qualifiers, reducing the number of annotations that must
appear in your code.
</P><P>For a complete description of all implicit IGJ qualifiers, see the
Javadoc for <A HREF="doc/checkers/igj/IGJAnnotatedTypeFactory.html"><TT>IGJAnnotatedTypeFactory</TT></A>.</P><P>The default annotation (for types that are unannotated and not given an
implicit qualifier) is as follows:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>@Mutable</TT> for almost all references. This is backward-compatible
with Java, since Java permits any reference to be mutated.
</LI><LI CLASS="li-itemize"><TT>@Readonly</TT> for local variables. This qualifier may be refined by
flow-sensitive local type refinement (see Section&#XA0;<A HREF="#type-refinement">19.1.2</A>).
</LI><LI CLASS="li-itemize"><TT>@Readonly</TT> for type parameter and wildcard bounds. For example,<PRE CLASS="verbatim">  interface List&lt;T extends Object&gt; { ... }
</PRE><P>is defaulted to</P><PRE CLASS="verbatim">  interface List&lt;T extends @Readonly Object&gt; { ... }
</PRE><P>This default is not backward-compatible &#X2014; that is, you may have to
explicitly add <TT>@Mutable</TT> annotations to some type parameter bounds in
order to make unannotated Java code type-check under IGJ. However, this
reduces the number of annotations you must write overall (since most
variables of generic type are in fact not modified), and permits more
client code to type-check (otherwise a client could not write
<TT>List&lt;@Readonly Date&gt;</TT>).</P></LI></UL><!--TOC section Annotation IGJ Dialect-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="annotation-igj-dialect">5.5</A>&#XA0;&#XA0;Annotation IGJ Dialect</H2><!--SEC END --><P>The IGJ checker supports the Annotation IGJ dialect of IGJ. The syntax of
Annotation IGJ is based on type annotations.</P><P>The syntax of the original IGJ
dialect&#XA0;[<A HREF="#ZibinPAAKE2007">ZPA<SUP>+</SUP>07</A>] was based on Java 5&#X2019;s generics and annotation mechanisms. The original
IGJ dialect was not backward-compatible with Java (either syntactically or
semantically). The dialect of IGJ checked by the IGJ checker corrects these
problems.</P><P>The differences between the Annotation IGJ dialect and the original IGJ dialect
are as follows.</P><!--TOC subsection Semantic Changes-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.5.1&#XA0;&#XA0;Semantic Changes</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">Annotation IGJ does not permit covariant changes in generic type
arguments, for backward compatibility with Java. In ordinary Java, types
with different generic type arguments, such as <TT>Vector&lt;Integer&gt;</TT> and
<TT>Vector&lt;Number&gt;</TT>, have no subtype relationship, even if the
arguments (<TT>Integer</TT> and <TT>Number</TT>) do. The original IGJ dialect
changed the Java subtyping rules to permit safely varying a type argument
covariantly in certain circumstances. For example,<PRE CLASS="verbatim">  Vector&lt;Mutable, Integer&gt;  &lt;:  Vector&lt;ReadOnly, Integer&gt;
                            &lt;:  Vector&lt;ReadOnly, Number&gt;
                            &lt;:  Vector&lt;ReadOnly, Object&gt;
</PRE><P>is valid in IGJ, but in Annotation IGJ, only</P><PRE CLASS="verbatim">  @Mutable Vector&lt;Integer&gt;  &lt;:  @ReadOnly Vector&lt;Integer&gt;
</PRE><P>holds and the other two subtype relations do not hold</P><PRE CLASS="verbatim">  @ReadOnly Vector&lt;Integer&gt; &lt;/:  @ReadOnly Vector&lt;Number&gt;
                            &lt;/:  @ReadOnly Vector&lt;Object&gt;
</PRE></LI><LI CLASS="li-itemize">Annotation IGJ supports array immutability. The original IGJ dialect did
not permit the (im)mutability of array elements to be specified, because
the generics syntax used by the original IGJ dialect cannot be applied to
array elements.</LI></UL><!--TOC subsection Syntax Changes-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->5.5.2&#XA0;&#XA0;Syntax Changes</H3><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">Immutability is specified through
<A HREF="http://types.cs.washington.edu/jsr308/">type annotations</A>&#XA0;[<A HREF="#JSR308-2008-09-12">Ern08</A>] (Section&#XA0;<A HREF="#igj-annotations">5.2</A>),
not through a combination of generics and annotations. Use of type
annotations makes Annotation IGJ backward compatible with Java syntax.</LI><LI CLASS="li-itemize">Templating over Immutability: The annotation <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A><TT>(</TT><TT><EM>id</EM></TT><TT>)</TT> is used to template
over immutability. See Section&#XA0;<A HREF="#igj-templating">5.5.3</A>.</LI></UL><!--TOC subsection Templating Over Immutability: <TT>@I</TT>-->
<H3 CLASS="subsection"><A NAME="igj-templating"><!--SEC ANCHOR -->5.5.3&#XA0;&#XA0;Templating Over Immutability: <TT>@I</TT></A></H3><!--SEC END --><P><TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> is a template annotation over IGJ Immutability annotations. It acts
similarly to type variables in Java&#X2019;s generic types, and the name
<TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> mimics the standard <TT>&lt;I&gt;</TT> type variable name used in code
written in the original IGJ dialect. The annotation value string is used
to distinguish between multiple instances of <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> &#X2014; in the
generics-based original dialect, these would be expressed as two type
variables <TT>&lt;I&gt;</TT> and <TT>&lt;J&gt;</TT>.</P><!--TOC paragraph Usage on classes-->
<H5 CLASS="paragraph"><A NAME="igj-usage-on-classes"><!--SEC ANCHOR -->Usage on classes</A></H5><!--SEC END --><P>A class declaration annotated with <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> can then be
used with any IGJ Immutability annotation. The actual immutability that
<TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> is resolved to dictates the immutability type for all the non-static
appearances of <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> with the same value as the class declaration.</P><P>Example:
</P><PRE CLASS="verbatim">    @I
    public class FileDescriptor {
       private @Immutable Date creationData;
       private @I Date lastModData;

       public @I Date getLastModDate() @ReadOnly { }
    }

    ...
    void useFileDescriptor() {
       @Mutable FileDescriptor file =
                         new @Mutable FileDescriptor(...);
       ...
       @Mutable Data date = file.getLastModDate();

    }
</PRE><P>In the last example, <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> was resolved to <TT>@</TT><A HREF="doc/checkers/igj/quals/Mutable.html"><TT>Mutable</TT></A> for the instance file.</P><!--TOC paragraph Usage on methods-->
<H5 CLASS="paragraph"><A NAME="igj-usage-on-methods"><!--SEC ANCHOR -->Usage on methods</A></H5><!--SEC END --><P>For example, it could be used for method parameters, return values, and the
actual IGJ immutability value would be resolved based on the method invocation.</P><P>For example, the below method <TT>getMidpoint</TT> returns a <TT>Point</TT> with the same
immutability type as the passed parameters if <TT>p1</TT> and <TT>p2</TT> match
in immutability, otherwise <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> is resolved to <TT>@</TT><A HREF="doc/checkers/igj/quals/ReadOnly.html"><TT>ReadOnly</TT></A>:</P><PRE CLASS="verbatim">  static @I Point getMidpoint(@I Point p1, @I Point p2) { ... }
</PRE><P>The <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A> annotation value distinguishes between <TT>@</TT><A HREF="doc/checkers/igj/quals/I.html"><TT>I</TT></A>
declarations. So, the below method <TT>findUnion</TT> returns a collection of the same
immutability type as the <EM>first</EM> collection parameter:</P><PRE CLASS="verbatim">  static &lt;E&gt; @I("First") Collection&lt;E&gt; findUnion(@I("First") Collection&lt;E&gt; col1,
                                                 @I("Second") Collection&lt;E&gt; col2) { ... }
</PRE><!--TOC section Iterators and their abstract state-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="igj-library-annotations">5.6</A>&#XA0;&#XA0;Iterators and their abstract state</H2><!--SEC END --><P>This section explains why the receiver of <TT>Iterator.next()</TT> is annotated
as <TT>@ReadOnly</TT>.</P><P>An iterator conceptually has two pieces of state:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
the underlying collection
</LI><LI CLASS="li-enumerate">an index into that collection (indicating the next object to be returned)
</LI></OL><P>We choose to exclude the index from the abstract state of the iterator.
That is, a change to the index does not count as a mutation of the
iterator itself.</P><P>Changes to the underlying collection are more important and interesting,
and unintentional changes are much more likely to lead to important
errors. Therefore, this choice about the iterator&#X2019;s abstract state
appears to be more useful than other choices. For example, if the
iterator&#X2019;s abstract state included both the underlying collection and
the index, then there would be no way to express, or check, that
<TT>Iterator.next</TT> does not change the underlying collection.</P><!--TOC section Examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="igj-example">5.7</A>&#XA0;&#XA0;Examples</H2><!--SEC END --><P>To try the IGJ checker on a source file that uses the IGJ qualifier, use
the following command (where <TT>javac</TT> is the JSR 308 compiler that
is distributed with the Checker Framework).</P><PRE CLASS="verbatim">  javac -processor checkers.igj.IGJChecker examples/IGJExample.java
</PRE><P>The IGJ checker itself is also annotated with IGJ annotations.</P><HR><!--TOC chapter Javari immutability checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="javari-checker">Chapter&#XA0;6</A>&#XA0;&#XA0;Javari immutability checker</H1><!--SEC END --><P>Javari&#XA0;[<A HREF="#TschantzE2005">TE05</A>, <A HREF="#QuinonezTE2008">QTE08</A>] is a Java language extension that helps programmers to avoid mutation
errors that result from unintended side effects.
If the Javari checker issues no warnings for a given program, then that
program will never change objects that should not be changed. This
guarantee enables a programmer to detect and prevent mutation-related
errors. (See Section&#XA0;<A HREF="#checker-guarantees">2.3</A> for caveats to the guarantee.)
The Javari webpage (<A HREF="http://types.cs.washington.edu/javari/"><TT>http://types.cs.washington.edu/javari/</TT></A>) contains
papers that explain the Javari language and type system.
By contrast to those papers, the Javari checker uses an annotation-based
dialect of the Javari language.</P><P>The Javarifier tool infers Javari types for an existing program; see
Section&#XA0;<A HREF="#javari-inference">6.2.2</A>.</P><P>Also consider the IGJ checker (Chapter&#XA0;<A HREF="#igj-checker">5</A>). The IGJ type
system is more expressive than that of Javari, and the IGJ checker is a bit
more robust. However, IGJ lacks a type inference tool such as Javarifier.</P><P>To run the Javari Checker, supply the <TT>-processor
checkers.javari.JavariChecker</TT> command-line option to javac. For
examples, see Section&#XA0;<A HREF="#javari-examples">6.5</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<DIV CLASS="center">
<IMG SRC="javari.png" ALT="javari.png"></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 6.1: Type hierarchy for Javari&#X2019;s ReadOnly type qualifier.</TD></TR>
</TABLE></DIV>
<A NAME="fig:javari-hierarchy"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC section Javari annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="javary-annotations">6.1</A>&#XA0;&#XA0;Javari annotations</H2><!--SEC END --><P>The following six annotations make up the Javari type system.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/javari/quals/ReadOnly.html"><B><TT>ReadOnly</TT></B></A></DT><DD CLASS="dd-description">
indicates a type that provides only read-only access. A reference of
this type may not be used to modify its referent, but aliasing references
to that object might change it.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/javari/quals/Mutable.html"><B><TT>Mutable</TT></B></A></DT><DD CLASS="dd-description">
indicates a mutable type.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/javari/quals/Assignable.html"><B><TT>Assignable</TT></B></A></DT><DD CLASS="dd-description">
is a field annotation, not a type qualifier. It indicates that the given
field may always be assigned, no matter what the type of the reference
used to access the field.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/javari/quals/QReadOnly.html"><B><TT>QReadOnly</TT></B></A></DT><DD CLASS="dd-description">
corresponds to Javari&#X2019;s &#X201C;<TT>? readonly</TT>&#X201D; for wildcard types. An
example of its use is <TT>List&lt;@QReadOnly Date&gt;</TT>. It allows only the
operations which are allowed for both readonly and mutable types.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/javari/quals/PolyRead.html"><B><TT>PolyRead</TT></B></A></DT><DD CLASS="dd-description">
(previously named <TT>@RoMaybe</TT>) specifies polymorphism over
mutability; it simulates mutability overloading. It can be applied to
methods and parameters. See Section&#XA0;<A HREF="#qualifier-polymorphism">18.2</A> and the
<TT>@</TT><A HREF="doc/checkers/javari/quals/PolyRead.html"><TT>PolyRead</TT></A> Javadoc for more details.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/javari/quals/ThisMutable.html"><B><TT>ThisMutable</TT></B></A></DT><DD CLASS="dd-description">
means that the mutability of the field is the same as that of the
reference that contains it. <TT>@ThisMutable</TT> is the default on
fields, and does not make sense to write elsewhere. Therefore,
<TT>@ThisMutable</TT> should never appear in a program.</DD></DL><!--TOC section Writing Javari annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-javari-annotations">6.2</A>&#XA0;&#XA0;Writing Javari annotations</H2><!--SEC END --><!--TOC subsection Implicit qualifiers-->
<H3 CLASS="subsection"><A NAME="javari-implicit-qualifiers"><!--SEC ANCHOR -->6.2.1&#XA0;&#XA0;Implicit qualifiers</A></H3><!--SEC END --><P>As described in Section&#XA0;<A HREF="#effective-qualifier">19.1</A>, the Javari checker
adds implicit qualifiers, reducing the number of annotations that must
appear in your code.
</P><P>For a complete description of all implicit Javari qualifiers, see the
Javadoc for <A HREF="doc/checkers/javari/JavariAnnotatedTypeFactory.html"><TT>JavariAnnotatedTypeFactory</TT></A>.</P><!--TOC subsection Inference of Javari annotations-->
<H3 CLASS="subsection"><A NAME="javari-inference"><!--SEC ANCHOR -->6.2.2&#XA0;&#XA0;Inference of Javari annotations</A></H3><!--SEC END --><P>It can be tedious to write annotations in your code. The Javarifier tool
(<A HREF="http://types.cs.washington.edu/javari/javarifier/"><TT>http://types.cs.washington.edu/javari/javarifier/</TT></A>) infers 
Javari types for an existing program. It 
automatically inserts Javari annotations in your Java program or
in <TT>.class</TT> files.</P><P>This has two benefits: it relieves the programmer of the tedium of writing
annotations (though the programmer can always refine the inferred
annotations), and it annotates libraries, permitting checking of programs
that use those libraries.</P><!--TOC section What the Javari checker checks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="javari-checks">6.3</A>&#XA0;&#XA0;What the Javari checker checks</H2><!--SEC END --><P>The checker issues an error whenever mutation happens through a readonly
reference, when fields of a readonly reference which are not explicitly
marked with <TT>@</TT><A HREF="doc/checkers/javari/quals/Assignable.html"><TT>Assignable</TT></A> are reassigned, or
when a readonly expression is assigned to a mutable variable. The checker
also emits a warning when casts increase the mutability access of a
reference.</P><!--TOC section Iterators and their abstract state-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="javari-library-annotations">6.4</A>&#XA0;&#XA0;Iterators and their abstract state</H2><!--SEC END --><P>For an explanation of why the receiver of <TT>Iterator.next()</TT> is annotated
as <TT>@ReadOnly</TT>, see Section&#XA0;<A HREF="#igj-library-annotations">5.6</A>.</P><!--TOC section Examples-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="javari-examples">6.5</A>&#XA0;&#XA0;Examples</H2><!--SEC END --><P>To try the Javari checker on a source file that uses the Javari
qualifier, use the following command (where <TT>javac</TT> is the JSR 308
compiler that
is distributed with the Checker Framework). Alternately, you may
specify just one of the test files.</P><PRE CLASS="verbatim">  javac -processor checkers.javari.JavariChecker tests/javari/*.java
</PRE><P>The compiler should issue the errors and warnings (if any) specified in the
<TT>.out</TT> files with same name.</P><P>To run the test suite for the Javari checker, use <TT>ant javari-tests</TT>.</P><P>The Javari checker itself is also annotated with Javari annotations.</P><HR><!--TOC chapter Lock checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="lock-checker">Chapter&#XA0;7</A>&#XA0;&#XA0;Lock checker</H1><!--SEC END --><P>The Lock checker prevents certain kinds of concurrency errors. If the Lock
checker issues no warnings for a given program, then the program holds the
appropriate lock every time that it accesses a variable.</P><P>Note: This does <EM>not</EM> mean that your program has <EM>no</EM> concurrency
errors. (You might have forgotten to annotate that a particular variable
should only be accessed when a lock is held. You might release and
re-acquire the lock, when correctness requires you to hold it throughout a
computation. And, there are other concurrency errors that cannot, or
should not, be solved with locks.) However, ensuring that your
program obeys its locking discipline is an easy and effective way to
eliminate a common and important class of errors.</P><P>To run the Lock Checker, supply the <TT>-processor
checkers.lock.LockChecker</TT> command-line option to javac.</P><!--TOC section Lock annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="lock-annotations">7.1</A>&#XA0;&#XA0;Lock annotations</H2><!--SEC END --><P>The Lock checker uses two annotations. One is a type qualifier, and the
other is a method annotation.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/lock/quals/GuardedBy.html"><B><TT>GuardedBy</TT></B></A></DT><DD CLASS="dd-description">
indicates a type whose value may be accessed only when the given lock is
held. See the <A HREF="doc/checkers/lock/quals/GuardedBy.html">GuardedBy
Javadoc</A> for an explanation of the argument. The lock
acquisition and the value access may be arbitrarily far in the future;
or, if the value is never accessed, the lock never need be held.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/lock/quals/Holding.html"><B><TT>Holding</TT></B></A></DT><DD CLASS="dd-description">
is a method annotation (not a type qualifier). It indicates that when
the method is called, the given lock must be held by the caller.
In other words, the given lock is already held at the time the method is
called.</DD></DL><!--TOC subsection Examples-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->7.1.1&#XA0;&#XA0;Examples</H3><!--SEC END --><P>Most often, field values are annotated with <TT>@GuardedBy</TT>, but other
uses are possible.</P><P>A return value may be annotated with <TT>@GuardedBy</TT>:</P><PRE CLASS="verbatim">  @GuardedBy("MyClass.myLock") Object myMethod() { ... }

  // reassignments without holding the lock are OK.
  @GuardedBy("MyClass.myLock") Object x = myMethod();
  @GuardedBy("MyClass.myLock") Object y = x;
  Object z = x;  // ILLEGAL (assuming no lock inference),
                 // because z can be freely accessed.
  x.toString() // ILLEGAL because the lock is not held
  synchronized(MyClass.myLock) {
    y.toString();  // OK: the lock is held
  }
</PRE><P>A parameter may be annotated with <TT>@GuardedBy</TT>:</P><PRE CLASS="verbatim">  void helper1(@GuardedBy("MyClass.myLock") Object a) {
    a.toString(); // ILLEGAL: the lock is not held
    synchronized(MyClass.myLock) {
      a.toString();  // OK: the lock is held
    }
  }
  @Holding("MyClass.myLock")
  void helper2(@GuardedBy("MyClass.myLock") Object b) {
    b.toString(); // OK: the lock is held
  }
  void helper3(Object c) {
    c.toString(); // OK: no lock constraints
  }
  void helper4(@GuardedBy("MyClass.myLock") Object d) {
    d.toString(); // ILLEGAL: the lock is not held
  }
  void myMethod2(@GuardedBy("MyClass.myLock") Object e) {
    helper1(e);  // OK to pass to another routine without holding the lock
    e.toString(); // ILLEGAL: the lock is not held
    synchronized (MyClass.myLock) {
      helper2(e);
      helper3(e);
      helper4(e); // OK, but helper4's body still does not type-check
    }
  }
</PRE><!--TOC subsection Discussion of <TT>@Holding</TT>-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->7.1.2&#XA0;&#XA0;Discussion of <TT>@Holding</TT></H3><!--SEC END --><P>A programmer might choose to use the <TT>@Holding</TT> method annotation in
two different ways: to specify a higher-level protocol, or to summarize
intended usage. Both of these approaches are useful, and the Lock checker
supports both.</P><!--TOC paragraph Higher-level synchronization protocol-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Higher-level synchronization protocol</H5><!--SEC END --><P><TT>@Holding</TT> can specify a higher-level synchronization protocol that
is not expressible as locks over Java objects. By requiring locks to be
held, you can create higher-level protocol primitives without giving up
the benefits of the annotations and checking of them.</P><!--TOC paragraph Method summary that simplifies reasoning-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Method summary that simplifies reasoning</H5><!--SEC END --><P><TT>@Holding</TT> can be a method summary that simplifies reasoning. In
this case, the <TT>@Holding</TT> doesn&#X2019;t necessarily introduce a new
correctness constraint; the program might be correct even if the lock
were acquired later in the body of the method or in a method it calls, so
long as the lock is acquired before accessing the data it protects.</P><P>Rather, here <TT>@Holding</TT> expresses a fact about execution: when
execution reaches this point, the following locks are already held. This
fact enables people and tools to reason intra- rather than
inter-procedurally.</P><P>In Java, it is always legal to re-acquire a lock that is already held,
and the re-acquisition always works. Thus, whenever you write </P><PRE CLASS="verbatim">  @Holding("myLock")
  void myMethod() {
    ...
  }
</PRE><P>it would be equivalent, from the point of view of which locks are held
during the body, to write</P><PRE CLASS="verbatim">  void myMethod() {
    synchronized (myLock) {   // no-op:  re-aquire a lock that is already held
      ...
    }
  }
</PRE><P>The advantages of the <TT>@Holding</TT> annotation include:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The annotation documents the fact that the lock is intended to already be
held.
</LI><LI CLASS="li-itemize">The Lock Checker enforces that the lock is held when the method is
called, rather than masking a programmer error by silently re-acquiring
the lock.
</LI><LI CLASS="li-itemize">The <TT>synchronized</TT> statement can deadlock if, due to a programmer error,
the lock is not already held. The Lock Checker prevents this type of
error.
</LI><LI CLASS="li-itemize">The annotation has no run-time overhead. Even if the lock re-acquisition
succeeds, it still consumes time.
</LI></UL><!--TOC subsection Relationship to annotations in <EM>Java Concurrency in Practice</EM>-->
<H3 CLASS="subsection"><A NAME="jcip-annotations"><!--SEC ANCHOR -->7.1.3&#XA0;&#XA0;Relationship to annotations in <EM>Java Concurrency in Practice</EM></A></H3><!--SEC END --><P>The book <A HREF="http://jcip.net/"><EM>Java Concurrency in Practice</EM></A>&#XA0;[<A HREF="#Goetz2006">GPB<SUP>+</SUP>06</A>] defines a
<A HREF="http://jcip.net/annotations/doc/net/jcip/annotations/GuardedBy.html"><TT>@GuardedBy</TT></A> annotation that is the inspiration for ours. The book&#X2019;s
<TT>@GuardedBy</TT> serves two related purposes:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
When applied to a field, it means that the given lock must be held when
accessing the field. The lock acquisition and the field access may be
arbitrarily far in the future.
</LI><LI CLASS="li-itemize">When applied to a method, it means that the given lock must be held by
the caller at the time that the method is called &#X2014; in other words, at
the time that execution passes the <TT>@GuardedBy</TT> annotation.
</LI></UL><P>One rationale for reusing the annotation name for both purposes in JCIP is
that there are fewer annotations to learn. Another rationale is
that both variables and methods are &#X201C;members&#X201D; that can be &#X201C;accessed&#X201D;;
variables can be accessed by reading or writing them (putfield, getfield),
and methods can be accessed by calling them (invokevirtual,
invokeinterface). In both cases, <TT>@GuardedBy</TT> creates preconditions
for accessing so-annotated members. This informal intuition is
inappropriate for a tool that requires precise semantics.</P><P>The Lock checker renames the method annotation to
<TT>@</TT><A HREF="doc/checkers/lock/quals/Holding.html"><TT>Holding</TT></A>, and it generalizes the 
<TT>@</TT><A HREF="doc/checkers/lock/quals/GuardedBy.html"><TT>GuardedBy</TT></A> annotation into a type qualifier
that can apply not just to a field but to an arbitrary type (including the
type of a parameter, return value, local variable, generic type parameter,
etc.). This makes the annotations more expressive and also more amenable
to automated checking. It also accommodates the distinct (though related)
meanings of the two annotations.</P><HR><!--TOC chapter Fake Enum checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="fenum-checker">Chapter&#XA0;8</A>&#XA0;&#XA0;Fake Enum checker</H1><!--SEC END --><P>Java&#X2019;s 
<A HREF="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.9"><TT>enum</TT></A>
keyword lets you define an enumeration type: a finite set of distinct values
that are related to one another but are disjoint from all other
types, including other enumerations.
Before enums were added to Java, there were two ways to encode an
enumeration, both of which are error-prone:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>the fake enum pattern</B></DT><DD CLASS="dd-description"> a set of <TT>int</TT> or <TT>String</TT>
constants (as often found in older C code).</DD><DT CLASS="dt-description"><B>the </B><A HREF="http://java.sun.com/developer/Books/shiftintojava/page1.html"><B>typesafe
enum pattern</B></A></DT><DD CLASS="dd-description"> a class with private constructor.
</DD></DL><P>Sometimes you need to use the fake enum pattern,
rather than a real enum or the typesafe enum pattern.
One reason is backward-compatibility. A public API that predates Java&#X2019;s
enum keyword may use <TT>int</TT> constants; it cannot be changed, because
doing so would break existing clients. For example, Java&#X2019;s JDK still uses
<TT>int</TT> constants in the AWT and Swing frameworks.
Another reason is performance, especially in environments with limited
resources. For example, the Android mobile phone platform
<A HREF="http://developer.android.com/guide/practices/design/performance.html#avoid_enums">recommends</A>
use of fake enums when only an integer value is needed, in order to reduce
code size and run time.</P><P>In cases when code has to use the fake enum pattern, the fake enum (Fenum)
checker gives the same safety guarantees as a true enumeration type. 
The developer can introduce new types that are distinct from all values of the
base type and from all other fake enums. Fenums can be introduced for
primitive types as well as for reference types.</P><P>Figure&#XA0;<A HREF="#fig:fenum-hierarchy">8.1</A> shows part of the type hierarchy for the
Fenum type system.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<DIV CLASS="center">
<IMG SRC="fenum.png" ALT="fenum.png"></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 8.1: Partial type hierarchy for the Fenum type system.
Fenums that take the form of <TT>@Fenum("A")</TT> and <TT>@Fenum("B")</TT> are user
defined fenums while fenums that take the form of <TT>@FenumC</TT> and <TT>@FenumD</TT> are
built-in fenums. See section&#XA0;<A HREF="#fenum-annotations">8.1</A> for descriptions of how to
introduce both types of fenums. Fenums in gray should never be used but are
provided for the benefit of the type system.</TD></TR>
</TABLE></DIV>
<A NAME="fig:fenum-hierarchy"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC section Fake enum annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="fenum-annotations">8.1</A>&#XA0;&#XA0;Fake enum annotations</H2><!--SEC END --><P>The checker supports two ways to introduce a new fake enum (fenum):</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Introduce your own specialized fenum annotation with code like this in
file <TT><EM>MyFenum</EM></TT><TT>.java</TT>:<PRE>
package <I>myproject</I>.quals;

import java.lang.annotation.*;
import checkers.quals.SubtypeOf;
import checkers.quals.TypeQualifier;

@Documented
@Retention(RetentionPolicy.RUNTIME)
@TypeQualifier
@SubtypeOf( <TT>{</TT> FenumTop.class <TT>}</TT> )
public @interface <I>MyFenum</I> <TT>{</TT><TT>}</TT>
</PRE><P>You only need to adapt the package, annotation, and file names in the example.</P></LI><LI CLASS="li-enumerate">Use the provided <TT>@</TT><A HREF="doc/checkers/fenum/quals/Fenum.html"><TT>Fenum</TT></A> annotation, which takes a
<TT>String</TT> argument to distinguish different fenums.
For example, <TT>@Fenum("A")</TT> and <TT>@Fenum("B")</TT> are two distinct fenums.
</LI></OL><P>The first approach allows you to define a short, meaningful name suitable for
your project, whereas the second approach allows quick prototyping.</P><!--TOC section What the Fenum checker checks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="fenum-checks">8.2</A>&#XA0;&#XA0;What the Fenum checker checks</H2><!--SEC END --><P>The Fenum checker ensures that unrelated types are not mixed. 
All types with a particular fenum annotation, or <TT>@Fenum(...)</TT> with a particular <TT>String</TT> argument, are
disjoint from all unannotated types and all types with a different fenum
annotation or <TT>String</TT> argument.</P><P>The checker forbids method calls on fenum types and ensures that
only compatible fenum types are used in comparisons and arithmetic operations
(if applicable to the annotated type).</P><P>It is the programmer&#X2019;s responsibility to ensure that fields with a fenum type
are properly initialized before use. Otherwise, one might observe a <TT>null</TT>
reference or zero value in the field of a fenum type. (The Nullness checker
(Chapter&#XA0;<A HREF="#nullness-checker">3</A>) can prevent failure to initialize a
reference variable.)</P><!--TOC section Running the Fenum checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="fenum-running">8.3</A>&#XA0;&#XA0;Running the Fenum checker</H2><!--SEC END --><P>The Fenum checker can be invoked by running the following commands.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
If you define your own annotation, provide the name of the annotation using the
<TT>-Aquals</TT> option:<PRE>
  javac -processor checkers.fenum.FenumChecker
        <I>-Aquals=myproject.quals.MyFenum</I> MyFile.java ...
</PRE></LI><LI CLASS="li-itemize">If your code uses the <TT>@</TT><A HREF="doc/checkers/fenum/quals/Fenum.html"><TT>Fenum</TT></A> annotation, you do
not need the <TT>-Aquals</TT> option:<PRE CLASS="verbatim">  javac -processor checkers.fenum.FenumChecker MyFile.java ...
</PRE></LI></UL><!--TOC section Suppressing warnings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="fenum-suppressing">8.4</A>&#XA0;&#XA0;Suppressing warnings</H2><!--SEC END --><P>One example of when you need to suppress warnings is when you initialize the
fenum constants to literal values.
To remove this warning message, add a <TT>@SuppressWarnings</TT> annotation to either
the field or class declaration, for example:</P><PRE CLASS="verbatim">@SuppressWarnings("fenum:assignment.type.incompatible")
class MyConsts {
  public static final @Fenum("A") int ACONST1 = 1;
  public static final @Fenum("A") int ACONST2 = 2;  
}
</PRE><!--TOC section Example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="fenum-example">8.5</A>&#XA0;&#XA0;Example</H2><!--SEC END --><P>The following example introduces two fenums in class <TT>TestStatic</TT>
and then performs a few typical operations.</P><PRE CLASS="verbatim">@SuppressWarnings("fenum:assignment.type.incompatible")   // for initialization
public class TestStatic {
  public static final @Fenum("A") int ACONST1 = 1;
  public static final @Fenum("A") int ACONST2 = 2;

  public static final @Fenum("B") int BCONST1 = 4;
  public static final @Fenum("B") int BCONST2 = 5;
}

class FenumUser {
  @Fenum("A") int state1 = TestStatic.ACONST1;     // ok
  @Fenum("B") int state2 = TestStatic.ACONST1;     // Incompatible fenums forbidden!

  void fenumArg(@Fenum("A") int p) {}
 
  void foo() {
    state1 = 4;                     // Direct use of value forbidden!
    state1 = TestStatic.BCONST1;    // Incompatible fenums forbidden!
    state1 = TestStatic.ACONST2;    // ok

    fenumArg(5);                    // Direct use of value forbidden!
    fenumArg(TestStatic.BCONST1);   // Incompatible fenums forbidden!
    fenumArg(TestStatic.ACONST1);   // ok
  }
 }
</PRE><!--TOC section References-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="fenum-references">8.6</A>&#XA0;&#XA0;References</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
Java Language Specification on enums:<BR>
 <A HREF="http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.9"><TT>http://java.sun.com/docs/books/jls/third_edition/html/classes.html#8.9</TT></A></LI><LI CLASS="li-itemize">Tutorial trail on enums:<BR>
 <A HREF="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html"><TT>http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</TT></A></LI><LI CLASS="li-itemize">Typesafe enum pattern:<BR>
 <A HREF="http://java.sun.com/developer/Books/shiftintojava/page1.html"><TT>http://java.sun.com/developer/Books/shiftintojava/page1.html</TT></A></LI><LI CLASS="li-itemize">Avoiding enums for performance:<BR>
 <A HREF="http://developer.android.com/guide/practices/design/performance.html#avoid_enums"><TT>http://developer.android.com/guide/practices/design/performance.html#avoid_enums</TT></A></LI><LI CLASS="li-itemize">Java Tip 122: Beware of Java typesafe enumerations:<BR>
 <A HREF="http://www.javaworld.com/javaworld/javatips/jw-javatip122.html"><TT>http://www.javaworld.com/javaworld/javatips/jw-javatip122.html</TT></A></LI></UL><HR><!--TOC chapter Tainting checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="tainting-checker">Chapter&#XA0;9</A>&#XA0;&#XA0;Tainting checker</H1><!--SEC END --><P>The tainting checker prevents certain kinds of trust errors.
A <EM>tainted</EM>, or untrusted, value is one that comes from an arbitrary,
possibly malicious source, such as user input or unvalidated data.
In certain parts of your application, using a tainted value can compromise
the application&#X2019;s integrity, causing it to crash, corrupt data, leak
private data, etc.</P><P>For example, a user-supplied pointer, handle, or map key should be
validated before being dereferenced.
As another example, a user-supplied string should not be concatenated into a
SQL query, lest the program be subject to a 
<A HREF="http://en.wikipedia.org/wiki/Sql_injection">SQL injection</A> attack.
A location in your program where malicious data could do damage is
called a <EM>sensitive sink</EM>.</P><P>A program must &#X201C;sanitize&#X201D; or &#X201C;untaint&#X201D; an untrusted value before using
it at a sensitive sink. There are two general ways to untaint a value:
by checking
that it is innocuous/legal (e.g., it contains no characters that can be
interpreted as SQL commands when pasted into a string context), or by
transforming the value to be legal (e.g., quoting all the characters that
can be interpreted as SQL commands). A correct program must use one of
these two techniques so that tainted values never flow to a sensitive sink.
The Tainting Checker ensures that your program does so.</P><P>If the Tainting Checker issues no warning for a given program, then no
tainted value ever flows to a sensitive sink. However, your program is not
necessarily free from all trust errors. As a simple example, you might
have forgotten to annotate a sensitive sink as requiring an untainted type,
or you might have forgotten to annotate untrusted data as having a tainted
type.</P><P>To run the Tainting Checker, supply the <TT>-processor
checkers.tainting.TaintingChecker</TT> command-line option to javac.
</P><!--TOC section Tainting annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="tainting-annotations">9.1</A>&#XA0;&#XA0;Tainting annotations</H2><!--SEC END --><P>The Tainting type system uses the following annotations:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>@</TT><A HREF="doc/checkers/tainting/quals/Untainted.html"><TT>Untainted</TT></A> indicates
a type that includes only untainted, trusted values.
</LI><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/tainting/quals/Tainted.html"><TT>Tainted</TT></A> indicates
a type that may include only tainted, untrusted values.
<TT>@Tainted</TT> is a supertype of <TT>@Untainted</TT>.
</LI><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/tainting/quals/PolyTainted.html"><TT>PolyTainted</TT></A> is a qualifier that is
polymorphic over tainting (see Section&#XA0;<A HREF="#qualifier-polymorphism">18.2</A>).
</LI></UL><!--TOC section Tips on writing <TT>@Untainted</TT> annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-untainted">9.2</A>&#XA0;&#XA0;Tips on writing <TT>@Untainted</TT> annotations</H2><!--SEC END --><P>Most programs are designed with a boundary that surrounds sensitive
computations, separating them from untrusted values. Outside this
boundary, the program may manipulate malicious values, but no malicious
values ever pass the boundary to be operated upon by sensitive
computations.</P><P>In some programs, the area outside the boundary is very small: values are
sanitized as soon as they are received from an external source. In other
programs, the area inside the boundary is very small: values are sanitized
only immediately before being used at a sensitive sink. Either approach
can work, so long as every possibly-tainted value is sanitized before it
reaches a sensitive sink.</P><P>Once you determine the boundary, annotating your program is easy: put
<TT>@Tainted</TT> outside the boundary, <TT>@Untainted</TT> inside, and
<TT>@SuppressWarnings("tainting")</TT> at the validation or
sanitization routines that are used at the boundary.
</P><P>The Tainting Checker&#X2019;s standard default qualifier is <TT>@Tainted</TT> (see
Section&#XA0;<A HREF="#defaults">19.1.1</A> for overriding this default). This is the safest
default, and the one that should be used for all code outside the boundary
(for example, code that reads user input). You can set the default
qualifier to <TT>@Untainted</TT> in code that may contain sensitive sinks.</P><P>The Tainting Checker does not know the intended semantics of your program,
so it cannot warn you if you mis-annotate a sensitive sink as taking
<TT>@Tainted</TT> data, or if you mis-annotate external data as
<TT>@Untainted</TT>. So long as you correctly annotate the sensitive sinks
and the places that untrusted data is read, the Tainting Checker will
ensure that all your other annotations are correct and that no undesired
information flows exist.</P><P>As an example, suppose that you wish to prevent SQL injection attacks. You
would start by annotating the
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/sql/Statement.html"><TT>Statement</TT></A> class to indicate that the
<TT>execute</TT> operations may only operate on untainted queries
(Chapter&#XA0;<A HREF="#annotating-libraries">21</A> describes how to annotate external
libraries):</P><PRE CLASS="verbatim">  public boolean execute(@Untainted String sql) throws SQLException;
  public boolean executeUpdate(@Untainted String sql) throws SQLException; 
</PRE><!--TOC section <TT>@Tainted</TT> and <TT>@Untainted</TT> can be used for many purposes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="tainting-many-uses">9.3</A>&#XA0;&#XA0;<TT>@Tainted</TT> and <TT>@Untainted</TT> can be used for many purposes</H2><!--SEC END --><P>The <TT>@Tainted</TT> and <TT>@Untainted</TT> annotations have only minimal
built-in semantics. In fact, the Tainting Checker provides only a small
amount of functionality beyond the Basic Checker
(Section&#XA0;<A HREF="#basic-checker">15</A>). This lack of hard-coded behavior means that
the annotations can serve many different purposes. Here are just a few
examples:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Prevent SQL injection attacks: <TT>@Tainted</TT> is external input,
<TT>@Untainted</TT> has been checked for SQL syntax.
</LI><LI CLASS="li-itemize">Prevent cross-site scripting attacks: <TT>@Tainted</TT> is external input,
<TT>@Untainted</TT> has been checked for JavaScript syntax.
</LI><LI CLASS="li-itemize">Prevent information leakage: <TT>@Tainted</TT> is secret data, 
<TT>@Untainted</TT> may be displayed to a user.
</LI></UL><P>In each case, you need to annotate the appropriate untainting/sanitization
routines. This is similar to the <TT>@Encrypted</TT> annotation
(Section&#XA0;<A HREF="#encrypted-example">15.2</A>), where the cryptographic functions are
beyond the reasoning abilities of the type system. In each case, the type
system verifies most of your code, and the <TT>@SuppressWarnings</TT>
annotations indicate the few places where human attention is needed.</P><P>If you want more specialized semantics, or you want to annotate multiple
types of tainting in a single program, then you can copy the definition of
the Tainting Checker to create a new annotation and checker with a more
specific name and semantics. See Chapter&#XA0;<A HREF="#writing-a-checker">22</A> for more
details.</P><HR><!--TOC chapter Linear checker for preventing aliasing-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="linear-checker">Chapter&#XA0;10</A>&#XA0;&#XA0;Linear checker for preventing aliasing</H1><!--SEC END --><P>The Linear Checker implements type-checking for a linear type system. A
linear type system prevents aliasing: there is only one (usable) reference
to a given object at any time. Once a reference appears on the right-hand
side of an assignment, it may not be used any more. The same rule applies
for pseudo-assignments such as procedure argument-passing (including as the
receiver) or return.</P><P>One way of thinking about this is that a reference can only be used once,
after which it is &#X201C;used up&#X201D;. This property is checked statically at
compile time. The single-use property only applies to use in an
assignment, which makes a new reference to the object; ordinary field
dereferencing does not use up a reference.</P><P>By forbidding aliasing, a linear type system can prevent problems such as
unexpected modification (by an alias), or ineffectual modification (after a
reference has already been passed to, and used by, other code).</P><P>To run the Linear Checker, supply the <TT>-processor
checkers.Linear.LinearChecker</TT> command-line option to javac.</P><P>Figure&#XA0;<A HREF="#fig:linear-example">10.1</A> gives an example of the Linear Checker&#X2019;s rules.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<PRE CLASS="verbatim">class Pair {
  Object a;
  Object b;
  public String toString() {
    return "&lt;" + String.valueOf(a) + "," + String.valueOf(b) + "&gt;";
  }
}

void print(@Linear Object arg) {
  System.out.println(arg);
}

@Linear Pair printAndReturn(@Linear Pair arg) {
  System.out.println(arg.a);
  System.out.println(arg.b);      // OK: field dereferencing does not use up the reference arg
  return arg;
}

@Linear Object m(Object o, @Linear Pair lp) {
  @Linear Object lo2 = o;         // ERROR: aliases may exist
  @Linear Pair lp3 = lp;          
  @Linear Pair lp4 = lp;          // ERROR: reference lp was already used
  lp3.a;                            
  lp3.b;                          // OK: field dereferencing does not use up the reference
  print(lp3);
  print(lp3);                     // ERROR: reference lp3 was already used
  lp3.a;                          // ERROR: reference lp3 was already used
  @Linear Pair lp4 = new Pair(...);
  lp4.toString();
  lp4.toString();                 // ERROR: reference lp4 was already used
  lp4 = new Pair();               // OK to reassign to a used-up reference
  // If you need a value back after passing it to a procedure, that
  // procedure must return it to you.
  lp4 = printAndReturn(lp4);
  if (...) {
    print(lp4);
  }
  if (...) {
    return lp4;                   // ERROR: reference lp4 may have been used
  } else {
    return new Object();
  }
}
</PRE><DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 10.1: Example of Linear Checker rules.</TD></TR>
</TABLE></DIV>
<A NAME="fig:linear-example"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC section Linear annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="linear-annotations">10.1</A>&#XA0;&#XA0;Linear annotations</H2><!--SEC END --><P>The linear type system uses one user-visible annotation:
<TT>@</TT><A HREF="doc/checkers/linear/quals/Linear.html"><TT>Linear</TT></A>. The annotation indicates
a type for which each value may only have a single reference &#X2014;
equivalently, may only be used once on the right-hand side of an
assignment.</P><P>The full qualifier hierarchy for the linear type system includes three
types:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>@UsedUp</TT> is the type of references whose object has been assigned to
another reference. The reference may not be used in any way, including
having its fields dereferenced, being tested for equality with <TT>==</TT>, or
being assigned to another reference. Users never need to write this
qualifier.
</LI><LI CLASS="li-itemize"><TT>@Linear</TT> is the type of references that have no aliases, and that may
be dereferenced at most once in the future. The type of <TT>new </TT><TT><EM>T</EM></TT><TT>()</TT> is
<TT>@Linear </TT><TT><EM>T</EM></TT> (the analysis does not account for the slim
possibility that an alias to <TT>this</TT> escapes the constructor).
</LI><LI CLASS="li-itemize"><TT>@NonLinear</TT> is the type of references that may be dereferenced, and
aliases made, as many times as desired. This is the default, so users only
need to write <TT>@NonLinear</TT> if they change the default.
</LI></UL><P><TT>@UsedUp</TT> is a supertype of <TT>@NonLinear</TT>, which is a
supertype of <TT>@Linear</TT>.</P><P>This hierarchy makes an assignment like</P><PRE CLASS="verbatim">  @Linear Object l = new Object();
  @NonLinear Object nl = l;
  @NonLinear Object nl2 = nl;
</PRE><P>legal. In other words, the fact that an object is referenced by a
<TT>@Linear</TT> type means that there is only one usable reference to it <EM>now</EM>,
not that there will <EM>never</EM> be multiple usable references to it.
(The latter guarantee would be possible to enforce, but it is not what the
Linear Checker does.)</P><!--TOC section Limitations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="linear-limitations">10.2</A>&#XA0;&#XA0;Limitations</H2><!--SEC END --><P>The <TT>@Linear</TT> annotation is supported and checked only on method
parameters (including the receiver), return types, and local variables.
Supporting <TT>@Linear</TT> on fields would require a sophisticated alias
analysis or type system, and is future work.
</P><P>No annotated libraries are provided for linear types. Most libraries would
not be able to use linear types in their purest form. For example, you
cannot put a linearly-typed object in a hashtable, because hashtable
insertion calls <TT>hashCode</TT>; <TT>hashCode</TT> uses up the reference and does not
return the object, even though it does not retain any pointers to the
object. For similar reasons, a collection of linearly-typed objects could
not be sorted or searched.</P><P>Our lightweight implementation is intended for use in the parts of your
program where errors relating to aliasing and object reuse are most likely.
You can use manual reasoning (and possibly an unchecked cast or warning
suppression) when objects enter or exit those portions of your program, or
when that portion of your program uses an unannotated library.</P><HR><!--TOC chapter Regex checker for regular expression syntax-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="regex-checker">Chapter&#XA0;11</A>&#XA0;&#XA0;Regex checker for regular expression syntax</H1><!--SEC END --><P>The Regex Checker prevents, at compile-time, use of syntactically invalid
regular expressions and access of invalid capturing groups.</P><P>A regular expression, or regex, is a pattern for matching certain strings
of text. In Java, a programmer writes a regular expression as a string.
At run time, the string is &#X201C;compiled&#X201D; into an efficient internal form
(<A HREF="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html"><TT>Pattern</TT></A>) that is used for
text-matching. Regular expression in Java also have capturing groups, which
are delimited by parentheses and allow for extraction from text.</P><P>The syntax of regular expressions is complex, so it is easy to make a
mistake. It is also easy to accidentally use a regex feature from another
language that is not supported by Java (see section &#X201C;Comparison to Perl
5&#X201D; in the <A HREF="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html"><TT>Pattern</TT></A> Javadoc).
Ordinarily, the programmer does not learn of these errors until run time.
The Regex checker warns about these problems at compile time.</P><P>To run the Regex Checker, supply the <TT>-processor
checkers.regex.RegexChecker</TT> command-line option to javac.</P><!--TOC section Regex annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="regex-annotations">11.1</A>&#XA0;&#XA0;Regex annotations</H2><!--SEC END --><P>These qualifiers make up the Regex type system:</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/regex/quals/Regex.html"><B><TT>Regex</TT></B></A></DT><DD CLASS="dd-description">
indicates valid regular expression <TT>String</TT>s. This qualifier takes
an optional parameter of at the least the number of capturing groups in
the regular expression. If not provided, the parameter defaults to 0.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/regex/quals/PolyRegex.html"><B><TT>PolyRegex</TT></B></A></DT><DD CLASS="dd-description">
indicates qualifier polymorphism. For a description of
<TT>@</TT><A HREF="doc/checkers/regex/quals/PolyRegex.html"><TT>PolyRegex</TT></A>,
see Section&#XA0;<A HREF="#qualifier-polymorphism">18.2</A>.</DD></DL><P>A subtyping hierarchy of the Regex checker&#X2019;s qualifiers is shown in
Figure&#XA0;<A HREF="#fig:regex-hierarchy">11.1</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<DIV CLASS="center">
<IMG SRC="regex.png" ALT="regex.png"></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 11.1: The subtyping relationship of the Regex checkers&#X2019;s qualifiers.
Because the parameter to a <TT>@Regex</TT> qualifier is at least the number of
capturing groups in a regular expression, a <TT>@Regex</TT> qualifier with more
capturing groups is a subtype of a <TT>@Regex</TT> qualifier with fewer capturing
groups. The <TT>@Regex</TT> qualifier is shorthand for <TT>@Regex(0)</TT>. Qualifiers
in gray are provided for the benefit of the type
system and should never be used.</TD></TR>
</TABLE></DIV>
<A NAME="fig:regex-hierarchy"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC section Annotating your code with <TT>@Regex</TT>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="annotating-with-regex">11.2</A>&#XA0;&#XA0;Annotating your code with <TT>@Regex</TT></H2><!--SEC END --><!--TOC subsection Implicit qualifiers-->
<H3 CLASS="subsection"><A NAME="regex-implicit-qualifiers"><!--SEC ANCHOR -->11.2.1&#XA0;&#XA0;Implicit qualifiers</A></H3><!--SEC END --><P>As described in Section&#XA0;<A HREF="#effective-qualifier">19.1</A>, the Regex checker adds
implicit qualifiers, reducing the number of annotations that must appear
in your code. The checker implicitly adds the <TT>Regex</TT> qualifier with
the parameter set to the correct number of capturing groups to
any <TT>String</TT> literal that is a valid regex. The Regex checker allows
for the <TT>null</TT> literal to be assigned to any type qualified with the
<TT>Regex</TT> qualifier.</P><!--TOC subsection Capturing groups-->
<H3 CLASS="subsection"><A NAME="regex-capturing-groups"><!--SEC ANCHOR -->11.2.2&#XA0;&#XA0;Capturing groups</A></H3><!--SEC END --><P>The Regex checker validates that a legal capturing group number is passed
to <A HREF="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html"><TT>Matcher</TT></A>&#X2019;s
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#group(int)"><TT>group</TT></A>,
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#start(int)"><TT>start</TT></A> and
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Matcher.html#end(int)"><TT>end</TT></A> methods. To do this,
the type of <TT>Matcher</TT> must be qualified with a <TT>@Regex</TT> annotation
with the number of capturing groups in the regular expression. This is
handled implicitly by the Regex checker for local variables (see
Section&#XA0;<A HREF="#type-refinement">19.1.2</A>), but you may need to add <TT>@Regex</TT> annotations
with a capturing group count to <TT>Pattern</TT> and <TT>Matcher</TT> fields and
parameters.</P><!--TOC subsection Testing whether a string is a regular expression-->
<H3 CLASS="subsection"><A NAME="regexutil-methods"><!--SEC ANCHOR -->11.2.3&#XA0;&#XA0;Testing whether a string is a regular expression</A></H3><!--SEC END --><P>Sometimes, the Regex Checker cannot infer whether a particular expression
is a regular expression &#X2014; and sometimes your code cannot either! In
these cases, you can use the <TT>isRegex</TT> method to perform such a test, and
other helper methods to provide useful error messages. A
common use is for user-provided regular expressions (such as ones passed
on the command-line).
Figure&#XA0;<A HREF="#fig:regex-util-example">11.2</A> gives an
example of the intended use of the <TT>RegexUtil</TT> methods.</P><DL CLASS="description"><DT CLASS="dt-description"><A HREF="doc/checkers/regex/RegexUtil.html#isRegex(java.lang.String)"><B><TT>RegexUtil.isRegex</TT></B></A></DT><DD CLASS="dd-description">
returns <TT>true</TT> if its argument is a valid regular expression.</DD><DT CLASS="dt-description"><A HREF="doc/checkers/regex/RegexUtil.html#regexError(java.lang.String)"><B><TT>RegexUtil.regexError</TT></B></A></DT><DD CLASS="dd-description">
returns a <TT>String</TT> error message if its argument is not a valid regular
expression, or <TT>null</TT> if its argument is a valid regular expression.</DD><DT CLASS="dt-description"><A HREF="doc/checkers/regex/RegexUtil.html#regexException(java.lang.String)"><B><TT>RegexUtil.regexException</TT></B></A></DT><DD CLASS="dd-description">
returns the
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/util/regex/PatternSyntaxException.html"><TT>PatternSyntaxException</TT></A>
that <A HREF="http://docs.oracle.com/javase/7/docs/api/java/util/regex/Pattern.html#compile(java.lang.String)"><TT>Pattern.compile(String)</TT></A>
throws when compiling an invalid regular expression. It returns <TT>null</TT>
if its argument is a valid regular expression.</DD></DL><P>An additional version of each of these methods is also provided that takes
an additional group count parameter. The
<A HREF="doc/checkers/regex/RegexUtil.html#isRegex(java.lang.String, int)"><TT>RegexUtil.isRegex</TT></A> method
verifies that the argument has at least the given number of groups. The
<A HREF="doc/checkers/regex/RegexUtil.html#regexError(java.lang.String, int)"><TT>RegexUtil.regexError</TT></A> and
<A HREF="doc/checkers/regex/RegexUtil.html#regexException(java.lang.String, int)"><TT>RegexUtil.regexException</TT></A>
methods return a <TT>String</TT> error message and <TT>PatternSyntaxException</TT>,
respectively, detailing why the given String is not a syntactically valid
regular expression with at least the given number of capturing groups.</P><P>A potential disadvantage of using these methods is that your code becomes
dependent on the Checker Framework at run time as well as at compile time.
You can avoid this by copying the implementation of these methods into
your own code.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<PRE CLASS="verbatim">String regex = getRegexFromUser();
if (! RegexUtil.isRegex(regex)) {
   throw new RuntimeException("Error parsing regex " + regex, RegexUtil.regexException(regex));
   // or: System.out.println("Error parsing regex \"" + regex + "\": " + RegexUtil.regexError(regex));
}
// The following line suppresses a Regex Checker warning and is only necessary until the 
// Regex Checker supports flow-sensitivity, after which time it can be removed from the code.
regex = RegexUtil.asRegex(regex);   // @SuppressWarnings("regex") // flow-sensitivity
Pattern p = Pattern.compile(regex);
</PRE><DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 11.2: Example use of <TT>RegexUtil</TT> methods.</TD></TR>
</TABLE></DIV>
<A NAME="fig:regex-util-example"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection Suppressing warnings-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->11.2.4&#XA0;&#XA0;Suppressing warnings</H3><!--SEC END --><P>If you are positive that a particular string that is being used as a
regular expression is syntactically valid, but the Regex Checker cannot
conclude this and issues a warning about possible use of an invalid regular
expression, then you can use the
<A HREF="doc/checkers/regex/RegexUtil.html#asRegex(java.lang.String)"><TT>RegexUtil.asRegex</TT></A> method to suppress the
warning.</P><P>You can think of this method 
is a cast: it returns its argument unchanged, but with the type
<TT>@Regex String</TT> if it is a valid regular expression. It throws an
Error if its argument is not a valid regular expression, but you should
only use it when you are sure it will not throw an error.</P><P>There is an additional <A HREF="doc/checkers/regex/RegexUtil.html#asRegex(java.lang.String, int)"><TT>RegexUtil.asRegex</TT></A>
method that takes a capturing group parameter. This method works the same as
described above, but returns a <TT>@Regex String</TT> with the parameter on the
annotation set to the value of the capturing group parameter passed to the method.</P><P>This method is
mainly a workaround until the Regex Checker supports flow-sensitivity (see
Section&#XA0;<A HREF="#type-refinement">19.1.2</A>) and should be used rarely once the Regex
Checker supports flow-sensitivity.</P><HR><!--TOC chapter Property file checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="propkey-checker">Chapter&#XA0;12</A>&#XA0;&#XA0;Property file checker</H1><!--SEC END --><P>The property file checker ensures that a property file or resource bundle (both
of which act like maps from keys to values) is only accessed with valid keys.
Accesses without a valid key either return <TT>null</TT> or a default value, which
can lead to a <TT>NullPointerException</TT> or hard-to-trace behavior.
The property file checker (Section <A HREF="#genpropkey-checker">12.1</A>) ensures
that the used keys are found in the corresponding property file or resource
bundle.</P><P>We also provide two specialized checkers.
An internationalization checker (Section <A HREF="#i18n-checker">12.2</A>)
verifies that code is properly internationalized.
A compiler message key checker (Section <A HREF="#compilermsgs-checker">12.3</A>)
verifies that compiler message keys used in the Checker Framework are
declared in a property file;
This is an example of a simple specialization of the property
file checker, and the Checker Framework source code shows how it is used.</P><P>It is easy to customize the property key checker for other related purposes.
Take a look at the source code of the compiler message key checker and adapt it for
your purposes.</P><!--TOC section Generic property file checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="genpropkey-checker">12.1</A>&#XA0;&#XA0;Generic property file checker</H2><!--SEC END --><P>The generic property file checker ensures that a resource key is located
in a specified property file or resource bundle.</P><P>The annotation <TT>@</TT><A HREF="doc/checkers/propkey/quals/PropertyKey.html"><TT>PropertyKey</TT></A>
indicates that the qualified <TT>String</TT> is a valid key
found in the property file or resource bundle.
You do not need to annotate <TT>String</TT> literals.
The checker looks up every <TT>String</TT> literal in the specified
property file or resource bundle, and adds annotations as appropriate.</P><P>If you pass a <TT>String</TT> variable to be eventually used as a key, you
also need to annotate all these variables with <TT>@PropertyKey</TT>.</P><P>The checker can be invoked by running the following
command:</P><PRE CLASS="verbatim">  javac -processor checkers.propkey.PropertyKeyChecker
        -Abundlenames=MyResource MyFile.java ...
</PRE><P>You must specify the resources, which map keys to strings.
The checker supports two types of resource:
resource bundles and property files. You can specify one or both of the
following two command-line options:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>-Abundlenames=</TT><TT><EM>resource_name</EM></TT><P><EM>resource_name</EM> is the name of the resource to be used with
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/util/ResourceBundle.html#getBundle(java.lang.String, java.util.Locale, java.lang.ClassLoader)"><TT>ResourceBundle.getBundle()</TT></A>.
The checker uses the default <TT>Locale</TT> and <TT>ClassLoader</TT> in the
compilation system.
(For a tutorial about <TT>ResourceBundle</TT>s, see
<A HREF="http://java.sun.com/developer/technicalArticles/Intl/ResourceBundles/"><TT>http://java.sun.com/developer/technicalArticles/Intl/ResourceBundles/</TT></A>.)
Multiple resource bundle names are separated by colons &#X2019;<TT>:</TT>&#X2019;.</P></LI><LI CLASS="li-enumerate"><TT>-Apropfiles=</TT><TT><EM>prop_file</EM></TT><P><EM>prop_file</EM> is the name of a properties file that maps
keys to values. The file format is described in
the Javadoc for 
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/util/Properties.html#load(java.io.Reader)"><TT>Properties.load()</TT></A>.
Multiple files are separated by colons &#X2019;<TT>:</TT>&#X2019;.</P></LI></OL><!--TOC section Internationalization checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="i18n-checker">12.2</A>&#XA0;&#XA0;Internationalization checker</H2><!--SEC END --><P>The Internationalization Checker verifies that your code is properly
internationalized. Internationalization is the process of adapting
software to different languages and locales. Internationalization is
sometimes called localization (though the terms are not
identical), and is sometimes called i18n (because the word starts with &#X201C;i&#X201D;,
ends with &#X201C;n&#X201D;, and has 18 characters in between; localization is similarly
sometimes abbreviated as l10n).</P><P>The checker focuses on one aspect of internationalization: user-visible strings
should be presented in the user&#X2019;s own language, such as English, French, or
German. This is achieved by looking up keys in a localization resource,
which maps keys to user-visible strings. For instance, one version of a
resource might map <TT>"CANCEL_STRING"</TT> to
<TT>"Cancel"</TT>, and another version of the same resource might map
<TT>"CANCEL_STRING"</TT> to <TT>"Abbrechen"</TT>.</P><P>There are other aspects to localization, such as formatting of dates (3/5
vs.&#XA0;5/3 for March 5), that the checker does not check.</P><P>The Internationalization Checker verifies these two properties:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Any user-visible text should be obtained from a localization resource.
For example, <TT>String</TT> literals should not be output to the user.</LI><LI CLASS="li-enumerate">When looking up keys in a localization resource, the key should exist in
that resource. This check catches incorrect or misspelled localization
keys.</LI></OL><!--TOC subsection Internationalization annotations-->
<H3 CLASS="subsection"><A NAME="i18n-annotations"><!--SEC ANCHOR -->12.2.1&#XA0;&#XA0;Internationalization annotations</A></H3><!--SEC END --><P>The Internationalization Checker supports two annotations:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>@</TT><A HREF="doc/checkers/i18n/quals/Localized.html"><TT>Localized</TT></A>: indicates that the qualified
<TT>String</TT> is a message that has been localized and/or formatted with
respect to the used locale.</LI><LI CLASS="li-enumerate"><TT>@</TT><A HREF="doc/checkers/i18n/quals/LocalizableKey.html"><TT>LocalizableKey</TT></A>: indicates that the
qualified <TT>String</TT> or <TT>Object</TT> is a valid key found in the
localization resource.
This annotation is a specialization of the <TT>@PropertyKey</TT> annotation, that
gets checked by the generic property key checker.
</LI></OL><P>You may need to add the <TT>@Localized</TT> annotation to more methods in the
JDK or other libraries, or in your own code.</P><!--TOC subsection Running the Internationalization Checker-->
<H3 CLASS="subsection"><A NAME="i18n-running"><!--SEC ANCHOR -->12.2.2&#XA0;&#XA0;Running the Internationalization Checker</A></H3><!--SEC END --><P>The Internationalization Checker can be invoked by running the following
command:</P><PRE CLASS="verbatim">  javac -processor checkers.i18n.I18nChecker -Abundlenames=MyResource MyFile.java ...
</PRE><P>You must specify the localization resource, which maps keys to user-visible
strings. Like the generic property key checker, the internationalization checker
supports two types of localization resource:
<TT>ResourceBundle</TT>s using the 
<TT>-Abundlenames=</TT><TT><EM>resource_name</EM></TT> option
or property files using the
<TT>-Apropfiles=</TT><TT><EM>prop_file</EM></TT> option.</P><!--TOC section Compiler Message Key checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="compilermsgs-checker">12.3</A>&#XA0;&#XA0;Compiler Message Key checker</H2><!--SEC END --><P>The Checker Framework uses compiler message keys to output error messages.
These keys are substituted by localized strings for user-visible error messages.
Using keys instead of the localized strings in the source code enables easier
testing, as the expected error keys can stay unchanged while the localized
strings can still be modified. 
We use the compiler message key checker to ensure that all internal
keys are correctly localized.
Instead of using the property file checker, we use a specialized checker,
giving us more precise documentation of the intended use of <TT>String</TT>s.</P><P>The single annotation used by this checker is 
<TT>@</TT><A HREF="doc/checkers/compilermsgs/quals/CompilerMessageKey.html"><TT>CompilerMessageKey</TT></A>.
The Checker Framework is completely annotated;
for example, class <TT>checkers.source.Result</TT>
uses <TT>@CompilerMessageKey</TT> in methods <TT>failure</TT> and <TT>warning</TT>.
For most users of the Checker Framework there will be no need to annotate any
<TT>String</TT>s, as the checker looks up all <TT>String</TT> literals and adds
annotations as appropriate.</P><P>The compiler message key checker can be invoked by running the following
command:</P><PRE CLASS="verbatim">  javac -processor checkers.compilermsgs.CompilerMessagesChecker
        -Apropfiles=messages.properties MyFile.java ...
</PRE><P>You must specify the resource, which maps compiler message keys to user-visible
strings. The checker supports the same options as the generic property key checker.
Within the Checker Framework we only use property files,
so the <TT>-Apropfiles=</TT><TT><EM>prop_file</EM></TT> option should be used.</P><HR><!--TOC chapter Signature checker for string representations of types-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="signature-checker">Chapter&#XA0;13</A>&#XA0;&#XA0;Signature checker for string representations of types</H1><!--SEC END --><P>The Signature String Checker, or Signature Checker for short, verifies that
string representations of types and signatures are used correctly.</P><P>Java defines multiple different string representations, and it is easy to
misuse them or to miss bugs during testing. Using the wrong string format
leads to a run-time exception or an incorrect result. This is a particular
problem for fully qualified and binary names, which are nearly the same &#X2014;
they differ only for nested classes and arrays.</P><!--TOC section Signature annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="signature-annotations">13.1</A>&#XA0;&#XA0;Signature annotations</H2><!--SEC END --><P>Java defines three main formats for the string representation of a type.
There is an annotation for each of these representations, plus one more.
Figure&#XA0;<A HREF="#fig:signature-hierarchy">13.1</A> shows how they are related.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>

<DIV CLASS="center">
<IMG SRC="signature-types.png" ALT="signature-types.png"></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 13.1: Partial type hierarchy for the Signature type system, showing
string representations of a Java type. Programmers only need to write
the boldfaced qualifiers, in the second row; qualifiers below those are
included to improve the internal handling of String literals.</TD></TR>
</TABLE></DIV>
<A NAME="fig:signature-hierarchy"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/signature/quals/FullyQualifiedName.html"><B><TT>FullyQualifiedName</TT></B></A></DT><DD CLASS="dd-description">
A <EM>fully qualified name</EM> (<A HREF="http://java.sun.com/docs/books/jls/third_edition/html/names.html#6.7">JLS &#XA7;6.7</A> and <A HREF="http://java.sun.com/docs/books/jvms/second_edition/html/Concepts.doc.html#20207">JVMS &#XA7;2.7.5</A>), such as
<TT>package.Outer.Inner</TT>, is used in Java code and in messages to
the user.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/signature/quals/BinaryName.html"><B><TT>BinaryName</TT></B></A></DT><DD CLASS="dd-description">
A <EM>binary name</EM> (<A HREF="http://java.sun.com/docs/books/jls/third_edition/html/binaryComp.html#13.1">JLS &#XA7;13.1</A>), such as
<TT>package.Outer$Inner</TT>, is
the representation of a type in its own <TT>.class</TT> file.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/signature/quals/FieldDescriptor.html"><B><TT>FieldDescriptor</TT></B></A></DT><DD CLASS="dd-description">
A <EM>field descriptor</EM> (<A HREF="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#14152">JVMS &#XA7;4.3.2</A>), such as
<TT>Lpackage/Outer$Inner;</TT>, is used in a <TT>.class</TT> file&#X2019;s constant pool,
for example to refer to other types; it abbreviates primitives and
arrays, and uses internal form (<A HREF="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#14757">JVMS &#XA7;4.2</A>) for class names.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/signature/quals/ClassGetName.html"><B><TT>ClassGetName</TT></B></A></DT><DD CLASS="dd-description">
The type representation used by the
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#getName()"><TT>Class.getName()</TT></A>, <TT>Class.forName(String)</TT>,
and <TT>Class.forName(String, boolean, ClassLoader)</TT> methods. This format
is: for any non-array type, the binary name; and for any array type, a
format like the @link FieldDescriptor field descriptor, but using
&#X201C;<TT>.</TT>&#X201D;&#XA0;where the field descriptor uses &#X201C;<TT>/</TT>&#X201D;.</DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/signature/quals/SourceName.html"><B><TT>SourceName</TT></B></A></DT><DD CLASS="dd-description">
A source name is a string that is a valid fully qualified name <EM>and</EM>
a valid binary name. A programmer should never or rarely use this &#X2014; you should
know how you intend to use a given variable. The checker infers it for
literal strings such as <TT>"package.MyClass"</TT> that are valid in both
formats, and you might occasionally see it in an error message.
Likewise, you might see other types such as <TT>SourceNameForNonArray</TT>,
<TT>BinaryNameForNonArray</TT>, and <TT>FieldDescriptorForArray</TT>, but you
generally should not use them either.</DD></DL><P>Java also defines other string formats for a type: simple
names (JLS &#XA7;6.2), qualified names (JLS &#XA7;6.2), and canonical
names (JLS &#XA7;6.7). The Signature Checker does not include annotations
for these.</P><P>Here are examples of the supported formats:</P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>fully-qualified name</TD><TD ALIGN=center NOWRAP>binary name</TD><TD ALIGN=center NOWRAP>Class.getName</TD><TD ALIGN=center NOWRAP>field descriptor</TD></TR>
<TR><TD ALIGN=left NOWRAP>int</TD><TD ALIGN=left NOWRAP>int</TD><TD ALIGN=left NOWRAP>int</TD><TD ALIGN=left NOWRAP>I</TD></TR>
<TR><TD ALIGN=left NOWRAP>int[][]</TD><TD ALIGN=left NOWRAP>int[][]</TD><TD ALIGN=left NOWRAP>[[I</TD><TD ALIGN=left NOWRAP>[[I</TD></TR>
<TR><TD ALIGN=left NOWRAP>MyClass</TD><TD ALIGN=left NOWRAP>MyClass</TD><TD ALIGN=left NOWRAP>MyClass</TD><TD ALIGN=left NOWRAP>LMyClass;</TD></TR>
<TR><TD ALIGN=left NOWRAP>MyClass[]</TD><TD ALIGN=left NOWRAP>MyClass[]</TD><TD ALIGN=left NOWRAP>[LMyClass;</TD><TD ALIGN=left NOWRAP>[LMyClass;</TD></TR>
<TR><TD ALIGN=left NOWRAP>java.lang.Integer</TD><TD ALIGN=left NOWRAP>java.lang.Integer</TD><TD ALIGN=left NOWRAP>java.lang.Integer</TD><TD ALIGN=left NOWRAP>Ljava/lang/Integer;</TD></TR>
<TR><TD ALIGN=left NOWRAP>java.lang.Integer[]</TD><TD ALIGN=left NOWRAP>java.lang.Integer[]</TD><TD ALIGN=left NOWRAP>[Ljava.lang.Integer;</TD><TD ALIGN=left NOWRAP>[Ljava/lang/Integer;</TD></TR>
<TR><TD ALIGN=left NOWRAP>package.Outer.Inner</TD><TD ALIGN=left NOWRAP>package.Outer$Inner</TD><TD ALIGN=left NOWRAP>package.Outer$Inner</TD><TD ALIGN=left NOWRAP>Lpackage/Outer$Inner;</TD></TR>
<TR><TD ALIGN=left NOWRAP>package.Outer.Inner[]</TD><TD ALIGN=left NOWRAP>package.Outer$Inner[]</TD><TD ALIGN=left NOWRAP>[Lpackage.Outer$Inner;</TD><TD ALIGN=left NOWRAP>[Lpackage/Outer$Inner;</TD></TR>
</TABLE>
</DIV><P>Java defines one format for the string representation of a method signature:</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/signature/quals/MethodDescriptor.html"><B><TT>MethodDescriptor</TT></B></A></DT><DD CLASS="dd-description">
A <EM>method descriptor</EM> (<A HREF="http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#7035">JVMS &#XA7;4.3.3</A>) identifies a method&#X2019;s signature (its parameter and return
types), just as a field descriptor identifies a 
type. The method descriptor for the method
<PRE CLASS="verbatim">    Object mymethod(int i, double d, Thread t)
</PRE>is
<PRE CLASS="verbatim">    (IDLjava/lang/Thread;)Ljava/lang/Object;
</PRE></DD></DL><!--TOC section What the Signature Checker checks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="signature-checks">13.2</A>&#XA0;&#XA0;What the Signature Checker checks</H2><!--SEC END --><P>Certain methods in the JDK, such as <TT>Class.forName</TT>, are annotated
indicating the type they require. The Signature Checker ensures that
clients call them with the proper arguments. The Signature Checker does
not reason about string operations such as concatenation, substring,
parsing, etc.</P><P>To run the Signature Checker, supply the <TT>-processor
checkers.signature.SignatureChecker</TT> command-line option to javac.</P><HR><!--TOC chapter Units checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="units-checker">Chapter&#XA0;14</A>&#XA0;&#XA0;Units checker</H1><!--SEC END --><P>For many applications, it is important to use the correct units of
measurement for primitive types. For example, NASA&#X2019;s Mars Climate Orbiter
(cost: $327 million) was lost because of a discrepancy between use
of the metric unit Newtons and the imperial measure Pound-force.</P><P>The <EM>Units Checker</EM> ensures consistent usage of units.
For example, consider the following code:</P><PRE>
@m int meters = 5 * UnitsTools.m;
@s int secs = 2 * UnitsTools.s;
@mPERs int speed = meters / secs;
</PRE><P>Due to the annotations <TT>@m</TT> and <TT>@s</TT>, the variables <TT>meters</TT> and <TT>secs</TT> are guaranteed to contain
only values with meters and seconds as units of measurement.
Utility class <TT>UnitsTools</TT> provides constants with which
unqualified integer are multiplied to get values of the corresponding unit.
The assignment of an unqualified value to <TT>meters</TT>, as in
<TT>meters = 99</TT>, will be flagged as an error by the Units Checker.</P><P>The division <TT>meters/secs</TT> takes the types of the two operands
into account and determines that the result is of type
meters per second, signified by the <TT>@mPERs</TT> qualifier.
We provide an extensible framework to define the result of operations
on units.</P><!--TOC section Units annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="units-annotations">14.1</A>&#XA0;&#XA0;Units annotations</H2><!--SEC END --><P>The checker currently supports two varieties of units annotations:
kind annotations (<TT>@Length</TT>, <TT>@Mass</TT>, &#X2026;) and
the SI units (<TT>@m</TT>, <TT>@kg</TT>, &#X2026;).</P><P>Kind annotations can be used to declare what the expected unit of
measurement is, without fixing the particular unit used.
For example, one could write a method taking a <TT>@Length</TT> value,
without specifying whether it will take meters or kilometers.
The following kind annotations are defined:</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>@</TT></B><A HREF="doc/checkers/units/quals/Area.html"><B><TT>Area</TT></B></A></DT><DD CLASS="dd-description"></DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/units/quals/Current.html"><B><TT>Current</TT></B></A></DT><DD CLASS="dd-description"></DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/units/quals/Length.html"><B><TT>Length</TT></B></A></DT><DD CLASS="dd-description"></DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/units/quals/Luminance.html"><B><TT>Luminance</TT></B></A></DT><DD CLASS="dd-description"></DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/units/quals/Mass.html"><B><TT>Mass</TT></B></A></DT><DD CLASS="dd-description"></DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/units/quals/Speed.html"><B><TT>Speed</TT></B></A></DT><DD CLASS="dd-description"></DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/units/quals/Substance.html"><B><TT>Substance</TT></B></A></DT><DD CLASS="dd-description"></DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/units/quals/Temperature.html"><B><TT>Temperature</TT></B></A></DT><DD CLASS="dd-description"></DD><DT CLASS="dt-description"><B><TT>@</TT></B><A HREF="doc/checkers/units/quals/Time.html"><B><TT>Time</TT></B></A></DT><DD CLASS="dd-description">
</DD></DL><P>For each kind of unit, the corresponding SI unit of
measurement is defined:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
For <TT>@Area</TT>:
the derived units
square millimeters <TT>@</TT><A HREF="doc/checkers/units/quals/mm2.html"><TT>mm2</TT></A>,
square meters <TT>@</TT><A HREF="doc/checkers/units/quals/m2.html"><TT>m2</TT></A>, and
square kilometers <TT>@</TT><A HREF="doc/checkers/units/quals/km2.html"><TT>km2</TT></A></LI><LI CLASS="li-enumerate">For <TT>@Current</TT>:
Ampere <TT>@</TT><A HREF="doc/checkers/units/quals/A.html"><TT>A</TT></A></LI><LI CLASS="li-enumerate">For <TT>@Length</TT>:
Meters <TT>@</TT><A HREF="doc/checkers/units/quals/m.html"><TT>m</TT></A>
and the derived units
millimeters <TT>@</TT><A HREF="doc/checkers/units/quals/mm.html"><TT>mm</TT></A> and
kilometers <TT>@</TT><A HREF="doc/checkers/units/quals/km.html"><TT>km</TT></A></LI><LI CLASS="li-enumerate">For <TT>@Luminance</TT>:
Candela <TT>@</TT><A HREF="doc/checkers/units/quals/cd.html"><TT>cd</TT></A></LI><LI CLASS="li-enumerate">For <TT>@Mass</TT>:
kilograms <TT>@</TT><A HREF="doc/checkers/units/quals/kg.html"><TT>kg</TT></A>
and the derived unit
grams <TT>@</TT><A HREF="doc/checkers/units/quals/g.html"><TT>g</TT></A></LI><LI CLASS="li-enumerate">For <TT>@Speed</TT>:
meters per second <TT>@</TT><A HREF="doc/checkers/units/quals/mPERs.html"><TT>mPERs</TT></A> and
kilometers per hour <TT>@</TT><A HREF="doc/checkers/units/quals/kmPERh.html"><TT>kmPERh</TT></A></LI><LI CLASS="li-enumerate">For <TT>@Substance</TT>:
Mole <TT>@</TT><A HREF="doc/checkers/units/quals/mol.html"><TT>mol</TT></A></LI><LI CLASS="li-enumerate">For <TT>@Temperature</TT>:
Kelvin <TT>@</TT><A HREF="doc/checkers/units/quals/K.html"><TT>K</TT></A>
and the derived unit
Celsius <TT>@</TT><A HREF="doc/checkers/units/quals/C.html"><TT>C</TT></A></LI><LI CLASS="li-enumerate">For <TT>@Time</TT>:
seconds <TT>@</TT><A HREF="doc/checkers/units/quals/s.html"><TT>s</TT></A>
and the derived units
minutes <TT>@</TT><A HREF="doc/checkers/units/quals/min.html"><TT>min</TT></A> and
hours <TT>@</TT><A HREF="doc/checkers/units/quals/h.html"><TT>h</TT></A>
</LI></OL><P>You may specify SI unit prefixes, using enumeration <A HREF="doc/checkers/units/quals/Prefix.html"><TT>Prefix</TT></A>.
The basic SI units
(<TT>@s</TT>, <TT>@m</TT>, <TT>@g</TT>, <TT>@A</TT>, <TT>@K</TT>,
<TT>@mol</TT>, <TT>@cd</TT>)
take an optional <TT>Prefix</TT> enum as argument.
For example, to use nanoseconds as unit, you could use
<TT>@s(Prefix.nano)</TT> as a unit type. Furthermore, <TT>@mm</TT> is equivalent to
<TT>@m(Prefix.milli)</TT>.</P><P>Class <TT>UnitsTools</TT> contains a constant for each SI unit.
To create a value of the particular unit, multiply an unqualified
value with one of these constants.
By using static imports, this allows very natural notation; for
example, after statically importing <TT>UnitsTools.m</TT>,
the expression <TT>5 * m</TT> represents five meters.
As all these unit constants are public, static, and final with value
one, the compiler will optimize away these multiplications.</P><!--TOC section Extending the Units Checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="extending-units">14.2</A>&#XA0;&#XA0;Extending the Units Checker</H2><!--SEC END --><P>You can create new kind annotations and unit annotations that are specific
to the particular needs of your project. An easy way to do this is by
copying and adapting an existing annotation. (In addition, search for all
uses of the annotation&#X2019;s name throughout the Units Checker implementation,
to find other code to adapt; read on for details.)</P><P>Here is an example of a new unit annotation.</P><PRE>
@Documented
@Retention(RetentionPolicy.RUNTIME)
@TypeQualifier
@SubtypeOf( <TT>{</TT> Time.class <TT>}</TT> )
@UnitsMultiple(quantity=s.class, prefix=Prefix.nano)
public @interface ns <TT>{</TT><TT>}</TT>
</PRE><P>The <TT>@SubtypeOf</TT> meta-annotation specifies that this annotation
introduces an additional unit of time.
The <TT>@UnitsMultiple</TT> meta-annotation specifies that this annotation
should be a nano multiple of the basic unit <TT>@s</TT>: <TT>@ns</TT> and
<TT>@s(Prefix.nano)</TT>
behave equivalently and interchangeably.
Most annotation definitions do not have a <TT>@UnitsMultiple</TT> meta-annotation.</P><P>To take full advantage of the additional unit qualifier, you need to
do two additional steps.
(1)&#XA0;Provide constants that convert from unqualified types to types that use
the new unit. 
See class <TT>UnitsTools</TT> for examples (you will need to suppress a
checker warning in just those few locations).
(2)&#XA0;Put the new unit in relation to existing units.
Provide an
implementation of the <TT>UnitsRelations</TT> interface as a
meta-annotation to one of the units.</P><P>See demonstration <TT>demos/units-extension/</TT> for an example
extension that defines Hertz (hz) as scalar per second, and defines an
implementation of <TT>UnitsRelations</TT> to enforce it.</P><!--TOC section What the Units Checker checks-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="units-checks">14.3</A>&#XA0;&#XA0;What the Units Checker checks</H2><!--SEC END --><P>The Units Checker ensures that unrelated types are not mixed. </P><P>All types with a particular unit annotation are
disjoint from all unannotated types, from all types with a different unit
annotation, and from all types with the same unit annotation but a
different prefix.</P><P>Subtyping between the units and the unit kinds is taken into account,
as is the <TT>@UnitsMultiple</TT> meta-annotation.</P><P>Multiplying a scalar with a unit type results in the same unit type.</P><P>The division of a unit type by the same unit type
results in the unqualified type.</P><P>Multiplying or dividing different unit types, for which no unit
relation is known to the system, will result in a <TT>MixedUnits</TT>
type, which is separate from all other units.
If you encounter a <TT>MixedUnits</TT> annotation in an error message,
ensure that your operations are performed on correct units or refine
your <TT>UnitsRelations</TT> implementation.</P><!--TOC section Running the Units Checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="units-running">14.4</A>&#XA0;&#XA0;Running the Units Checker</H2><!--SEC END --><P>The Units Checker can be invoked by running the following commands.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
If your code uses only the SI units that are provided by the
framework, simply invoke the checker:<PRE CLASS="verbatim">  javac -processor checkers.units.UnitsChecker MyFile.java ...
</PRE></LI><LI CLASS="li-itemize">If you define your own units, provide the name of the annotations using the
<TT>-Aunits</TT> option:<PRE>
  javac -processor checkers.units.UnitsChecker 
        <I>-Aunits=myproject.quals.MyUnit,myproject.quals.MyOtherUnit</I> MyFile.java ...
</PRE></LI></UL><!--TOC section Suppressing warnings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="units-suppressing">14.5</A>&#XA0;&#XA0;Suppressing warnings</H2><!--SEC END --><P>One example of when you need to suppress warnings is when you
initialize a variable with a unit type by a literal value.
To remove this warning message, it is best to introduce a
constant that represents the unit and to
add a <TT>@SuppressWarnings</TT>
annotation to that constant.
For examples, see class <TT>UnitsTools</TT>.</P><!--TOC section References-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="units-references">14.6</A>&#XA0;&#XA0;References</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
The GNU Units tool provides a comprehensive list of units:<BR>
 <A HREF="http://www.gnu.org/software/units/"><TT>http://www.gnu.org/software/units/</TT></A></LI><LI CLASS="li-itemize">The F# units of measurement system inspired some of our syntax:<BR>
 <A HREF="http://en.wikibooks.org/wiki/F_Sharp_Programming/Units_of_Measure"><TT>http://en.wikibooks.org/wiki/F_Sharp_Programming/Units_of_Measure</TT></A></LI></UL><HR><!--TOC chapter Basic checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="basic-checker">Chapter&#XA0;15</A>&#XA0;&#XA0;Basic checker</H1><!--SEC END --><P>The Basic checker enforces only subtyping rules. It operates over
annotations specified by a user on the command line. Thus, users can
create a simple type checker without writing any code beyond definitions of
the type qualifier annotations.</P><P>The Basic checker can accommodate all of the type system enhancements that
can be declaratively specified (see Chapter&#XA0;<A HREF="#writing-a-checker">22</A>).
This includes type introduction rules (implicit
annotations, e.g., literals are implicitly considered <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>) via
the <TT>@</TT><A HREF="doc/checkers/quals/ImplicitFor.html"><TT>ImplicitFor</TT></A> meta-annotation, and other features such as
flow-sensitive type qualifier inference (Section&#XA0;<A HREF="#type-refinement">19.1.2</A>) and
qualifier polymorphism (Section&#XA0;<A HREF="#qualifier-polymorphism">18.2</A>).</P><P>The Basic checker is also useful to type system designers who wish to
experiment with a checker before writing code; the Basic checker
demonstrates the functionality that a checker inherits from the Checker
Framework.</P><P>If you need typestate analysis, then you can extend a typestate checker,
much as you would extend the Basic Checker if you do not need typestate
analysis. For more details (including a definition of &#X201C;typestate&#X201D;), see
Chapter&#XA0;<A HREF="#typestate-checker">16</A>.</P><P>For type systems that require special checks (e.g., warning about
dereferences of possibly-null values), you will need to write code and
extend the framework as discussed in Chapter&#XA0;<A HREF="#writing-a-checker">22</A>.</P><!--TOC section Using the Basic checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="basic-using">15.1</A>&#XA0;&#XA0;Using the Basic checker</H2><!--SEC END --><P>The Basic checker is used in the same way as other checkers (using the
<TT>-processor checkers.basic.BasicChecker</TT> option; see Chapter&#XA0;<A HREF="#using-a-checker">2</A>), except that it
requires an additional annotation processor argument via the standard
&#X201C;<TT>-A</TT>&#X201D; switch:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>-Aquals</TT>: this option specifies a comma-no-space-separated list of
the fully-qualified class
names of the annotations used as qualifiers in the custom type system. For
example,<PRE>
  javac -processor checkers.fenum.BasicChecker
        <I>-Aquals=myproject.quals.MyQual,myproject.quals.OtherQual</I> MyFile.java ...
</PRE><P>It serves the same purpose as the <TT>@</TT><A HREF="doc/checkers/quals/TypeQualifiers.html"><TT>TypeQualifiers</TT></A>
annotation used by other checkers (see section
<A HREF="#writing-compiler-interface">22.6</A>).</P><P>The annotations listed in <TT>-Aquals</TT> must be accessible to
the compiler during compilation in the classpath. In other words, they must
already be compiled before you run the Basic checker with <TT>javac</TT>; it
is not sufficient to supply their source files on the command line.</P></LI></UL><P>To suppress a warning issued by the basic checker, use a 
<TT>@</TT><A HREF="http://docs.oracle.com/javase/7/docs/api/java/lang/SuppressWarnings.html"><TT>SuppressWarnings</TT></A>
annotation, with the argument being the unqualified, uncapitalized name of
any of the annotations passed to <TT>-Aquals</TT>. This will suppress all
warnings, regardless of which of the annotations is involved in the
warning. (As a matter of style, you should choose one of the annotations
as your <TT>@SuppressWarnings</TT> key and stick with it for that entire type
hierarchy.)</P><!--TOC section Basic checker example-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="encrypted-example">15.2</A>&#XA0;&#XA0;Basic checker example<A NAME="basic-example"></A></H2><!--SEC END --><P>Consider a hypothetical <TT>Encrypted</TT> type qualifier, which denotes that the
representation of an object (such as a <TT>String</TT>, <TT>CharSequence</TT>, or
<TT>byte[]</TT>) is encrypted. To use the Basic checker for the <TT>Encrypted</TT>
type system, follow three steps.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Define an annotation for the <TT>Encrypted</TT> qualifier:<PRE CLASS="verbatim">package myquals;

import checkers.quals.*;

/**
 * Denotes that the representation of an object is encrypted.
 * ...
 */
@TypeQualifier
@SubtypeOf(Unqualified.class)
@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
public @interface Encrypted {}
</PRE><P>Don&#X2019;t forget to compile this class:</P><PRE CLASS="verbatim">$ javac myquals/Encrypted.java
</PRE><P>The resulting <TT>.class</TT> file should either be on your classpath, or on the
processor path (set via the <TT>-processorpath</TT> command-line option to javac).</P></LI><LI CLASS="li-enumerate">Write <TT>@Encrypted</TT> annotations in your program (<TT>YourProgram.java</TT>):<PRE CLASS="verbatim">import myquals.Encrypted;

...

public @Encrypted String encrypt(String text) {
    // ...
}

// Only send encrypted data!
public void sendOverInternet(@Encrypted String msg) {
    // ...
}

void sendText() {
    // ...
    @Encrypted String ciphertext = encrypt(plaintext);
    sendOverInternet(ciphertext);
    // ...
}

void sendPassword() {
    String password = getUserPassword();
    sendOverInternet(password);
}
</PRE><P>You may also need to add <TT>@SuppressWarnings</TT> annotations to the
<TT>encrypt</TT> and <TT>decrypt</TT> methods. Analyzing them is beyond the
capability of any realistic type system.</P></LI><LI CLASS="li-enumerate">Invoke the compiler with the Basic checker, specifying the
<TT>@Encrypted</TT> annotation using the <TT>-Aquals</TT> option.
You should add the <TT>Encrypted</TT> classfile to the processor classpath:<PRE CLASS="verbatim">$ javac -processorpath myqualspath -processor checkers.basic.BasicChecker \
        -Aquals=myquals.Encrypted YourProgram.java

YourProgram.java:42: incompatible types.
found   : java.lang.String
required: @myquals.Encrypted java.lang.String
    sendOverInternet(password);
                     ^
</PRE></LI></OL><HR><!--TOC chapter Typestate checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="typestate-checker">Chapter&#XA0;16</A>&#XA0;&#XA0;Typestate checker</H1><!--SEC END --><P>In a regular type system, a variable has the same type throughout its
scope.
In a typestate system, a variable&#X2019;s type can change as operations
are performed on it.</P><P>The most common example of typestate is for a <TT>File</TT> object. Assume a file
can be in two states, <TT>@Open</TT> and <TT>@Closed</TT>. Calling the <TT>close()</TT> method
changes the file&#X2019;s state. Any subsequent attempt to read, write, or close
the file will lead to a run-time error. It would be better for the type
system to warn about such problems, or guarantee their absence, at compile
time.</P><P>Just as you can extend the Basic Checker to create a type checker, you can
extend a typestate checker to create a type checker that supports typestate
analysis. Two extensible typestate analyses that build on the Checker
Framework are available. One is by Adam Warski:
<A HREF="http://www.warski.org/typestate.html"><TT>http://www.warski.org/typestate.html</TT></A>.
The other is by Daniel Wand:
<A HREF="http://typestate.ewand.de/"><TT>http://typestate.ewand.de/</TT></A>.</P><!--TOC section Comparison to flow-sensitive type refinement-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="typestate-vs-type-refinement">16.1</A>&#XA0;&#XA0;Comparison to flow-sensitive type refinement</H2><!--SEC END --><P>The Checker Framework&#X2019;s flow-sensitive type refinement
(Section&#XA0;<A HREF="#type-refinement">19.1.2</A>) implements a form of typestate analysis.
For example, after code that tests a variable against null, the Nullness
Checker (Chapter&#XA0;<A HREF="#nullness-checker">3</A>) treats the variable&#X2019;s type as
<TT>@NonNull </TT><TT><EM>T</EM></TT>, for some <TT><EM>T</EM></TT>.</P><P>For many type systems, flow-sensitive type refinement is sufficient. But
sometimes, you need full typestate analysis. This section compares the
two. (Dependent types and unused variables
(Section&#XA0;<A HREF="#unused-fields-and-dependent-types">19.4</A>) also have similarities
with typestate analysis and can occasionally substitute for it. For
brevity, this discussion omits them.)</P><P>A typestate analysis is easier for a user to create or extend.
Flow-sensitive type refinement is built into the Checker Framework and is
optionally extended by each checker. Modifying the rules requires writing
Java code in your checker. By contrast, it is possible to write a simple
typestate checker declaratively, by writing annotations on the methods
(such as <TT>close()</TT>) that change a reference&#X2019;s typestate.</P><P>A typestate analysis can change a reference&#X2019;s type to something that is not
consistent with its original definition. For example, suppose that a
programmer decides that the <TT>@Open</TT> and <TT>@Closed</TT> qualifiers are
incomparable &#X2014; neither is a subtype of the other. A typestate analysis
can specify that the <TT>close()</TT> operation converts an <TT>@Open File</TT> into a
<TT>@Closed File</TT>. By contrast, flow-sensitive type refinement can only give
a new type that is a subtype of the declared type &#X2014; for flow-sensitive
type refinement to be effective, <TT>@Closed</TT> would need to be a child of
<TT>@Open</TT> in the qualifier hierarchy (and <TT>close()</TT> would need to be
treated specially by the checker).</P><HR><!--TOC chapter Third-party checkers-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="external-checkers">Chapter&#XA0;17</A>&#XA0;&#XA0;Third-party checkers<A NAME="third-party-checkers"></A></H1><!--SEC END --><P>The checker framework has been used to build other checkers that are not
distributed together with the framework. This chapter mentions just a few
of them.
If you want a reference to your checker included in this chapter,
send us a link and a short description.</P><!--TOC section Units and dimensions checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="units-and-dimensions-checker">17.1</A>&#XA0;&#XA0;Units and dimensions checker</H2><!--SEC END --><P>A checker for units and dimensions is available at
<A HREF="http://www.lexspoon.org/expannots/"><TT>http://www.lexspoon.org/expannots/</TT></A>.</P><P>Unlike the Units Checker that is distributed with the Checker Framework
(see Section&#XA0;<A HREF="#units-checker">14</A>), this checker includes dynamic checks and
permits annotation arguments that are Java expressions. This added
flexibility, however, requires that you use a special version both of the
Checker Framework and of the Type Annotations compiler.</P><!--TOC section Thread locality checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="loci-thread-locality-checker">17.2</A>&#XA0;&#XA0;Thread locality checker</H2><!--SEC END --><P>Loci, a checker for thread locality, is available at
<A HREF="http://www.it.uu.se/research/upmarc/loci/"><TT>http://www.it.uu.se/research/upmarc/loci/</TT></A>.
Developer resources are available at the project page
<A HREF="http://java.net/projects/loci/"><TT>http://java.net/projects/loci/</TT></A>.</P><!--TOC section Safety-Critical Java checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="safety-critical-java-checker">17.3</A>&#XA0;&#XA0;Safety-Critical Java checker</H2><!--SEC END --><P>A checker for Safety-Critical Java (SCJ, JSR 302) is available at
<A HREF="http://sss.cs.purdue.edu/projects/oscj/checker/checker.html"><TT>http://sss.cs.purdue.edu/projects/oscj/checker/checker.html</TT></A>.
Developer resources are available at the project page
<A HREF="http://code.google.com/p/scj-jsr302/"><TT>http://code.google.com/p/scj-jsr302/</TT></A>.</P><!--TOC section Generic Universe Types checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="gut-checker">17.4</A>&#XA0;&#XA0;Generic Universe Types checker</H2><!--SEC END --><P>A checker for Generic Universe Types, a lightweight ownership type
system, is available from
<A HREF="http://www.cs.washington.edu/homes/wmdietl/ownership/"><TT>http://www.cs.washington.edu/homes/wmdietl/ownership/</TT></A>.</P><!--TOC section EnerJ checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="enerj-checker">17.5</A>&#XA0;&#XA0;EnerJ checker</H2><!--SEC END --><P>A checker for EnerJ, an extension to Java that exposes hardware faults
in a safe, principled manner to save energy with only
slight sacrifices to the quality of service, is available from
<A HREF="http://sampa.cs.washington.edu/sampa/EnerJ"><TT>http://sampa.cs.washington.edu/sampa/EnerJ</TT></A>.</P><HR><!--TOC chapter Generics and polymorphism-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="polymorphism">Chapter&#XA0;18</A>&#XA0;&#XA0;Generics and polymorphism</H1><!--SEC END --><P>This chapter describes support for Java generics and for the analogous
capability over type qualifiers.</P><!--TOC section Generics (parametric polymorphism or type polymorphism)-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="generics">18.1</A>&#XA0;&#XA0;Generics (parametric polymorphism or type polymorphism)</H2><!--SEC END --><P>The Checker Framework fully supports
type-qualified Java generic types (also known in the research literature as &#X201C;parametric
polymorphism&#X201D;). Before running any checker, we recommend that you eliminate
raw types from your code (e.g., your code should use <TT>List&lt;...&gt;</TT> as
opposed to <TT>List</TT>).
Using generics helps prevent type errors just as using a pluggable
type-checker does.
</P><P>When instantiating a generic type,
clients supply the qualifier along with the type argument, as in
<TT>List&lt;@NonNull String&gt;</TT>.</P><!--TOC subsection Restricting instantiation of a generic class-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.1.1&#XA0;&#XA0;Restricting instantiation of a generic class</H3><!--SEC END --><P>When you define a generic class, the generic type parameters can restrict
how the class may be instantiated. For example, given the definition
<CODE>class G&lt;T extends Number&gt; {...}</CODE>,
a client can instantiate it as <TT>G&lt;Integer&gt;</TT> but not <TT>G&lt;Date&gt;</TT>.
Similarly, type qualifiers on the generic type parameters can restrict on
how the class may be instantiated. For example, a generic list class might
indicate that it can hold only non-null values. Similarly, a generic map
class might indicate it requires an immutable key type, but that it
supports both nullable and non-null value types.</P><P>There are two ways to restrict the type qualifiers that may be used on
the actual type argument when instantiating a generic class.</P><P>The first technique is the standard Java approach of using the
<TT>extends</TT> or <TT>super</TT> clause to supply an upper or lower bound.
For example:</P><PRE CLASS="verbatim">  MyClass&lt;T extends @NonNull Object&gt; { ... }

  MyClass&lt;@NonNull String&gt; m1;       // OK
  MyClass&lt;@Nullable String&gt; m2;      // error
</PRE><P>The second technique is to write a type annotation on the declaration of a
generic type parameter, which specifies the exact annotation that is
required on the actual type argument, rather than just a bound. For example:</P><PRE CLASS="verbatim">  class MyClassNN&lt;@NonNull T&gt; { ... }
  class MyClassNble&lt;@Nullable T&gt; { ... }

  MyClassNN&lt;@NonNull Number&gt; v1;     // OK
  MyClassNN&lt;@Nullable Number&gt; v2;    // error
  MyClassNble&lt;@NonNull Number&gt; v4;   // error
  MyClassNble&lt;@Nullable Number&gt; v3;  // OK
</PRE><P>A way to view a type annotation on a generic type parameter declaration is
as syntactic sugar for the annotation on both the <TT>extends</TT> and the
<TT>super</TT> clauses of the declaration. For example, these two declarations
have the same effect:</P><PRE CLASS="verbatim">  class MyClassNN&lt;@NonNull T&gt; { ... }
  class MyClassNN&lt;T extends @NonNull Object super @NonNull void&gt; { ... }
</PRE><P>except that the latter is not legal Java syntax. The syntactic sugar is
necessary because of two limitations in Java syntax: it is illegal to
specify both the upper and the
lower bound, and it is impossible to specify a type annotation for a lower
bound without also specifying a type (use of <TT>void</TT> is illegal).</P><P>If a type parameter declaration is annotated with <TT>@A</TT>, and a bound is
also given, then the annotation applies everywhere that there is no
explicit annotation. For example, the following pairs of declarations are
identical.</P><PRE CLASS="verbatim">  class MyClass&lt;@A T&gt; { ... }
  class MyClass&lt;T extends @A Object super @A void&gt; { ... }

  class MyClass&lt;@A T extends Number&gt; { ... }
  class MyClass&lt;T extends @A Number super @A void&gt; { ... }

  class MyClass&lt;@A T extends @B Number&gt; { ... }
  class MyClass&lt;T extends @B Number super @A void&gt; { ... }

  class MyClass&lt;@A T super Number&gt; { ... }
  class MyClass&lt;T extends @A Object super @A Number&gt; { ... }

  class MyClass&lt;@A T super @B Number&gt; { ... }
  class MyClass&lt;T extends @A Object super @B Number&gt; { ... }
</PRE><P>We can see from the above that almost all of the following types mean
different things:</P><PRE CLASS="verbatim">  class MyList1&lt;@Nullable T&gt; { ... }
  class MyList2&lt;@NonNull T&gt; { ... }
  class MyList3&lt;T extends @Nullable Object&gt; { ... }
  class MyList4&lt;T extends @NonNull Object&gt; { ... } // same as MyList2
</PRE><P><TT>MyList1</TT> must be instantiated with a nullable type. 
The implementation must be able to consume (store) a null
value and produce (retrieve) a null value.</P><P><TT>MyList2</TT> and <TT>MyList4</TT> must be instantiated with non-null type.
The implementation has to account for only non-null values &#X2014; it
does not have to account for consuming or producing null.</P><P><TT>MyList3</TT> may be instantiated either way:
with a nullable type or a non-null type. The implementation must consider
that it may be instantiated either way &#X2014; flexible enough to support either
instantiation, yet rigorous enough to impose the correct constraints of the
specific instantiation. It must also itself comply with the constraints of
the potential instantiations.</P><P>One way to express the difference is by comparing what expressions are
legal in the implementation of the list &#X2014; that is, what expressions may
appear in the ellipsis, such as inside a method&#X2019;s body. Suppose each class
has, in the ellipsis, these declarations:</P><PRE CLASS="verbatim">  T t;
  @Nullable T nble;      // Section "Type annotations on a use of a generic type variable", below,
  @NonNull T nn;         // further explains the meaning of "@Nullable T" and "@NonNull T".
  void add(T arg) { ... }
  T get(int i) { ... }
</PRE><P>Then the following expressions would be legal, inside a given implementation.
(Compilable source code appears as file
<TT>checker-framework/checkers/tests/nullness/GenericsExample.java</TT>.)</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>MyList1</TD><TD ALIGN=center NOWRAP>MyList2</TD><TD ALIGN=center NOWRAP>MyList3</TD><TD ALIGN=center NOWRAP>MyList4</TD></TR>
<TR><TD ALIGN=left NOWRAP> t = null;</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>error</TD><TD ALIGN=center NOWRAP>error</TD><TD ALIGN=center NOWRAP>error</TD></TR>
<TR><TD ALIGN=left NOWRAP> t = nble;</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>error</TD><TD ALIGN=center NOWRAP>error</TD><TD ALIGN=center NOWRAP>error</TD></TR>
<TR><TD ALIGN=left NOWRAP> nble = null;</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD></TR>
<TR><TD ALIGN=left NOWRAP> nn = null;</TD><TD ALIGN=center NOWRAP>error</TD><TD ALIGN=center NOWRAP>error</TD><TD ALIGN=center NOWRAP>error</TD><TD ALIGN=center NOWRAP>error</TD></TR>
<TR><TD ALIGN=left NOWRAP> t = this.get(0);</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD></TR>
<TR><TD ALIGN=left NOWRAP> nble = this.get(0);</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD></TR>
<TR><TD ALIGN=left NOWRAP> nn = this.get(0);</TD><TD ALIGN=center NOWRAP>error</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>error</TD><TD ALIGN=center NOWRAP>OK</TD></TR>
<TR><TD ALIGN=left NOWRAP> this.add(t);</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD></TR>
<TR><TD ALIGN=left NOWRAP> this.add(nble);</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>error</TD><TD ALIGN=center NOWRAP>error</TD><TD ALIGN=center NOWRAP>error</TD></TR>
<TR><TD ALIGN=left NOWRAP> this.add(nn);</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD><TD ALIGN=center NOWRAP>OK</TD></TR>
</TABLE><P><BR>
</P><P>The differences are more
significant when the qualifier hierarchy is more complicated than just
<TT>@Nullable</TT> and <TT>@NonNull</TT>.</P><!--TOC subsection Defaults for bounds-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.1.2&#XA0;&#XA0;Defaults for bounds</H3><!--SEC END --><P>
Ordinarily, a type parameter declaration with no extends clause means the
type parameter can be instantiated with any type argument at all. For
example:</P><PRE CLASS="verbatim">  class C&lt;T&gt; { ... }
  class C&lt;T extends Object&gt; { ... }  // identical to previous line
</PRE><P>However, instantiation may be restricted if a default qualifier is in
effect (see Section&#XA0;<A HREF="#defaults">19.1.1</A>). For example, the Nullness Checker
(Chapter&#XA0;<A HREF="#nullness-checker">3</A>) uses a (configurable) default of
<TT>@NonNull</TT> (see Section&#XA0;<A HREF="#null-defaults">3.3.2</A>). That means that either
declaration above is interpreted as</P><PRE CLASS="verbatim">  class C&lt;T extends @NonNull Object&gt; { ... }
</PRE><P>and an instantiation such as <TT>C&lt;@Nullable Number&gt;</TT> is illegal.
In such a case, to permit all type arguments, the programmer would write</P><PRE CLASS="verbatim">  class C&lt;T extends @Nullable Object&gt; { ... }
</PRE><P>It is possible to set the default qualifier for upper bounds separately
from other default qualifiers, by writing an annotation such as
<TT>@DefaultQualifier(value="Nullable", locations=</TT><TT>DefaultLocation.UPPER_BOUNDS</TT><TT>)</TT>.</P><!--TOC subsection Type annotations on a use of a generic type variable-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->18.1.3&#XA0;&#XA0;Type annotations on a use of a generic type variable</H3><!--SEC END --><P>A type annotation on a generic type variable overrides/ignores any type
qualifier (in the same type hierarchy) on the corresponding actual type
argument. For example, suppose that <TT>T</TT> is a formal type parameter.
Then using <TT>@Nullable T</TT> within the scope of <TT>T</TT> applies the type
qualifier <TT>@Nullable</TT> to the (unqualified) Java type of <TT>T</TT>.
This feature is only rarely used.</P><P>Here is an example of applying a type annotation to a generic type
variable:</P><PRE CLASS="verbatim">  class MyClass2&lt;T&gt; {
    ...
    @Nullable T myField = null;
    ...
  }
</PRE><P>The type annotation does not restrict how <TT>MyClass2</TT> may be
instantiated. In other words, both
<TT>MyClass2&lt;@NonNull String&gt;</TT> and <TT>MyClass2&lt;@Nullable String&gt;</TT> are
legal, and in both cases <TT>@Nullable T</TT> means <TT>@Nullable String</TT>.
In <TT>MyClass2&lt;@Interned String&gt;</TT>,
<TT>@Nullable T</TT> means <TT>@Nullable @Interned String</TT>.</P><!--TOC subsection Covariant type parameters-->
<H3 CLASS="subsection"><A NAME="covariant-type-parameters"><!--SEC ANCHOR -->18.1.4&#XA0;&#XA0;Covariant type parameters</A></H3><!--SEC END --><P>Java types are <EM>invariant</EM> in their type parameter. This means that
<TT>A&lt;X&gt;</TT> is a subtype of <TT>B&lt;Y&gt;</TT> only if <TT>X</TT> &#X2261; <TT>Y</TT>. For
example, <TT>ArrayList&lt;Number&gt;</TT> is a subtype of <TT>List&lt;Number&gt;</TT>, but
neither <TT>ArrayList&lt;Integer&gt;</TT> nor <TT>List&lt;Integer&gt;</TT> is a subtype of
<TT>List&lt;Number&gt;</TT>. (If they were, there would be a type hole in the Java
type system.) For the same reason, type parameter annotations are treated
invariantly. For example, <TT>List&lt;@Nullable String&gt;</TT> is not a subtype
of <TT>List&lt;String&gt;</TT>.</P><P>When a type parameter is used in a read-only way &#X2014; that is, when values
of that type are read but are never assigned &#X2014; then it is safe for the
type to be <EM>covariant</EM> in the type parameter. This means that a
subtype&#X2019;s type parameter can be a subtype of the supertype&#X2019;s type
parameter. Use the <TT>@</TT><A HREF="doc/checkers/nullness/quals/Covariant.html"><TT>Covariant</TT></A> annotation to indicate
this.</P><P>For example, consider <TT>Iterator</TT>. Its elements can be read but not
written, so <TT>Iterator&lt;@Nullable String&gt;</TT> can be a subtype of
<TT>Iterator&lt;String&gt;</TT> without introducing a hole in the type system.
Therefore, its type parameter is annotated with <TT>@Covariant</TT>.
The first type parameter of <TT>Map.Entry</TT> is also covariant.
Another example would be a hypothetical class <TT>ImmutableList</TT>.</P><P>The <TT>@Covariant</TT> annotation is trusted but not checked.
If you write <TT>@Covariant</TT> in a position that can be written (say, by a
<TT>set</TT> operation), then you have created an unsoundness in the type system.
For example, it would be incorrect to annotate the type parameter of
<TT>ListIterator</TT>, which supports a <TT>set</TT> operation.</P><!--TOC section Qualifier polymorphism-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="qualifier-polymorphism">18.2</A>&#XA0;&#XA0;Qualifier polymorphism</H2><!--SEC END --><P>The Checker Framework also supports type <EM>qualifier</EM> polymorphism for
methods, which permits a single method to have multiple different qualified
type signatures.</P><P>To <EM>define</EM> a polymorphic qualifier, mark the definition with
<TT>@</TT><A HREF="doc/checkers/quals/PolymorphicQualifier.html"><TT>PolymorphicQualifier</TT></A>. For example,
<TT>@</TT><A HREF="doc/checkers/nullness/quals/PolyNull.html"><TT>PolyNull</TT></A> is a polymorphic type
qualifier for the Nullness type system:</P><PRE CLASS="verbatim">  @PolymorphicQualifier
  @Target(ElementType.TYPE_USE)
  public @interface PolyNull { }
</PRE><P>To <EM>use</EM> a polymorphic qualifier, just write it on a type.
For example, you can write <TT>@PolyNull</TT> anywhere that you would write
<TT>@NonNull</TT> or <TT>@Nullable</TT>.</P><P>A method written using a polymorphic qualifier conceptually has multiple
versions, somewhat like a template in C++ or the generics feature of Java.
In each version, each instance of the polymorphic qualifier has been
replaced by the same other qualifier from the hierarchy. See the examples
below in Section&#XA0;<A HREF="#qualifier-polymorphism-examples">18.2.1</A>.</P><P>The method body must type-check with all signatures. A method call is
type-correct if it type-checks under any one of the signatures. If a call
matches multiple signatures, then the compiler uses the most specific
matching signature for the purpose of type-checking. This is just like
Java&#X2019;s rule for resolving overriding methods, though there is no effect on
run-time dispatch or behavior.</P><P>Polymorphic qualifiers can be used on a method signature or body.
They may not be used on classes or fields.</P><!--TOC subsection Examples of using polymorphic qualifiers-->
<H3 CLASS="subsection"><A NAME="qualifier-polymorphism-examples"><!--SEC ANCHOR -->18.2.1&#XA0;&#XA0;Examples of using polymorphic qualifiers</A></H3><!--SEC END --><P>As an example of the use of <TT>@PolyNull</TT>, method <A HREF="http://docs.oracle.com/javase/7/docs/api/java/lang/Class.html#cast(java.lang.Object)"><TT>Class.cast</TT></A>
returns null if and only if its argument is <TT>null</TT>:</P><PRE CLASS="verbatim">  @PolyNull T cast(@PolyNull Object obj) { ... }
</PRE><P>This is like writing:</P><PRE CLASS="verbatim">   @NonNull T cast( @NonNull Object obj) { ... }
  @Nullable T cast(@Nullable Object obj) { ... }
</PRE><P>except that the latter is not legal Java, since it defines two
methods with the same Java signature.</P><P>As another example, consider</P><PRE CLASS="verbatim">  @PolyNull T max(@PolyNull T x, @PolyNull T y);
</PRE><P>which is like writing</P><PRE CLASS="verbatim">   @NonNull T max( @NonNull T x,  @NonNull T y);
  @Nullable T max(@Nullable T x, @Nullable T y);
</PRE><P>Another way of thinking about which one of the two <TT>max</TT> variants is
selected is that the nullness annotations of (the declared types of) both
arguments are <EM>unified</EM> to a type that is a supertype of both, also
known as the <EM>least upper bound</EM> or lub. If both
arguments are <TT>@NonNull</TT>, their unification (lub) is <TT>@NonNull</TT>, and the
method return type is <TT>@NonNull</TT>. But if even one of the arguments is <TT>@Nullable</TT>,
then the unification (lub) is <TT>@Nullable</TT>, and so is the return type.</P><!--TOC subsection Use multiple polymorphic qualifiers in a method signature-->
<H3 CLASS="subsection"><A NAME="qualifier-polymorphism-multiple-qualifiers"><!--SEC ANCHOR -->18.2.2&#XA0;&#XA0;Use multiple polymorphic qualifiers in a method signature</A></H3><!--SEC END --><P>Usually, it does not make sense to write only a single instance of a polymorphic
qualifier in a method definition: if you write one instance of (say)
<TT>@PolyNull</TT>, then you should use at least two. (An exception is a
polymorphic qualifier on an array element type; this section ignores that
case, but see below for further details.)</P><P>For example, there is no point to writing</P><PRE CLASS="verbatim">  void m(@PolyNull Object obj)
</PRE><P>which expands to</P><PRE CLASS="verbatim">  void m(@NonNull Object obj)
  void m(@Nullable Object obj)
</PRE><P>This is no different (in terms of which calls to the method will
type-check) than writing just</P><PRE CLASS="verbatim">  void m(@Nullable Object obj)
</PRE><P>The benefit of polymorphic qualifiers comes when one is used multiple times
in a method, since then each instance turns into the same type qualifier.
Most frequently, the polymorphic qualifier appears on at least one formal
parameter and also on the return type. It can also be useful to have
polymorphic qualifiers on (only) multiple formal parameters, especially if
the method side-effects one of its arguments.
For example, consider</P><PRE CLASS="verbatim">void moveBetweenStacks(Stack&lt;@PolyNull Object&gt; s1, Stack&lt;@PolyNull Object&gt; s2) {
  s1.push(s2.pop());
}
</PRE><P>In this example, if it is acceptable to rewrite your code to use Java
generics, the code can be even cleaner:</P><PRE CLASS="verbatim">&lt;T&gt; void moveBetweenStacks(Stack&lt;T&gt; s1, Stack&lt;T&gt; s2) {
  s1.push(s2.pop());
}
</PRE><!--TOC subsection Using a single polymorphic qualifier on an element type-->
<H3 CLASS="subsection"><A NAME="qualifier-polymorphism-element-types"><!--SEC ANCHOR -->18.2.3&#XA0;&#XA0;Using a single polymorphic qualifier on an element type</A></H3><!--SEC END --><P>There is an exception to the general rule that a polymorphic qualifier
should be used multiple times in a signature. It can make sense to use a
polymorphic qualifier just once, if it is on an array or generic element
type.</P><P>For example, consider a routine that returns the first index, in an array
or collection, of a given element:</P><PRE CLASS="verbatim">  public static int indexOf(@PolyNull Object[] a, Object elt) { ... }

  public static int indexOf(Collection&lt;@PolyNull Object&gt; a, Object elt) { ... }
</PRE><P>If <TT>@PolyNull</TT> were replaced with either <TT>@Nullable</TT> or <TT>@NonNull</TT>, then
some safe client calls would be rejected.</P><P>Of course, it would be better style to use a generic method, as in either
of these signatures (and likewise for the <TT>Collection</TT> version):</P><PRE CLASS="verbatim"> public static &lt;T&gt; int indexOf(T[] a, /*@Nullable*/ Object elt) { ... }
 public static &lt;T&gt; int indexOf(T[] a, T elt) { ... }
</PRE><P>In conclusion, use of a single polymorphic qualifier may be necessary in
legacy code, but can be avoided by use of better code style.</P><HR><!--TOC chapter Advanced type system features-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="advanced-type-system-features">Chapter&#XA0;19</A>&#XA0;&#XA0;Advanced type system features</H1><!--SEC END --><P>This chapter describes features that are automatically supported by every
checker written with the Checker Framework.
You may wish to skim or skip this chapter on first reading. After you have
used a checker for a little while and want to be able to express more
sophisticated and useful types, or to understand more about how the Checker
Framework works, you can return to it.</P><!--TOC section The effective qualifier on a type (defaults and inference)-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="effective-qualifier">19.1</A>&#XA0;&#XA0;The effective qualifier on a type (defaults and inference)</H2><!--SEC END --><P>A checker sometimes treats a type as having a slightly different qualifier
than what is written on the type &#X2014; especially if the programmer wrote no
qualifier at all.
Most readers can skip this section on first reading, because you will
probably find the system simply &#X201C;does what you mean&#X201D;, without forcing
you to write too many qualifiers in your program.
In particular, qualifiers in method bodies are extremely rare.</P><P>Most of this section is applicable only to source code that is being
checked by a checker.
</P><P>The following steps determine the effective
qualifier on a type &#X2014; the qualifier that the checkers treat as being present.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
The type system adds implicit qualifiers. Implicit qualifiers can be
built into a type system (Section&#XA0;<A HREF="#writing-type-introduction">22.4</A>), in
which case the type system&#X2019;s documentation should explain all of the type
system&#X2019;s implicit qualifiers. Or, a programmer may introduce an implicit
annotation on each use of class <I>C</I> by writing a qualifier on the
declaration of class <I>C</I>.<UL CLASS="itemize"><LI CLASS="li-itemize">
Example 1 (built-in): In the Nullness type system,
<TT>enum</TT> values are never null, nor is a method receiver.
</LI><LI CLASS="li-itemize">Example 2 (built-in): In the Interning type system, string literals
and <TT>enum</TT> values are always interned.
</LI></UL></LI><LI CLASS="li-enumerate">If a type qualifier is present in the source code, that qualifier is used.<P>If the type has an implicit qualifier, then it is an error to write an
explicit qualifier that is equal to (redundant with) or a supertype of
(weaker than) the implicit qualifier. A programmer may strengthen
(write a subtype of) an implicit qualifier, however.</P></LI><LI CLASS="li-enumerate">If there is no implicit or explicit qualifier on a type, then a default
qualifier may be applied; see Section&#XA0;<A HREF="#defaults">19.1.1</A>.<P>At this point (after step 3), every type has a qualifier.</P></LI><LI CLASS="li-enumerate">The type system may refine a qualified type on a local variable &#X2014; that
is, treat it as a subtype of how it was declared or defaulted. This
refinement is always sound and has the effect of eliminating false
positive error messages. See Section&#XA0;<A HREF="#type-refinement">19.1.2</A>.</LI></OL><!--TOC subsection Default qualifier for unannotated types-->
<H3 CLASS="subsection"><A NAME="defaults"><!--SEC ANCHOR -->19.1.1&#XA0;&#XA0;Default qualifier for unannotated types</A></H3><!--SEC END --><P>A type system designer, or an end-user programmer, can cause unannotated
references to be treated as if they had a default annotation.</P><P>There are several defaulting mechanisms, for convenience and flexibility.
When determining the default qualifier for a use of a type, the following
rules are used in order, until one applies.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Use the innermost user-written <TT>@DefaultQualifier</TT>, as explained in
this section.
</LI><LI CLASS="li-itemize">Use the default specified by the type system designer
(Section&#XA0;<A HREF="#typesystem-defaults">22.3.3</A>).
</LI><LI CLASS="li-itemize">Use <TT>@</TT><A HREF="doc/checkers/quals/Unqualified.html"><TT>Unqualified</TT></A>, which the framework
inserts to avoid ambiguity and simplify the programming interface for
type system designers. Users do not have to worry about this detail,
but type system implementers can rely on the fact that some
qualifier is present.
</LI></UL><P>The end-user programmer specifies a default qualifier by writing the <TT>@</TT><A HREF="doc/checkers/quals/DefaultQualifier.html"><TT>DefaultQualifier</TT></A>
annotation on a package, class, method, or variable declaration. The
argument to <TT>@</TT><A HREF="doc/checkers/quals/DefaultQualifier.html"><TT>DefaultQualifier</TT></A> is the <TT>String</TT>
name of an annotation. It may be a short name like <TT>"NonNull"</TT>, if an
appropriate import statement exists. Otherwise, it should be
fully-qualified, like <TT>"checkers.nullness.quals.NonNull"</TT>.
The optional second argument indicates where the default
applies. If the second argument is omitted, the specified annotation is
the default in all locations. See the Javadoc of <A HREF="doc/checkers/quals/DefaultQualifier.html"><TT>DefaultQualifier</TT></A> for details.</P><P>For example, using the Nullness type system (Chapter&#XA0;<A HREF="#nullness-checker">3</A>):</P><PRE CLASS="verbatim">import checkers.quals.*;        // for DefaultQualifier[s]
import checkers.nullness.quals.NonNull;

@DefaultQualifier("NonNull")
class MyClass {

  public boolean compile(File myFile) { // myFile has type "@NonNull File"
    if (!myFile.exists())          // no warning: myFile is non-null
      return false;
    @Nullable File srcPath = ...;  // must annotate to specify "@Nullable File"
    ...
    if (srcPath.exists())          // warning: srcPath might be null
      ...
  }

  @DefaultQualifier("Mutable")
  public boolean isJavaFile(File myfile) {  // myFile has type "@Mutable File"
    ...
  }
}
</PRE><P>If you wish to write multiple
<TT>@</TT><A HREF="doc/checkers/quals/DefaultQualifier.html"><TT>DefaultQualifier</TT></A> annotations at a single location,
use
<TT>@</TT><A HREF="doc/checkers/quals/DefaultQualifiers.html"><TT>DefaultQualifiers</TT></A> instead. For example:</P><PRE CLASS="verbatim">@DefaultQualifiers({
  @DefaultQualifier("NonNull"),
  @DefaultQualifier("Mutable")
})
</PRE><P>If <TT>@DefaultQualifier</TT>[<TT>s</TT>] is placed on a package (via the
<TT>package-info.java</TT> file), then it applies to the given package <EM>and</EM>
all subpackages.
</P><P>Recall that an annotation on a class definition indicates an implicit
qualifier (Section&#XA0;<A HREF="#effective-qualifier">19.1</A>) that can only be
strengthened, not weakened. This can lead to unexpected results if
the default qualifier applies to a class definition. Thus, you may want to
put explicit qualifiers on class declarations (which prevents the default
from taking effect), or exclude class declarations from defaulting.</P><P>When a programmer omits an <TT>extends</TT> clause at a declaration of a type
parameter, the default still applies to the implicit upper bound. For
example, consider these two declarations:</P><PRE CLASS="verbatim">  class C&lt;T&gt; { ... }
  class C&lt;T extends Object&gt; { ... }  // identical to previous line
</PRE><P>The two declarations are treated identically by Java, and the default
qualifier applies to the <TT>Object</TT> upper bound whether it is implicit or
explicit. (The @NonNull default annotation applies only to the upper bound
in the <TT>extends</TT> clause, not to the lower bound in the inexpressible
implicit <TT>super void</TT> clause.)</P><!--TOC subsection Automatic type refinement (flow-sensitive type qualifier inference)-->
<H3 CLASS="subsection"><A NAME="type-refinement"><!--SEC ANCHOR -->19.1.2&#XA0;&#XA0;Automatic type refinement (flow-sensitive type qualifier inference)</A></H3><!--SEC END --><P>In order to reduce the burden of annotating types in your program, the
checkers soundly treat certain variables and expressions as having a
subtype of their declared or defaulted (Section&#XA0;<A HREF="#defaults">19.1.1</A>)
type. This functionality
never introduces unsoundness or causes an error to be missed: it merely
suppresses false positive warnings.</P><P>By default, all checkers, including new checkers that you write, can take
advantage of this functionality. Most of the time, users don&#X2019;t have to
think about, and may not even notice, this feature of the framework. The
checkers simply do the right thing even when a programmer forgets an
annotation on a local variable, or when a programmers writes an
unnecessarily general type in a declaration.</P><P>If you are curious or want more details about this feature, then read on.</P><P>As an example, the Nullness checker (Chapter&#XA0;<A HREF="#nullness-checker">3</A>) can automatically
determine that certain variables are non-null, even if they were explicitly
or by default annotated as nullable.
The checker treats a variable or expression as <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
starting at the time that it is either
assigned a non-null value or checked against null (e.g., via an assertion,
<TT>if</TT> statement, or being dereferenced)
</LI><LI CLASS="li-itemize">until it might be re-assigned (e.g.,
via an assignment that might affect this variable, or via a method call
that might affect this variable).
</LI></UL><P>As with explicit annotations, the implicitly non-null types permit
dereferences and assignments to non-null types, without
compiler warnings.</P><P>Consider this code, along with comments indicating whether the
Nullness checker (Chapter&#XA0;<A HREF="#nullness-checker">3</A>) issues a warning. Note that the same expression may yield a
warning or not depending on its context.</P><PRE CLASS="verbatim">  // Requires an argument of type @NonNull String
  void parse(@NonNull String toParse) { ... }

  // Argument does NOT have a @NonNull type
  void lex(@Nullable String toLex) {
    parse(toLex);        // warning:  toLex might be null
    if (toLex != null) {
      parse(toLex);      // no warning:  toLex is known to be non-null
    }
    parse(toLex);        // warning:  toLex might be null
    toLex = new String(...);
    parse(toLex);        // no warning:  toLex is known to be non-null
  }
</PRE><P>If you find examples where you think a value should be inferred to have
(or not have) a
given annotation, but the checker does not do so, please submit a bug
report (see Section&#XA0;<A HREF="#reporting-bugs">25.2</A>) that includes a small piece of
Java code that reproduces the problem.</P><P>The inference indicates when a variable can be treated as having a subtype
of its declared type &#X2014; for instance, when an otherwise nullable type can be
treated as a <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> one. The inference never treats a variable as
a supertype of its declared type (e.g., an expression of <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>
type is never inferred to be treated as possibly-null).</P><P>Type inference is never performed for method parameters of non-private
methods, nor for non-private fields. 
More generally, the inferred information is never written to the
<TT>.class</TT> file as user-written annotations are.
If the checker did inference in externally-visible locations and wrote it
to the <TT>.class</TT> file, then the resulting <TT>.class</TT> file would be different
depending on whether an annotation processor had been run or not. It is a
design goal that the same annotations appear in the <TT>.class</TT> file
regardless of whether the class is compiled with or without the checker,
and this requires that any public signature be fully annotated by the user
rather than inferred.</P><!--TOC subsection Fields and flow sensitivity analysis-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->19.1.3&#XA0;&#XA0;Fields and flow sensitivity analysis</H3><!--SEC END --><P>Flow sensitivity analysis infers the type of fields in some restricted cases:</P><UL CLASS="itemize"><LI CLASS="li-itemize">A final initialized field:
Type inference is performed for final fields that are initialized to a
compile-time constant at the declaration site; so the type of <TT>protocol</TT>
is <TT>@NonNull String</TT> in the following declaration:<PRE CLASS="verbatim">    public final String protocol = "https";
</PRE><P>Please note that such inferred type may leak to the public interface of the
class. To override such behavior, you can explicitly insert the desired
annotation, e.g.,</P><PRE CLASS="verbatim">    public final @Nullable String protocol = "https";
</PRE></LI><LI CLASS="li-itemize">Within method bodies:
Type inference is performed for fields in the context of method bodies,
like local variables, but method invocations invalidate any inferred
information. Consider the following example, where <TT>name</TT> is a nullable
field:<PRE CLASS="verbatim">class DBObject {
  @Nullable Date updatedAt;

  void update() {
    if (updatedAt == null)
        updatedAt = new Date();
    // updatedAt is nonnull
    log("Updating object at " + updatedAt.getTime());

    persistData();
    // updatedAt is nullable again
    log.debug("Saved object updated at " + updatedAt.getTime()); // invalid!
  }
}
</PRE><P>Here the call to <TT>persistData()</TT> invalidates the inferred non-null type
of <TT>updatedAt</TT>.</P><P>When methods do not modify any object state or have any identity side-effects
(e.g., <TT>log()</TT> method here), you can annotate these methods as
<TT>Pure</TT>. Annotating them as <TT>Pure</TT>, would cause the flow analyzer to
carry the inferred types across the method invocation boundary.</P></LI></UL><!--TOC subsection Inherited defaults-->
<H3 CLASS="subsection"><A NAME="inherited-defaults"><!--SEC ANCHOR -->19.1.4&#XA0;&#XA0;Inherited defaults</A></H3><!--SEC END --><P>In certain situations, it would be convenient for an annotation on a
superclass member to be automatically inherited by subclasses that override
it. This feature would reduce both annotation effort and program
comprehensibility. In general, a program is read more often than it is
edited/annotated, so the Checker Framework does not currently support this
feature. Here are more detailed justifications:</P><UL CLASS="itemize"><LI CLASS="li-itemize">Currently, a user can determine the annotation on a parameter or return
value by looking at a single file. If annotations could be inherited
from supertypes, then a user would have to examine all supertypes to
understand the meaning of an unannotated type in a given file.</LI><LI CLASS="li-itemize">Different annotations might be inherited from a supertype and an
interface, or from two interfaces. Presumably, the subtype&#X2019;s annotations
would be stronger than either (the greatest lower bound in the type
system), or an error would be thrown if no such annotations existed.</LI></UL><P>If these issues can be resolved, then the feature may be added in the
future. Or, it may be added optionally, and each type-checker
implementation can enable it if desired.</P><!--TOC section Writing Java expressions as annotation arguments-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="java-expressions-as-arguments">19.2</A>&#XA0;&#XA0;Writing Java expressions as annotation arguments</H2><!--SEC END --><P>Sometimes, it is necessary to write a Java expression as the argument to an
annotation. As of this writing, the annotations that take a Java
expression as an argument are:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>@</TT><A HREF="doc/checkers/nullness/quals/KeyFor.html"><TT>KeyFor</TT></A>
</LI><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNullOnEntry.html"><TT>NonNullOnEntry</TT></A>
</LI><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/nullness/quals/AssertNonNullAfter.html"><TT>AssertNonNullAfter</TT></A>
</LI><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/nullness/quals/AssertNonNullIfTrue.html"><TT>AssertNonNullIfTrue</TT></A>
</LI><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/nullness/quals/AssertNonNullIfFalse.html"><TT>AssertNonNullIfFalse</TT></A>
</LI></UL><P>The expression is a subset of legal Java expressions:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the receiver object, <TT>this</TT>.
</LI><LI CLASS="li-itemize">a formal parameter. Write <TT>#</TT> followed by the zero-based parameter
index. For example: <TT>#0</TT>, <TT>#2</TT>.
</LI><LI CLASS="li-itemize">a local variable. This is not applicable for method annotations, but is
applicable to type annotations such as
<TT>@</TT><A HREF="doc/checkers/nullness/quals/KeyFor.html"><TT>KeyFor</TT></A>. Write the variable name. For
example: <TT>myLocalVar</TT>.
</LI><LI CLASS="li-itemize">a static variable. Write the class name and the variable, as in
<TT>System.out</TT>.
<P>Within the class itself, just write the field name &#X2014; do not write the
class name.
</P></LI><LI CLASS="li-itemize">a field of any expression. For example: <TT>next</TT>,
<TT>this.next</TT>, <TT>#0.next</TT>, <TT>myLocalVar.next</TT>.
</LI><LI CLASS="li-itemize">a method invocation on any expression.
The method must be pure and have no formal parameters. For example:
<TT>myClass.getPackage()</TT>, <TT>myClass.getSuperclass()</TT>,
<TT>myClass.getComponentType()</TT>.<P><B>Warning:</B> currently, annotations that use method calls are
<EM>not</EM> checked. The annotation is trusted, and other code will rely
on it, but it is not verified that other code establishes or maintains
the validity of the annotation. Such expressions are still useful if a
human verifies their correctness. They are used in the JDK annotations,
for example.
</P></LI></UL><P>You may optionally omit a leading &#X201C;<TT>this.</TT>&#X201D;, just as in Java. Thus, 
<TT>this.next</TT> and <TT>next</TT> are equivalent, assuming that there is no
shadowing definition of <TT>next</TT>.</P><P><B>Limitation:</B> Currently, only one level of field access can be
checked; the checker cannot handle, for example, <TT>"this.field1.field2"</TT>.</P><P>(A side note: The formal parameter syntax <TT>#0</TT> may seem less convenient
than writing the formal parameter name. This syntax is necessary because
in the <TT>.class</TT> file, no parameter name information is available. Running
the compiler without a checker should create legal annotations in the
<TT>.class</TT> file, so we cannot rely on the checker to translate names to
indices.)</P><!--TOC section Inexpressible types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="inexpressible-types">19.3</A>&#XA0;&#XA0;Inexpressible types</H2><!--SEC END --><P>The Type Annotations syntax&#XA0;[<A HREF="#JSR308-2008-09-12">Ern08</A>] is designed to be easy to read. As a result,
there are types that it cannot express. An example is the type of
<TT>Collection.toArray()</TT>, which returns an array of objects, where the
objects have the same annotation as the elements of the receiver.</P><P>A possible annotation would be</P><PRE CLASS="verbatim">public @PolyNull Object [] toArray() ArrayList&lt;@PolyNull E&gt; { ... }
</PRE><P>except that this is illegal syntax: &#X201C;<TT>ArrayList&lt;@PolyNull E&gt;</TT>&#X201D; is
not legal in the receiver position. (This is a motivation for
<A HREF="http://types.cs.washington.edu/jsr308/specification/java-annotation-design.html#receiver-type-parameter-annotations">extending</A>
the Type Annotations syntax.)</P><P>The annotated libraries (Section&#XA0;<A HREF="#annotating-libraries">21</A>) contain a less-precise annotation for
<TT>toArray</TT>. The Nullness Checker special-cases <TT>toArray</TT> to
act as if it had the above annotation. The cases that
are currently being handled are described in
<A HREF="doc/checkers/nullness/CollectionToArrayHeuristics.html"><TT>CollectionToArrayHeuristics</TT></A>.
This approach would be possible for other checkers and other methods as the
need arises.</P><!--TOC section Unused fields and dependent types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="unused-fields-and-dependent-types">19.4</A>&#XA0;&#XA0;Unused fields and dependent types</H2><!--SEC END --><P>In an inheritance hierarchy, subclasses often introduce new methods and
fields. For example, a <TT>Marsupial</TT> (and its subclasses such as
<TT>Kangaroo</TT>) might have a variable indicating the size of the animal&#X2019;s
pouch. Because such variables would not exist in superclasses such as
<TT>Mammal</TT> and <TT>Animal</TT>, any attempt to use them would be a compile-time
error.</P><P>If you cannot use subtypes but wish to enforce similar requirements using
type qualifiers, you can do so. To restrict which methods may be invoked,
you can write an annotation on a method receiver; then the method may only
be invoked on an expression whose type has the given annotation (or one of
its subtypes). Section&#XA0;<A HREF="#unused-fields">19.4.1</A> describes how to restrict which
fields may be accessed: in other words, a given field may only be accessed
from an expression whose type has a given qualifier. Then,
Section&#XA0;<A HREF="#dependent-types">19.4.2</A> describes an even more powerful mechanism, by
which the qualifier of a field depends on the qualifier of the expression
from which the field was accessed.
(Also see the discussion of typestate checkers, in
Chapter&#XA0;<A HREF="#typestate-checker">16</A>.)</P><!--TOC subsection Unused fields-->
<H3 CLASS="subsection"><A NAME="unused-fields"><!--SEC ANCHOR -->19.4.1&#XA0;&#XA0;Unused fields</A></H3><!--SEC END --><P>A Java subtype can have more fields than its supertype. For example:</P><PRE CLASS="verbatim">class Mammal extends Animal { ... }
class Marsupial extends Mammal {
  ...
  int pouchSize;  // pouch capacity, in cubic centimeters
  ...
}
</PRE><P>You can simulate
the same effect for type qualifiers: a given field may not be accessed via
a reference with a supertype qualifier, but can be accessed via a reference
with a subtype qualifier.
For example:</P><PRE CLASS="verbatim">@interface Mammal { }
@interface Marsupial { }
class Animal {
  @Unused(when=Mammal.class)
  int pouchSize;  // pouch capacity, in cubic centimeters
  ...
}

@Marsupial Animal joey = ...;
... joey.pouchSize ...    // OK
@Mammal Animal mae = ...;
... mae.pouchSize ...    // compile-time error
</PRE><P>The <TT>@</TT><A HREF="doc/checkers/quals/Unused.html"><TT>Unused</TT></A> annotation
on a field declares that the field may <EM>not</EM> be accessed via a receiver of
the given qualified type (or any <EM>super</EM>type).</P><P>(It would probably be clearer to replace <TT>@Unused</TT> by an annotation that
indicates when the field <EM>may</EM> be used.)</P><!--TOC subsection Dependent types-->
<H3 CLASS="subsection"><A NAME="dependent-types"><!--SEC ANCHOR -->19.4.2&#XA0;&#XA0;Dependent types</A></H3><!--SEC END --><P>A variable has a <EM>dependent type</EM> if its type depends on some other
value or type.
</P><P>The Checker Framework supports a form of dependent types, via the
<TT>@</TT><A HREF="doc/checkers/quals/Dependent.html"><TT>Dependent</TT></A> annotation.
This annotation changes the type of a field or variable, based on the
qualified type of the receiver (<TT>this</TT>). This can be viewed as a more
expressive form of polymorphism (see Section&#XA0;<A HREF="#polymorphism">18</A>). It can
also be seen as a way of linking the meanings of two type qualifier
hierarchies.</P><P>Here is a restatement of the example of Section&#XA0;<A HREF="#unused-fields">19.4.1</A>, using
<TT>@</TT><A HREF="doc/checkers/quals/Dependent.html"><TT>Dependent</TT></A>:</P><PRE CLASS="verbatim">@interface Mammal { }
@interface Marsupial { }
class Animal { ...
  // pouch capacity, in cubic centimeters
  // (non-null if this animal is a marsupial)
  @Nullable @Dependent(result=NonNull.class, when=Marsupial.class) Integer pouchSize;
  ...
}

@Marsupial Animal joey = ...;
... joey.pouchSize.intValue() ...    // OK
@Mammal Animal mae = ...;
... mae.pouchSize.intValue() ...    // compile-time error:
                                    //   dereference of possibly-null mae.pouchSize
</PRE><P>However, when the <TT>@</TT><A HREF="doc/checkers/quals/Unused.html"><TT>Unused</TT></A> annotation is sufficient, you
should use it instead of <TT>@Dependent</TT>.</P><HR><!--TOC chapter Handling warnings and legacy code-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="warnings-and-legacy">Chapter&#XA0;20</A>&#XA0;&#XA0;Handling warnings and legacy code</H1><!--SEC END --><P>Section&#XA0;<A HREF="#get-started-with-legacy-code">2.4.1</A> describes a methodology for
applying annotations to legacy code. This chapter tells you what to do if,
for some reason, you cannot change your code in such a way as to eliminate
a checker warning.</P><P>Also recall that you can convert checker errors into warnings via the
<TT>-Awarns</TT> command-line option; see Section&#XA0;<A HREF="#checker-options">2.2.1</A>.</P><!--TOC section Checking partially-annotated programs: handling unannotated code-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="unannotated-code">20.1</A>&#XA0;&#XA0;Checking partially-annotated programs: handling unannotated code</H2><!--SEC END --><P>Sometimes, you wish to type-check only part of your program.
You might focus on the most mission-critical or error-prone part of your
code. When you start to use a checker, you may not wish to annotate
your entire program right away.
You may not have
enough knowledge to annotate poorly-documented libraries that your program uses.</P><P>If annotated code uses unannotated code, then the checker may issue
warnings. For example, the Nullness checker (Chapter&#XA0;<A HREF="#nullness-checker">3</A>) will
warn whenever an unannotated method result is used in a non-null context:</P><PRE CLASS="verbatim">  @NonNull myvar = unannotated_method();   // WARNING: unannotated_method may return null
</PRE><P>If the call <EM>can</EM> return null, you should fix the bug in your program by
removing the <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> annotation in your own program.</P><P>If the library call <EM>never</EM> returns null,
there are several ways to eliminate the compiler warnings.
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Annotate <TT>unannotated_method</TT> in full. This approach provides
the strongest guarantees, but may require you to annotate additional
methods that <TT>unannotated_method</TT> calls. See
Chapter&#XA0;<A HREF="#annotating-libraries">21</A> for a discussion of how to annotate
libraries for which you have no source code.
</LI><LI CLASS="li-enumerate">Annotate only the signature of <TT>unannotated_method</TT>, and
suppress warnings in its body. Two ways to suppress the warnings are via a
<TT>@SuppressWarnings</TT> annotation or by not running the checker on that
file (see Section&#XA0;<A HREF="#suppressing-warnings">20.2</A>).
</LI><LI CLASS="li-enumerate">Suppress all warnings related to uses of <TT>unannotated_method</TT>
via the <TT>skipUses</TT> processor option
(see Section&#XA0;<A HREF="#suppressing-warnings">20.2</A>).
Since this can suppress more warnings than you may expect,
it is usually better to annotate at least the method&#X2019;s signature. If you
choose the boundary between the annotated and unannotated code wisely,
then you only have to annotate the signatures of a limited number of
classes/methods
(e.g., the public interface to a library or package).</LI></OL><P>Chapter&#XA0;<A HREF="#annotating-libraries">21</A> discusses adding annotations to
signatures when you do not have source code available.
Section&#XA0;<A HREF="#suppressing-warnings">20.2</A> discusses suppressing warnings.</P><P>If you annotate a third-party library, please share it with us so that we
can distribute the annotations with the Checker Framework; see
Section&#XA0;<A HREF="#reporting-bugs">25.2</A>.</P><!--TOC section Suppressing warnings-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="suppressing-warnings">20.2</A>&#XA0;&#XA0;Suppressing warnings</H2><!--SEC END --><P>You may wish to suppress checker warnings because of unannotated libraries
or un-annotated portions of your own code, because of application
invariants that are beyond the capabilities of the type system, because of
checker limitations, because you are interested in only some of the
guarantees provided by a checker, or for other reasons. You can suppress
warnings via
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
the <TT>@SuppressWarnings</TT> annotation,
</LI><LI CLASS="li-enumerate">the <TT>-AskipUses</TT> command-line option,
</LI><LI CLASS="li-enumerate">the <TT>-AskipDefs</TT> command-line option,
</LI><LI CLASS="li-enumerate">the <TT>-Alint</TT> command-line option,
</LI><LI CLASS="li-enumerate">not using the <TT>-processor</TT> command-line option, or
</LI><LI CLASS="li-enumerate">checker-specific mechanisms.
</LI></OL><P>We now explain these mechanisms in turn.</P><!--TOC subsection <TT>@SuppressWarnings</TT> annotation-->
<H3 CLASS="subsection"><A NAME="suppresswarnings-annotation"><!--SEC ANCHOR -->20.2.1&#XA0;&#XA0;<TT>@SuppressWarnings</TT> annotation</A></H3><!--SEC END --><P>You can suppress specific errors and warnings by use of the
<TT>@SuppressWarnings("</TT><TT><EM>checkername</EM></TT><TT>")</TT> annotation, for example
<TT>@SuppressWarnings("interning")</TT> or <TT>@SuppressWarnings("nullness")</TT>.
The argument <EM>checkername</EM> is in lower case and is derived from the
way you invoke the checker; for example, if you invoke a checker as
<TT>javac -processor MyNiftyChecker ...</TT>, then you would suppress its
error messages with <TT>@SuppressWarnings("mynifty")</TT>. (An exception is
the Basic Checker, for which you use the annotation name; see
Section&#XA0;<A HREF="#basic-using">15.1</A>).</P><P>A <TT>@</TT><A HREF="http://docs.oracle.com/javase/7/docs/api/java/lang/SuppressWarnings.html"><TT>SuppressWarnings</TT></A>
annotation may be placed on program elements such as a local
variable declaration, a method, or a class. It suppresses all warnings
related to the given checker, for that program element.</P><P>For instance, one common use is
to suppress warnings at a cast that you know is safe. Here is an example
that uses the Tainting Checker (Section&#XA0;<A HREF="#tainting-checker">9</A>):</P><PRE CLASS="verbatim">  @SuppressWarnings("tainting")
  String myvar = (@Untainted String) expr;  // expr has type: @Tainted String
</PRE><P>It is good practice to suppress warnings in the
smallest possible scope. For example, if a particular expression causes a
false positive warning, you should extract that expression into a local variable
and place a <TT>@SuppressWarnings</TT> annotation on the variable
declaration.
As another example, if you have annotated the signatures but not the bodies
of the methods in a class or package, put a <TT>@SuppressWarnings</TT>
annotation on the class declaration or on the package&#X2019;s
<TT>package-info.java</TT> file.</P><P><A NAME="compiler-message-keys"></A></P><P>Another good practice is to use the most specific possible argument to
<TT>@SuppressWarnings</TT>. The string can be of the form <EM>checkername</EM> or
or <EM>checkername:messagekey</EM>. The <EM>checkername</EM> part is as
described above. The <EM>messagekey</EM> part suppresses only
errors/warnings relating to the given message key. For example,
<TT>cast.unsafe</TT> is the key for warnings about an unsafe cast, and
<TT>cast.redundant</TT> to the key for warnings about a redundant cast.</P><P>Thus, the above example could have been written as:</P><PRE CLASS="verbatim">  @SuppressWarnings("tainting")              // suppresses all tainting-related warnings
  @SuppressWarnings("tainting:cast.unsafe")  // suppresses tainting warnings about unsafe casts
  @SuppressWarnings("tainting:cast")         // suppresses tainting warnings about casts 
</PRE><P>For a list of the message keys, 
see the <TT>messages.properties</TT> files in 
<TT>checker-framework/checkers/src/checkers/</TT><TT><EM>checkername</EM></TT><TT>/messages.properties</TT>.
Each checker is built on the <TT>basetype</TT> checker and inherits its
properties. Thus, to find all the error keys for a checker, you usually
need to examine its own <TT>messages.properties</TT> file and that of
<TT>basetype</TT>.</P><P>If a checker produces a warning/error and you want to determine its message
key, you can re-run the checker, passing the the <TT>-Anomsgtext</TT>
command-line option (Section&#XA0;<A HREF="#debugging-options">22.8</A>).</P><!--TOC subsection <TT>-AskipUses</TT> command-line option-->
<H3 CLASS="subsection"><A NAME="askipuses"><!--SEC ANCHOR -->20.2.2&#XA0;&#XA0;<TT>-AskipUses</TT> command-line option</A></H3><!--SEC END --><P>You can suppress all errors and warnings at all <EM>uses</EM> of a given
class (but the class itself is still type-checked, unless you also use
the <TT>-AskipDefs</TT> command-line option, see&#XA0;<A HREF="#askipdefs">20.2.3</A>).
Set the <TT>-AskipUses</TT> command-line option to a
regular expression that matches class names (not file names) for which warnings and errors
should be suppressed. For example, suppose that you use
&#X201C;<CODE>-AskipUses=^java\.</CODE>&#X201D; on the command line
(with appropriate quoting) when invoking
<TT>javac</TT>. Then the checkers will suppress all warnings related to
classes whose fully-qualified name starts with <CODE>java.</CODE>, such
as all warnings relating to invalid arguments and all warnings relating to
incorrect use of the return value.</P><P>To suppress all errors and warnings related to multiple classes, you can use
the regular expression alternative operator &#X201C;<TT>|</TT>&#X201D;, as in
&#X201C;<CODE>-AskipUses="java\.lang\.|java\.util\."</CODE>&#X201D; to suppress
all warnings related to uses of classes belong to the <TT>java.lang</TT> or
<TT>java.util</TT> packages.</P><!--TOC subsection <TT>-AskipDefs</TT> command-line option-->
<H3 CLASS="subsection"><A NAME="askipdefs"><!--SEC ANCHOR -->20.2.3&#XA0;&#XA0;<TT>-AskipDefs</TT> command-line option</A></H3><!--SEC END --><P>You can suppress all errors and warnings in the <EM>definition</EM> of a given
class (but uses of the class are still type-checked, unless you also use
the <TT>-AskipUses</TT> command-line option, see&#XA0;<A HREF="#askipuses">20.2.2</A>).
Set the <TT>-AskipDefs</TT> command-line option to a
regular expression that matches class names (not file names) in whose definition warnings and errors
should be suppressed. For example, if you use
&#X201C;<CODE>-AskipDefs=^mypackage\.</CODE>&#X201D; on the command line
(with appropriate quoting) when invoking
<TT>javac</TT>, then the definitions of 
classes whose fully-qualified name starts with <CODE>mypackage.</CODE>
will not be checked.</P><P>Another way not to type-check a file is not to pass it on the compiler
command-line: the Checker Framework type-checks only files that are passed
to the compiler on the command line, and does not type-check any file that
is not passed to the compiler. The <TT>-AskipDefs</TT> command-line option
is intended for situations in which the build system is hard to understand
or change. In such a situation, a programmer may find it easier to supply
an extra command-line argument, than to change the set of files that is
compiled.</P><!--TOC subsection <TT>-Alint</TT> command-line option-->
<H3 CLASS="subsection"><A NAME="alint"><!--SEC ANCHOR -->20.2.4&#XA0;&#XA0;<TT>-Alint</TT> command-line option</A></H3><!--SEC END --><P><A NAME="lint-options"></A></P><P>The <TT>-Alint</TT> option enables or disables optional checks, analogously to
javac&#X2019;s <TT>-Xlint</TT> option.
Each of the distributed checkers supports at least the following lint options:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>cast:unsafe</TT> (default: on) warn about unsafe casts that are not
checked at run time, as in <TT>((@NonNull String) myref)</TT>. Such casts
are generally not necessary when flow-sensitive local type refinement is
enabled.</LI><LI CLASS="li-itemize"><TT>cast:redundant</TT> (default: on) warn about redundant
casts that are guaranteed to succeed at run time,
as in <TT>((@NonNull String) "m")</TT>. Such casts are not necessary,
because the target expression of the cast already has the given type
qualifier.</LI><LI CLASS="li-itemize"><TT>cast</TT> Enable or disable all cast-related warnings.</LI><LI CLASS="li-itemize"><TT>all</TT> Enable or disable all lint warnings, including
checker-specific ones if any. Examples include <TT>nulltest</TT> for the
Nullness Checker (see Section&#XA0;<A HREF="#lint-nulltest">1</A>) and <TT>dotequals</TT> for
the Interning Checker (see Section&#XA0;<A HREF="#lint-dotequals">4.3</A>). This option
does not enable/disable the checker&#X2019;s standard checks, just its optional
ones.</LI><LI CLASS="li-itemize"><TT>none</TT> The inverse of <TT>all</TT>: disable or enable all lint warnings,
including checker-specific ones if any.</LI></UL><P>To activate a lint option, write <TT>-Alint=</TT> followed by a
comma-delimited list of check names. If the option is preceded by a
hyphen (<TT>-</TT>), the warning is disabled. For example, to disable all
lint options except redundant casts, you can pass
<TT>-Alint=-all,cast:redundant</TT> on the command line.</P><!--TOC subsection No <TT>-processor</TT> command-line option-->
<H3 CLASS="subsection"><A NAME="no-processor"><!--SEC ANCHOR -->20.2.5&#XA0;&#XA0;No <TT>-processor</TT> command-line option</A></H3><!--SEC END --><P>You can also compile parts of your code without use of the
<TT>-processor</TT> switch to <TT>javac</TT>. No checking is done during
such compilations.</P><!--TOC subsection Checker-specific mechanisms-->
<H3 CLASS="subsection"><A NAME="checker-specific-suppression"><!--SEC ANCHOR -->20.2.6&#XA0;&#XA0;Checker-specific mechanisms</A></H3><!--SEC END --><P>Finally, some checkers have special rules. For example, the Nullness
checker (Chapter&#XA0;<A HREF="#nullness-checker">3</A>) uses <TT>assert</TT> statements that contain
null checks, and the special <TT>castNonNull</TT> method, to suppress warnings
(Section&#XA0;<A HREF="#suppressing-warnings-with-assertions">3.4.1</A>).
This manual also explains special mechanisms for
suppressing warnings issued by the Fenum checker
(Section&#XA0;<A HREF="#fenum-suppressing">8.4</A>) and the Units checker
(Section&#XA0;<A HREF="#units-suppressing">14.5</A>).</P><!--TOC section Backward compatibility with earlier versions of Java-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="backward-compatibility">20.3</A>&#XA0;&#XA0;Backward compatibility with earlier versions of Java</H2><!--SEC END --><P>Sometimes, your code needs to be compiled by people who are not using a
compiler that supports type annotations.
Sections&#XA0;<A HREF="#annotations-in-comments">20.3.1</A>&#X2013;<A HREF="#uncommenting-annotations">20.3.3</A>
discuss this situation, which you can handle by writing annotations in
comments.</P><P>In other cases, your code needs to be run by people who are not using a Java&#XA0;8
JVM. Section&#XA0;<A HREF="#java5-class-files">20.3.4</A> discusses this situation, which
you can handle by passing the <TT>-target 5</TT> command-line argument.</P><P>(<B>Note:</B> These are features of the Type Annotations compiler that is
distributed along with the Checker Framework. They are <EM>not</EM>
supported by the mainline OpenJDK compiler. These features are the key
difference between the Type Annotations compiler and the OpenJDK compiler
on which it is built.)</P><!--TOC subsection Annotations in comments-->
<H3 CLASS="subsection"><A NAME="annotations-in-comments"><!--SEC ANCHOR -->20.3.1&#XA0;&#XA0;Annotations in comments</A></H3><!--SEC END --><P>A Java 4 compiler does not permit use of
annotations, and a Java 5 compiler only permits annotations on
declarations (but not on generic arguments, casts, <TT>extends</TT> clauses, method receiver, etc.).</P><P>So that your code can be compiled by any Java compiler (for any version of
the Java language), you may write any annotation inside a
<TT>/*</TT>&#X2026;<TT>*/</TT> Java comment, as in <TT>List&lt;/*@NonNull*/ String&gt;</TT>.
The Type Annotations compiler treats the code exactly as if you had not written the
<TT>/*</TT> and <TT>*/</TT>.
In other words, the Type Annotations compiler will recognize the
annotation, but your code will still compile with any other Java compiler.</P><P>This feature only works if you provide no <TT>-source</TT> command-line
argument to <TT>javac</TT>, or if the <TT>-source</TT> argument is <TT>1.8</TT>
or <TT>8</TT>.</P><P>In a single program, you may write some annotations in comments, and others
without comments.</P><P>By default, the compiler ignores any comment that contains spaces at the
beginning or end, or between the <TT>@</TT> and the annotation name.
In other words, it reads <TT>/*@NonNull*/</TT> as an annotation but ignores
<TT>/* @NonNull*/</TT> or <TT>/*@ NonNull*/</TT> or <TT>/*@NonNull */</TT>.
This
feature enables backward compatibility with code that contains comments
that start with <TT>@</TT> but are not annotations. (The
ESC/Java&#XA0;[<A HREF="#FlanaganLLNSS02">FLL<SUP>+</SUP>02</A>], JML&#XA0;[<A HREF="#LeavensBR2006:JML">LBR06</A>], and
Splint&#XA0;[<A HREF="#Evans96">Eva96</A>] tools all use &#X201C;<TT>/*@</TT>&#X201D; or &#X201C;<TT>/*&#XA0;@</TT>&#X201D; as a
comment marker.)
Compiler flag
<TT>-XDTA:spacesincomments</TT> causes the compiler to parse annotation comments
even when they contain spaces. You may need to use
<TT>-XDTA:spacesincomments</TT> if you use Eclipse&#X2019;s &#X201C;Source &gt; Correct
Indentation&#X201D; command, since it inserts space in comments. But the
annotation comments are less readable with spaces, so you may wish to disable
inserting spaces: in the Formatter preferences, in the Comments tab,
unselect the &#X201C;enable block comment formatting&#X201D; checkbox.</P><P>There is no way to turn off the annotations in comments feature. If you
don&#X2019;t want this feature, you can use a standard Java 8 compiler that
supports type annotations but not annotations in comments. If your code
already contains comments of the form <TT>/*@...*/</TT> that look like type
annotations, and you want the Type Annotations compiler not to try to
interpret them, then you can add spaces to the comments.</P><P>This mechanism permits annotations to be written in comments, but it does
not permit Java 8&#X2019;s new receiver (&#X201C;<TT>this</TT>&#X201D;) syntax to be written in
comments. That means that it is not generally possible to write
annotations on receivers in a forward-compatible way.</P><!--TOC subsection Implicit import statements-->
<H3 CLASS="subsection"><A NAME="implicit-import-statements"><!--SEC ANCHOR -->20.3.2&#XA0;&#XA0;Implicit import statements</A></H3><!--SEC END --><P>When writing source code with annotations, it is more convenient to write a
short form such as <TT>@NonNull</TT> instead of
<TT>@checkers.nullness.quals.NonNull</TT>. Here are ways to achieve this goal.</P><P><A NAME="jsr308_imports"></A></P><UL CLASS="itemize"><LI CLASS="li-itemize">
The traditional way to do this is to write an import statement like
&#X201C;<TT>import checkers.nullness.quals.*;</TT>&#X201D;. This works, but everyone who
compiles the code (no matter what compiler they use, and even if the
annotations are in comments) must have the annotation definitions (e.g.,
the <TT>checkers.jar</TT> or <TT>checkers-quals.jar</TT> file) on their
classpath. The reason is that a Java compiler issues an error if an
imported package is not on the classpath. See Section&#XA0;<A HREF="#distributing">2.1.1</A>.</LI><LI CLASS="li-itemize">There is no mechanism for the compiler to read import statements written in
comments, as it does for annotations in comments (see
Section&#XA0;<A HREF="#annotations-in-comments">20.3.1</A>).
</LI><LI CLASS="li-itemize">An alternative is to set the shell environment variable
<TT>jsr308_imports</TT> when you compile the code.
The Type Annotations compiler treats this as if the given packages/classes were
imported, but other compilers
ignore the
<TT>jsr308_imports</TT> environment variable &#X2014; they do not need it, since
they do not support annotations in comments. Thus, your code can compile
whether or not the Type Annotations compiler is being used.<P>You can specify multiple packages/classes separated by the classpath separator
(same as the file path separator: <TT>;</TT> for Windows, and <TT>:</TT> for Unix and
Mac). For example, to implicitly import the Nullness and Interning
qualifiers, set <TT>jsr308_imports</TT> to
<TT>checkers.nullness.quals.*:checkers.interning.quals.*</TT>.</P><P>Three ways to set an environment variable are:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Set the environment variable in your shell. For example, in bash, you
could do <TT>export jsr308_imports=&#X2019;checkers.nullness.quals.*&#X2019;</TT>.
This takes effect for all subsequent commands in that shell. To take
effect for all shells that you run, put the command in your
<CODE>~/.bashrc</CODE> file.
</LI><LI CLASS="li-itemize">Set the environment variable for a single command. For example, in bash
prefix the <TT>javac</TT> command by
<TT>jsr308_imports=&#X2019;checkers.nullness.quals.*&#X2019;</TT>.
</LI><LI CLASS="li-itemize">Set the environment variable for a single comamnd, via a <TT>javac</TT>
argument. Use the <TT>javac</TT> command-line argument
<TT>-J-Djsr308_imports=&#X2019;checkers.nullness.quals.*&#X2019;</TT>.
</LI></UL><P>If you issue the javac command from the command line or in a Makefile, you
may need to add quotes (as shown above), to prevent your shell from
expanding the <TT>*</TT> character.
If you supply the <TT>-J-Djsr308_imports</TT> argument via an Ant buildfile,
you do not need the extra quoting.</P></LI><LI CLASS="li-itemize">If it is not possible to set the environment variable (for example, Maven
bug <A HREF="http://jira.codehaus.org/browse/PLXCOMP-190">PLXCOMP-190</A>
makes it impossible to use the <TT>-J-Djsr308_imports</TT> command-line
argument), you can instead use a different javac command-line argument:
<TT>-jsr308_imports ...</TT> or <TT>-Djsr308.imports=...</TT> (they have the
same effect). The same syntax for the packages/classes, and the same
warnings about quoting from the command line, apply as for the
<TT>jsr308_imports</TT> environment variable.</LI></UL><!--TOC subsection Migrating away from annotations in comments-->
<H3 CLASS="subsection"><A NAME="uncommenting-annotations"><!--SEC ANCHOR -->20.3.3&#XA0;&#XA0;Migrating away from annotations in comments</A></H3><!--SEC END --><P>Suppose that your codebase currently uses annotations in comments, but you
wish to remove the comment characters around your annotations, because in
the future you will use only compilers that support type annotations.
This Unix command removes
the comment characters, for all Java files in the current
working directory or any subdirectory.</P><PRE CLASS="verbatim">   find . -type f -name '*.java' -print \
     | xargs grep -l -P '/\*\s*@([^ */]+)\s*\*/' \
     | xargs perl -pi.bak -e 's|/\*\s*@([^ */]+)\s*\*/|@\1|g'
</PRE><P>You can customize this command:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
To process comments with embedded spaces and asterisks, change
two instances of &#X201C;<CODE>[^ */]</CODE>&#X201D; to &#X201C;<CODE>[^/]</CODE>&#X201D;.
</LI><LI CLASS="li-itemize">To ignore comments with leading or trailing spaces, remove the four
instances of &#X201C;<CODE>\s*</CODE>&#X201D;.
</LI><LI CLASS="li-itemize">To not make backups, remove &#X201C;<CODE>.bak</CODE>&#X201D;.
</LI></UL><P>If your code used implicit import statements
(Section&#XA0;<A HREF="#implicit-import-statements">20.3.2</A>), then after uncommenting the
annotations, you may also need to introduce
explicit import statements into your code.</P><!--TOC subsection Annotations in Java 5 <TT>.class</TT> files-->
<H3 CLASS="subsection"><A NAME="java5-class-files"><!--SEC ANCHOR -->20.3.4&#XA0;&#XA0;Annotations in Java 5 <TT>.class</TT> files</A></H3><!--SEC END --><P>If you supply the <TT>-target 5</TT> command-line argument along with no
<TT>-source</TT> argument (or <TT>-source 8</TT>, which is equivalent), then the
Type Annotations compiler creates a <TT>.class</TT> file that can be run on a
Java 5 JVM, but that contains the type annotations. (It does not matter
whether the type annotations were written in comments or not.) The fact
that the <TT>.class</TT> file contains the type annotations is useful when
type-checking client code. If you try to type-check client code against a
library that lacks type annotations, then spurious warnings can result.
So, use of <TT>-target 5</TT> gives backward compatibility with earlier JVMs
while still permitting pluggable type-checking.</P><P>Ordinary Java compilers do not let you use a <TT>-target</TT> command-line
argument with a value less than the <TT>-source</TT> argument.</P><P>Use of the <TT>-source 5</TT> command-line argument produces a <TT>.class</TT>
file that does not contain type annotations. One reason you might want to
periodically compile with the <TT>-source 5</TT> argument is to ensure that
your code does not use any Java 8 features other than type annotations in
comments.</P><HR><!--TOC chapter Annotating libraries-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="annotating-libraries">Chapter&#XA0;21</A>&#XA0;&#XA0;Annotating libraries</H1><!--SEC END --><P>When annotated code uses an unannotated library, a checker may issue warnings.
As described in Section&#XA0;<A HREF="#unannotated-code">20.1</A>, the best way to correct
this problem is to add annotations to the library. (Alternately, you can instead
suppress all warnings related to an unannotated library by use of the
<TT>-AskipUses</TT> command-line option; see
Section&#XA0;<A HREF="#suppressing-warnings">20.2</A>.) If you have source code for the
library, you can easily add the annotations.
This chapter tells you
how to add annotations to a library for which you have no source code,
because the library is distributed only in binary form
(as <TT>.class</TT> files, possibly packaged in a <TT>.jar</TT> file).
This chapter is also useful if you do not wish to edit the
library&#X2019;s source code.</P><P>You can make the annotations known to the checkers in two ways.</P><UL CLASS="itemize"><LI CLASS="li-itemize">You can write annotations in a &#X201C;stub
file&#X201D; containing classes with no method bodies.
Section&#XA0;<A HREF="#stub">21.2</A> describes how to create and use stub files.</LI><LI CLASS="li-itemize">You can insert annotations in the compiled
<TT>.class</TT> files of the library.
You would express the annotations textually, typically as an annotation index file, and
then insert them in the library by using the Annotation File Utilities
(<A HREF="http://types.cs.washington.edu/annotation-file-utilities/"><TT>http://types.cs.washington.edu/annotation-file-utilities/</TT></A>).
See the Annotation File Utilities documentation for full details.</LI></UL><P>The Checker Framework distribution contains annotations for popular
libraries, such as the JDK. It uses both of the above mechanisms. The
Nullness, Javari, IGJ, and Interning Checkers use an annotated JDK
(Section&#XA0;<A HREF="#skeleton">21.3</A>), and all other checkers use stub files
(Section&#XA0;<A HREF="#stub">21.2</A>).</P><P>If you annotate additional libraries, please share them with us so that we
can distribute the annotations with the Checker Framework; see
Section&#XA0;<A HREF="#reporting-bugs">25.2</A>.
You can determine the correct annotations for a library either
automatically by running an inference tool, or manually by reading the
documentation. Presently, type inference tools are available for the
Nullness (Section&#XA0;<A HREF="#nullness-inference">3.3.4</A>) and Javari
(Section&#XA0;<A HREF="#javari-inference">6.2.2</A>) type systems.</P><!--TOC section Choosing between stub files and annotated <TT>.class</TT> files-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="stub-vs-class-files">21.1</A>&#XA0;&#XA0;Choosing between stub files and annotated <TT>.class</TT> files</H2><!--SEC END --><P>A checker can read annotations either from a stub file or from a library&#X2019;s
<TT>.class</TT> files. This section helps you choose between the two alternatives.</P><P>Once created, a stub file can be used directly; this makes it an easy way
to get started with library annotations.
When provided by the author of the checker, a stub file is used
automatically, with no need for the user to supply a command-line option.</P><P>Inserting annotations in a library&#X2019;s <TT>.class</TT> files takes an extra step
using an external tool, the Annotation File Utilities
(<A HREF="http://types.cs.washington.edu/annotation-file-utilities/"><TT>http://types.cs.washington.edu/annotation-file-utilities/</TT></A>).
However, this process does not suffer the limitations of stub files
(Section&#XA0;<A HREF="#stub-limitations">21.2.4</A>).</P><!--TOC section Using stub classes-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="stub-creating-and-using">21.2</A>&#XA0;&#XA0;Using stub classes<A NAME="stub"></A></H2><!--SEC END --><P>A stub file contains &#X201C;stub classes&#X201D; that contain annotated signatures,
but no method bodies. A
checker uses the annotated signatures at compile time, instead of or in
addition to annotations that appear in the library.</P><P>Section&#XA0;<A HREF="#stub-creating">21.2.1</A> describes how to create stub classes.
Section&#XA0;<A HREF="#stub-using">21.2.2</A> describes how to use stub classes.
These sections illustrate stub classes via the example of creating a <TT>@</TT><A HREF="doc/checkers/interning/quals/Interned.html"><TT>Interned</TT></A>-annotated
version of <TT>java.lang.String</TT>. You don&#X2019;t need to repeat these steps
to handle <TT>java.lang.String</TT> for the Interning Checker,
but you might do something similar for a different class and/or checker.</P><!--TOC subsection Creating a stub file-->
<H3 CLASS="subsection"><A NAME="stub-creating"><!--SEC ANCHOR -->21.2.1&#XA0;&#XA0;Creating a stub file</A></H3><!--SEC END --><!--TOC subsubsection If you have access to the Java source code-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->If you have access to the Java source code</H4><!--SEC END --><P>Every Java file is a stub file. If you have access to the Java file, then
you can use the Java file as the stub file, without removing
any of the parts that the stub file format permits you to. Just add
annotations to the signatures, leaving the method bodies unchanged.
Optionally (but highly recommended!), run the type-checker to verify that
your annotations are correct. When you run the type-checker on your
annotations, there should not be any stub file that also contains
annotations for the class. In particular, if you are type-checking the JDK
itself, then you should use the <TT>-Aignorejdkastub</TT> command-line option.</P><P>This approach retains the original
documentation and source code, making it easier for a programmer to
double-check the annotations. It also enables creation of diffs, easing
the process of upgrading when a library adds new methods. And, the
annotations are in a format that the library maintainers can even
incorporate.</P><P>The downside of this approach is that the stub files are larger. This can
slow down parsing. Furthermore, a programmer must search the stub file
for a given method rather than just skimming a few pages of method signatures.</P><!--TOC subsubsection If you do not have access to the Java source code-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->If you do not have access to the Java source code</H4><!--SEC END --><P>If you do not have access to the library source code, then you can create a
stub file from the class file (Section&#XA0;<A HREF="#stub-creating">21.2.1</A>),
and then annotate it. The rest of this section describes this approach.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Create a stub file by running the stub class generator. (<TT>checkers.jar</TT>
must be on your classpath.)<PRE CLASS="verbatim">  cd nullness-stub
  java checkers.util.stub.StubGenerator java.lang.String &gt; String.astub
</PRE><P>Supply it with the fully-qualified name of the class for which you wish to
generate a stub class. The stub class generator prints the
stub class to standard out, so you may wish to redirect its output to a
file.</P></LI><LI CLASS="li-enumerate">Add import statements for the annotations. So you would need to
add the following import statement at the beginning of the file:<PRE CLASS="verbatim">  import checkers.interning.quals.*;
</PRE><P>The stub file parser silently ignores any annotations that it cannot
resolve to a type, so don&#X2019;t forget the import statement.</P></LI><LI CLASS="li-enumerate">Add annotations to the stub class. For example, you might annotate
the <A HREF="http://docs.oracle.com/javase/7/docs/api/java/lang/String.html#intern()"><TT>String.intern()</TT></A> method as follows:<PRE CLASS="verbatim">  @Interned String intern();
</PRE><P>You may also remove irrelevant parts of the stub file; see
Section&#XA0;<A HREF="#stub-format">21.2.3</A>.</P></LI></OL><!--TOC subsection Using a stub file-->
<H3 CLASS="subsection"><A NAME="stub-using"><!--SEC ANCHOR -->21.2.2&#XA0;&#XA0;Using a stub file</A></H3><!--SEC END --><P>The <TT>-Astubs</TT> argument causes the Checker Framework to read
annotations from annotated stub classes in preference to the unannotated
original library classes. For example:</P><PRE CLASS="verbatim">  javac -processor checkers.interning.InterningChecker -Astubs=String.astub:stubs MyFile.java MyOtherFile.java ...
</PRE><P>Each stub path entry is a file or a directory; specifying a directory is
equivalent to specifying every file in it whose name ends with
<TT>.astub</TT>. The stub path entries are delimited by
<TT>File.pathSeparator</TT> (&#X2018;<TT>:</TT>&#X2019; for Linux and Mac, &#X2018;<TT>;</TT>&#X2019; for Windows).</P><P>A checker automatically reads the stub file <TT>jdk.astub</TT>. (The checker
author should place it in the same directory as the Checker class, i.e.,
the subclass of <TT>BaseTypeVisitor</TT>.) Programmers should only use the
<TT>-Astubs</TT> argument for additional stub files they create themselves.</P><!--TOC subsection Stub file format-->
<H3 CLASS="subsection"><A NAME="stub-format"><!--SEC ANCHOR -->21.2.3&#XA0;&#XA0;Stub file format</A></H3><!--SEC END --><P>Every Java file is a valid stub file. However, you can omit information
that is not relevant to pluggable type-checking; this makes the stub file
smaller and easier for people to read and write.</P><P>As an illustration, a stub file for the Interning type system
(Chapter&#XA0;<A HREF="#interning-checker">4</A>) could be:</P><PRE CLASS="verbatim">  import checkers.interning.quals.Interned;
  package java.lang;
  @Interned class Class&lt;T&gt; { }
  class String {
    @Interned String intern();
  }
</PRE><P>The stub file format is allowed to differ from Java source code in the
following ways:
</P><DL CLASS="description"><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><B>Method bodies:</B>
The stub class does not require method bodies for classes; any method
body may be replaced by a semicolon (<TT>;</TT>), as in an interface or
abstract method declaration.</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><B>Method declarations:</B>
You only have to specify the methods that you need to annotate.
Any method declaration may be omitted, in which case the checker reads
its annotations from library&#X2019;s <TT>.class</TT> files. (If you are using a stub class, then
typically the library is unannotated.)</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><B>Declaration specifiers:</B>
Declaration specifiers (e.g., <TT>public</TT>, <TT>final</TT>, <TT>volatile</TT>)
may be omitted.</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><B>Import statements:</B>
The only required import statements are the ones to import type
annotations. Such imports must be at the beginning of the
file. Other import statements are optional.</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><B>Multiple classes and packages:</B>
The stub file format permits having multiple classes and packages.
The packages are separated by a package statement:
<TT>package my.package;</TT>. Each package declaration may occur only once; in
other words, all classes from a package must appear together.</DD></DL><!--TOC subsection Limitations-->
<H3 CLASS="subsection"><A NAME="stub-limitations"><!--SEC ANCHOR -->21.2.4&#XA0;&#XA0;Limitations</A></H3><!--SEC END --><P>The stub file reader has several limitations:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
It does not handle <TT>enum</TT>s.
</LI><LI CLASS="li-itemize">It does not handle nested classes. To work around this, it permits a
top-level class to be written with a <TT>$</TT> in its name, and applies the
annotations to the appropriate nested class.
</LI></UL><P>If these limitations are a problem, then you should insert annotations
in the library&#X2019;s <TT>.class</TT> files instead.</P><!--TOC section Using distributed annotated JDKs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="skeleton">21.3</A>&#XA0;&#XA0;Using distributed annotated JDKs<A NAME="skeleton-using"></A></H2><!--SEC END --><P>The Checker Framework distribution contains
annotated JDKs at the path <TT>checkers/jdk/jdk.jar</TT>.
The <TT>javac</TT> that is distributed with the Checker Framework uses the
annotated JDKs by default.</P><P>If you use a different <TT>javac</TT>, then you must add a
<TT>-Xbootclasspath/p:</TT> argument, which causes the compiler to read
annotations from annotated JDK classes in preference to the unannotated
original library classes. Supply <TT>-Xbootclasspath/p:</TT> in addition to
whatever other arguments you usually use, including <TT>-classpath</TT>. For example:</P><PRE CLASS="verbatim">  javac -processor checkers.nullness.NullnessChecker -Xbootclasspath/p:${CHECKERS}/jdk/jdk.jar my_source_files
</PRE><P>If you do not supply the <TT>-Xbootclasspath/p:</TT> option, the checker will
print a message warning you to do so. In the unlikely event that you want
to suppress this warning, use <TT>-Anocheckjdk</TT>.</P><P>The annotated JDK should <EM>not</EM> be in your classpath at run time, only
at compile time.</P><P>The supplied annotated JDK is a version of JDK 6. If you wish to have an
annotated version of JDK 7, you will need to create it yourself. Running
<TT>ant jdk.jar</TT> from the <TT>checkers/</TT> directory will perform this process.</P><!--TOC section Troubleshooting/debugging annotated libraries-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="libraries-troubleshooting">21.4</A>&#XA0;&#XA0;Troubleshooting/debugging annotated libraries</H2><!--SEC END --><P>Sometimes, it may seem that a checker is treating a library as unannotated
even though the library has annotations. The compiler has two flags that
may help you in determining whether library files are read, and if they are
read whether the library&#X2019;s annotations are parsed.</P><DL CLASS="description"><DT CLASS="dt-description">
</DT><DD CLASS="dd-description"><TT>-verbose</TT>
Outputs info about compile phases &#X2014; when the compiler
reads/parses/attributes/writes any file. Also outputs the classpath and
sourcepath paths.
</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><TT>-XDTA:parser</TT> (which is equivalent to <TT>-XDTA:reader</TT> plus <TT>-XDTA:writer</TT>)
Sets the internal <TT>debugJSR308</TT> flag, which output information about
reading and writing.
</DD></DL><HR><!--TOC chapter How to create a new checker-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="writing-a-checker">Chapter&#XA0;22</A>&#XA0;&#XA0;How to create a new checker</H1><!--SEC END --><P>This chapter describes how to create a checker
&#X2014; a type-checking compiler plugin that detects bugs or verifies their
absence. After a programmer annotates a program,
the checker plugin verifies that the code is consistent
with the annotations.
If you only want to <EM>use</EM> a checker, you do not need to read this
chapter.</P><P>Writing a simple checker is easy! For example, here is a complete, useful
type checker:</P><PRE CLASS="verbatim">@TypeQualifier
@SubtypeOf(Unqualified.class)
@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
public @interface Encrypted {}
</PRE><P>This checker is so short because it builds on the Basic Checker
(Chapter&#XA0;<A HREF="#basic-checker">15</A>).
See Section&#XA0;<A HREF="#basic-example">15.2</A> for more details about this particular checker.
When you wish to create a new checker, it is often easiest to begin by
building it declaratively on top of the Basic Checker, and then return to
this chapter when you need more expressiveness or power than the Basic
Checker affords.</P><P>You can also create your own checker by customizing a different existing
checker. Specific checkers that are designed for extension (besides the Basic
Checker) include the Fake Enumeration Checker
(Chapter&#XA0;<A HREF="#fenum-checker">8</A>), the Units Checker
(Chapter&#XA0;<A HREF="#units-checker">14</A>), and the typestate checkers
(Chapter&#XA0;<A HREF="#typestate-checker">16</A>).
Or, you can copy and then modify a different existing checker &#X2014; whether
one distributed with the Checker Framework or a third-party one.</P><P>You can place your checker&#X2019;s source files wherever you like. When you
compile your checker, <TT>$CHECKERS/binary/jsr308-all.jar</TT> should be on your
classpath. (If you wish to modify an existing checker in place, or to
place the source code for your new checker in your own private copy of the
Checker Framework source code, then you need to be able to re-compile the
Checker Framework, as described in Section&#XA0;<A HREF="#build-source">25.3</A>.)</P><P>The rest of this chapter contains many details for people who want to write more powerful
checkers.
You do not need all of the details, at least at first.
In addition to reading this chapter of the manual, you may find it helpful
to examine the implementations of the checkers that are distributed with
the Checker Framework. You can even create your checker by modifying one
of those.
The Javadoc documentation of the framework and the checkers is in the
distribution and is also available online at
<A HREF="http://types.cs.washington.edu/checker-framework/current/doc/"><TT>http://types.cs.washington.edu/checker-framework/current/doc/</TT></A>.</P><P>If you write a new checker and wish to advertise it to the world, let us
know so we can mention it in the Checker Framework manual, link to
it from the webpages, or include it in the Checker Framework distribution.
For examples, see Chapters&#XA0;<A HREF="#typestate-checker">16</A>
and&#XA0;<A HREF="#third-party-checkers">17</A>.</P><!--TOC section Relationship of the Checker Framework to other tools-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="tool-relationships">22.1</A>&#XA0;&#XA0;Relationship of the Checker Framework to other tools</H2><!--SEC END --><P>This table shows the relationship among various tools.
All of the tools use the Type Annotations (JSR 308) syntax.
You use the Checker Framework to build pluggable type systems, and the
Annotation File Utilities to manipulate <TT>.java</TT> and <TT>.class</TT> files.</P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">Basic </DIV><P>Checker</P></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Nullness </DIV><P>Checker</P></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Mutation </DIV><P>Checker</P></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Tainting </DIV><P>Checker</P></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">&#X2026;</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Your </DIV><P>Checker</P></TD><TD ALIGN=center NOWRAP COLSPAN=2>&nbsp;</TD></TR>
<TR><TD VALIGN=top ALIGN=left COLSPAN=6><DIV CLASS="center">Base Checker </DIV><P>(enforces subtyping rules)</P></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Type </DIV><P>inference</P></TD><TD VALIGN=top ALIGN=left>Other <P>tools</P></TD></TR>
<TR><TD VALIGN=top ALIGN=left COLSPAN=6><DIV CLASS="center">Checker Framework </DIV><P>(enables creation of pluggable type-checkers)</P></TD><TD VALIGN=top ALIGN=left COLSPAN=2><DIV CLASS="center"><A HREF="http://types.cs.washington.edu/annotation-file-utilities/">Annotation File Utilities</A> </DIV><P>(<TT>.java</TT> &#X2194; <TT>.class</TT> files)</P></TD></TR>
<TR><TD VALIGN=top ALIGN=left COLSPAN=8><DIV CLASS="center"><A HREF="http://types.cs.washington.edu/jsr308/">Type Annotations</A> syntax
and classfile format (&#X201C;JSR 308&#X201D;) </DIV><P>(no built-in semantics)</P></TD></TR>
</TABLE>
</DIV><P>The Base Checker enforces the standard subtyping rules on extended types.
The Basic Checker is a simple use of the Base Checker that supports
providing type qualifiers on the command line.
You usually want to build your checker on the Base Checker.</P><!--TOC section The parts of a checker-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="parts-of-a-checker">22.2</A>&#XA0;&#XA0;The parts of a checker</H2><!--SEC END --><P>The Checker Framework provides abstract base classes (default
implementations), and a specific checker overrides as little or as much of
the default implementations as necessary.
Sections&#XA0;<A HREF="#writing-typequals">22.3</A>&#X2013;<A HREF="#writing-compiler-interface">22.6</A> describe
the components of a type system as written using the Checker Framework:</P><DL CLASS="description"><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><A HREF="#writing-typequals">22.3</A>
<B>Type qualifiers and hierarchy.</B> You define the annotations for
the type system and the subtyping relationships among qualified types
(for instance, that <TT>@NonNull Object</TT> is a subtype of <TT>@Nullable
Object</TT>).</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><A HREF="#writing-type-introduction">22.4</A>
<B>Type introduction rules.</B> For some types and
expressions, a qualifier should be treated as implicitly present even if a
programmer did not explicitly write it. For example, in the Nullness
type system every literal
other than <TT>null</TT> has a <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type;
examples of literals include <TT>"some string"</TT> and <TT>java.util.Date.class</TT>.</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><A HREF="#extending-visitor">22.5</A>
<B>Type rules.</B> You specify the type system semantics (type
rules), violation of which yields a type error. There are two types of
rules.
<UL CLASS="itemize"><LI CLASS="li-itemize">
Subtyping rules related to the type hierarchy, such as that every
assignment and pseudo-assignment satisfies a subtyping relationship.
Your checker automatically inherits these subtyping rules from the Base
Checker (Chapter&#XA0;<A HREF="#basic-checker">15</A>).
</LI><LI CLASS="li-itemize">Additional rules that are specific to your particular checker. For
example, in the Nullness type system, only references with a
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type may be dereferenced. You
write these additional rules yourself.
</LI></UL></DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><A HREF="#writing-compiler-interface">22.6</A>
<B>Interface to the compiler.</B> The compiler interface indicates
which annotations are part of the type system, which command-line options
and <TT>@SuppressWarnings</TT> annotations the checker recognizes, etc.
</DD></DL><!--TOC section Annotations: Type qualifiers and hierarchy-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-typequals">22.3</A>&#XA0;&#XA0;Annotations: Type qualifiers and hierarchy</H2><!--SEC END --><P>A type system designer specifies the qualifiers in the type system and
the type hierarchy that relates them.</P><P>Type qualifiers are defined as Java annotations&#XA0;[<A HREF="#JSR269">Dar06</A>]. In Java, an
annotation is defined using the Java <TT>@interface</TT> keyword.
For example:</P><PRE CLASS="verbatim">  // Define an annotation for the @NonNull type qualifier.
  @TypeQualifier
  @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
  public @interface NonNull { }
</PRE><P>Write the <TT>@</TT><A HREF="doc/checkers/quals/TypeQualifier.html"><TT>TypeQualifier</TT></A> meta-annotation on the annotation definition
to indicate that the annotation represents a type qualifier
and should be processed by the checker.
Also write a <TT>@</TT><A HREF="http://docs.oracle.com/javase/7/docs/api/java/lang/annotation/Target.html"><TT>Target</TT></A>
meta-annotation to indicate where the annotation may be written.
(An annotation that is written on an annotation
definition, such as <TT>@</TT><A HREF="doc/checkers/quals/TypeQualifier.html"><TT>TypeQualifier</TT></A>, is called a <EM>meta-annotation</EM>.)</P><P>The type hierarchy induced by the qualifiers can be defined either
declaratively via meta-annotations (Section&#XA0;<A HREF="#declarative-hierarchy">22.3.1</A>), or procedurally through
subclassing <A HREF="doc/checkers/types/QualifierHierarchy.html"><TT>QualifierHierarchy</TT></A> or
<A HREF="doc/checkers/types/TypeHierarchy.html"><TT>TypeHierarchy</TT></A> (Section&#XA0;<A HREF="#procedural-hierarchy">22.3.2</A>).</P><!--TOC subsection Declaratively defining the qualifier and type hierarchy-->
<H3 CLASS="subsection"><A NAME="declarative-hierarchy"><!--SEC ANCHOR -->22.3.1&#XA0;&#XA0;Declaratively defining the qualifier and type hierarchy</A></H3><!--SEC END --><P>Declaratively, the type system designer uses two meta-annotations (written
on the declaration of qualifier annotations) to specify the qualifier
hierarchy.</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/quals/SubtypeOf.html"><TT>SubtypeOf</TT></A> denotes that a qualifier is a subtype of
another qualifier or qualifiers, specified as an array of class
literals. For example, for any type <I>T</I>,
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> <I>T</I> is a subtype of <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A> <I>T</I>:<PRE CLASS="verbatim">    @TypeQualifier
    @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
    @SubtypeOf( { Nullable.class } )
    public @interface NonNull { }
  </PRE><P><TT>@</TT><A HREF="doc/checkers/quals/SubtypeOf.html"><TT>SubtypeOf</TT></A> accepts multiple annotation classes as an argument,
permitting the type hierarchy to be an arbitrary DAG. For example,
in the IGJ type system (Section&#XA0;<A HREF="#igj-annotations">5.2</A>), <TT>@</TT><A HREF="doc/checkers/igj/quals/Mutable.html"><TT>Mutable</TT></A>
and <TT>@</TT><A HREF="doc/checkers/igj/quals/Immutable.html"><TT>Immutable</TT></A> induce two mutually exclusive subtypes of the
<TT>@</TT><A HREF="doc/checkers/igj/quals/ReadOnly.html"><TT>ReadOnly</TT></A> qualifier.
</P><P>All type qualifiers, except for polymorphic qualifiers (see below and
also Section&#XA0;<A HREF="#qualifier-polymorphism">18.2</A>), need to be
properly annotated with <A HREF="doc/checkers/quals/SubtypeOf.html"><TT>SubtypeOf</TT></A>.</P><P>The root qualifier should be annotated with
<TT>@SubtypeOf( { } )</TT>. The root qualifier is the qualifier that is
a supertype of all other qualifiers. For example, <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>
is the root of the Nullness type system, hence is defined as:</P><PRE CLASS="verbatim">    @TypeQualifier
    @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
    @SubtypeOf( { } )
    public @interface Nullable { }
  </PRE><P>If the root of the hierarchy is the unqualified type, then its children
will use <TT>@SubtypeOf(Unqualified.class)</TT>, but no <TT>@SubtypeOf(
{ } )</TT> annotation on the root is necessary. For an example, see the
<TT>Encrypted</TT> type system of Section&#XA0;<A HREF="#encrypted-example">15.2</A>.</P></LI><LI CLASS="li-itemize"><TT>@</TT><A HREF="doc/checkers/quals/PolymorphicQualifier.html"><TT>PolymorphicQualifier</TT></A> denotes that a qualifier is a
polymorphic qualifier. For example:<PRE CLASS="verbatim">    @TypeQualifier
    @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
    @PolymorphicQualifier
    public @interface PolyNull { }
  </PRE><P>For a description of polymorphic qualifiers, see
Section&#XA0;<A HREF="#qualifier-polymorphism">18.2</A>. A polymorphic qualifier needs
no <TT>@</TT><A HREF="doc/checkers/quals/SubtypeOf.html"><TT>SubtypeOf</TT></A> meta-annotation and need not be
mentioned in any other <TT>@</TT><A HREF="doc/checkers/quals/SubtypeOf.html"><TT>SubtypeOf</TT></A>
meta-annotation.</P></LI></UL><P>The declarative and procedural mechanisms for specifying the hierarchy can
be used together. In particular, when using the <TT>@</TT><A HREF="doc/checkers/quals/SubtypeOf.html"><TT>SubtypeOf</TT></A>
meta-annotation, further customizations may be
performed procedurally (Section&#XA0;<A HREF="#procedural-hierarchy">22.3.2</A>)
by overriding the <A HREF="doc/checkers/basetype/BaseTypeChecker.html#isSubtype(checkers.types.AnnotatedTypeMirror,%20checkers.types.AnnotatedTypeMirror)"><TT>isSubtype</TT></A> method in the checker class
(Section&#XA0;<A HREF="#writing-compiler-interface">22.6</A>).
However, the declarative mechanism is sufficient for most type systems.</P><!--TOC subsection Procedurally defining the qualifier and type hierarchy-->
<H3 CLASS="subsection"><A NAME="procedural-hierarchy"><!--SEC ANCHOR -->22.3.2&#XA0;&#XA0;Procedurally defining the qualifier and type hierarchy</A></H3><!--SEC END --><P>While the declarative syntax suffices for many cases, more complex
type hierarchies can be expressed by overriding, in <A HREF="doc/checkers/basetype/BaseTypeChecker.html"><TT>BaseTypeChecker</TT></A>,
either <A HREF="doc/checkers/basetype/BaseTypeChecker.html#createQualifierHierarchy()"><TT>createQualifierHierarchy</TT></A> or <A HREF="doc/checkers/basetype/BaseTypeChecker.html#createTypeHierarchy()"><TT>createTypeHierarchy</TT></A> (typically
only one of these needs to be overridden).
For more details, see the Javadoc of those methods and of the classes
<A HREF="doc/checkers/types/QualifierHierarchy.html"><TT>QualifierHierarchy</TT></A> and <A HREF="doc/checkers/types/TypeHierarchy.html"><TT>TypeHierarchy</TT></A>.</P><P>The <A HREF="doc/checkers/types/QualifierHierarchy.html"><TT>QualifierHierarchy</TT></A> class represents the qualifier hierarchy (not the
type hierarchy), e.g., <A HREF="doc/checkers/igj/quals/Mutable.html"><TT>Mutable</TT></A>
is a subtype of <A HREF="doc/checkers/igj/quals/ReadOnly.html"><TT>ReadOnly</TT></A>. A type-system designer may subclass
<A HREF="doc/checkers/types/QualifierHierarchy.html"><TT>QualifierHierarchy</TT></A> to express customized qualifier
relationships (e.g., relationships based on annotation
arguments).</P><P>The <A HREF="doc/checkers/types/TypeHierarchy.html"><TT>TypeHierarchy</TT></A> class represents the type hierarchy &#X2014;
that is, relationships between
annotated types, rather than merely type qualifiers, e.g., <TT>@Mutable
Date</TT> is a subtype of <TT>@ReadOnly Date</TT>. The default <A HREF="doc/checkers/types/TypeHierarchy.html"><TT>TypeHierarchy</TT></A> uses
<A HREF="doc/checkers/types/QualifierHierarchy.html"><TT>QualifierHierarchy</TT></A> to determine all subtyping relationships.
The default <A HREF="doc/checkers/types/TypeHierarchy.html"><TT>TypeHierarchy</TT></A> handles
generic type arguments, array components, type variables, and
wildcards in a similar manner to the Java standard subtype
relationship but with taking qualifiers into consideration. Some type
systems may need to override that behavior. For instance, the Java
Language Specification specifies that two generic types are subtypes only
if their type arguments are identical: for example,
<TT>List&lt;Date&gt;</TT> is not a subtype of <TT>List&lt;Object&gt;</TT>, or of any other
generic <TT>List</TT>.
(In the technical jargon, the generic arguments are &#X201C;invariant&#X201D; or &#X201C;novariant&#X201D;.)
The Javari type system overrides this
behavior to allow some type arguments to change covariantly in a type-safe
manner (e.g.,
<TT>List&lt;@Mutable Date&gt;</TT> is a subtype of <TT>List&lt;@QReadOnly Date&gt;</TT>).</P><!--TOC subsection Defining a default annotation-->
<H3 CLASS="subsection"><A NAME="typesystem-defaults"><!--SEC ANCHOR -->22.3.3&#XA0;&#XA0;Defining a default annotation</A></H3><!--SEC END --><P>A type system designer may set a default annotation. A user may override
the default; see Section&#XA0;<A HREF="#defaults">19.1.1</A>.</P><P>The type system designer may specify a default annotation declaratively,
using the <TT>@</TT><A HREF="doc/checkers/quals/DefaultQualifierInHierarchy.html"><TT>DefaultQualifierInHierarchy</TT></A>
meta-annotation.
Note that the default will apply to any source code that the checker reads,
including stub libraries, but will not apply to compiled <TT>.class</TT>
files that the checker reads.</P><P>Alternately, the type system designer may specify a default procedurally,
by calling the
<A HREF="doc/checkers/util/QualifierDefaults.html#addAbsoluteDefault(javax.lang.model.element.AnnotationMirror,%20java.util.Set)"><TT>QualifierDefaults.addAbsoluteDefault</TT></A>
method. You may do this even if you have declaratively defined the
qualifier hierarchy; see the Nullness checker&#X2019;s implementation for an
example.</P><P>Recall that defaults are distinct
from implicit annotations; see Sections&#XA0;<A HREF="#effective-qualifier">19.1</A>
and&#XA0;<A HREF="#writing-type-introduction">22.4</A>.</P><!--TOC subsection Completeness of the type hierarchy-->
<H3 CLASS="subsection"><A NAME="top-qualifier"><!--SEC ANCHOR -->22.3.4&#XA0;&#XA0;Completeness of the type hierarchy<A NAME="bottom-qualifier"></A></A></H3><!--SEC END --><!--TOC paragraph Bottom qualifier-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Bottom qualifier</H5><!--SEC END --><P>
It is usually a good idea to have a bottom qualifier in your type hierarchy
&#X2014; a qualifier that is a (direct or indirect) subtype of every other
qualifier. For instance, the hierarchy of Figure&#XA0;<A HREF="#fig:igj-hierarchy">5.1</A> lacks
a bottom qualifier, because there is no qualifier that is a subtype of both
<TT>@Immutable</TT> and <TT>@Mutable</TT>.
The bottom qualifier is the natural type for the <TT>null</TT>
value, which can be viewed as having any type at all. Without a bottom
qualifier, type-checking becomes less precise.
Users should never write the bottom qualifier explicitly; it is merely used
for the <TT>null</TT> value.</P><P>The actual IGJ hierarchy does contain a (non-user-visible) bottom qualifier,
defined like this:</P><PRE CLASS="verbatim">  @TypeQualifier
  @SubtypeOf({Mutable.class, Immutable.class, I.class})
  @Target({}) // forbids a programmer from writing it in a program
  @ImplicitFor(trees = { Kind.NULL_LITERAL, Kind.CLASS, Kind.NEW_ARRAY },
               typeClasses = { AnnotatedPrimitiveType.class })
  @interface IGJBottom { }
</PRE><!--TOC paragraph Top qualifier-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Top qualifier</H5><!--SEC END --><P>
Similarly, it is usually a good idea to have a top qualifier in your type
hierarchy &#X2014; a qualifier that is a (direct or indirect) supertype of every
other qualifier. When a type system lacks a top qualifier (or any other
qualifier), then users lose flexibility in expressing defaults.</P><P>For instance, the <TT>@Encrypted</TT> type system of
Section&#XA0;<A HREF="#encrypted-example">15.2</A> lacks an explicit top qualifier:</P><PRE CLASS="verbatim">  @TypeQualifier
  @SubtypeOf(Unqualified.class)
  @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
  public @interface Encrypted {}
</PRE><P>The default is
<TT>@Unqualified</TT>, and there is no way for a user to change that.
(A user could not specify <TT>@DefaultQualifier(Unqualified.class)</TT>,
because many type systems share <TT>@Unqualified</TT> and it is not clear which
type system the annotation is intended to refer to.)</P><P>By contrast, the Nullness type system has an explicit qualifier for every
possible meaning: both <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A> and
<TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A>. Because it has no built-in meaning
for unannotated types; a user may specify a default qualifier. This
greater flexibility for the user is usually preferable.</P><P>There are reasons to omit the top qualifier.
The ability to omit the top qualifier is a convenience
when writing a type system, because it reduces the number of qualifiers
that must be defined; this is especially convenient when using the Basic
Checker (Section&#XA0;<A HREF="#basic-checker">15</A>).
More importantly, omitting the top qualifier restricts the user in ways
that the type system designer may have intended.</P><!--TOC section Type factory: Implicit annotations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-type-introduction">22.4</A>&#XA0;&#XA0;Type factory: Implicit annotations</H2><!--SEC END --><P>For some types and expressions, a qualifier should be treated as present
even if a programmer did not explicitly write it. For example, every
literal (other than <TT>null</TT>) has a <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> type.</P><P>The implicit annotations may be specified declaratively and/or procedurally.</P><!--TOC subsection Declaratively specifying implicit annotations-->
<H3 CLASS="subsection"><A NAME="declarative-type-introduction"><!--SEC ANCHOR -->22.4.1&#XA0;&#XA0;Declaratively specifying implicit annotations</A></H3><!--SEC END --><P>The <TT>@</TT><A HREF="doc/checkers/quals/ImplicitFor.html"><TT>ImplicitFor</TT></A> meta-annotation indicates implicit annotations.
When written on a qualifier, <A HREF="doc/checkers/quals/ImplicitFor.html"><TT>ImplicitFor</TT></A>
specifies the trees (AST nodes) and types for which the framework should
automatically add that qualifier.</P><P>In short, the types and trees can be
specified via any combination of five fields in <A HREF="doc/checkers/quals/ImplicitFor.html"><TT>ImplicitFor</TT></A>:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>trees</TT>: an array of
<A HREF="http://docs.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.Kind.html?is-external=true"><TT>com.sun.source.tree.Tree.Kind</TT></A>, e.g.,
<TT>NEW_ARRAY</TT> or <TT>METHOD_INVOCATION</TT>
</LI><LI CLASS="li-itemize"><TT>types</TT>: an array of
<A HREF="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/type/TypeKind.html?is-external=true"><TT>TypeKind</TT></A>, e.g., <TT>ARRAY</TT>
or <TT>BOOLEAN</TT>
</LI><LI CLASS="li-itemize"><TT>treeClasses</TT>: an array of class literals for classes
implementing <A HREF="http://docs.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.html?is-external=true"><TT>Tree</TT></A>, e.g.,
<TT>LiteralTree.class</TT> or <TT>ExpressionTree.class</TT>
</LI><LI CLASS="li-itemize"><TT>typeClasses</TT>: an array of class literals for classes
implementing <TT>javax.lang.model.type.TypeMirror</TT>, e.g.,
<TT>javax.lang.model.type.PrimitiveType</TT>. Often you should use
a subclass of <A HREF="doc/checkers/types/AnnotatedTypeMirror.html"><TT>AnnotatedTypeMirror</TT></A>.
</LI><LI CLASS="li-itemize"><TT>stringPatterns</TT>: an array of regular expressions that will
be matched against
string literals, e.g., <TT>"[01]+"</TT> for a binary number. Useful
for annotations that indicate the format of a string.
</LI></UL><P>For example, consider the definitions of the <TT>@</TT><A HREF="doc/checkers/nullness/quals/NonNull.html"><TT>NonNull</TT></A> and <TT>@</TT><A HREF="doc/checkers/nullness/quals/Nullable.html"><TT>Nullable</TT></A>
type qualifiers:</P><PRE CLASS="verbatim">  @TypeQualifier
  @SubtypeOf( { Nullable.class } )
  @ImplicitFor(
    types={TypeKind.PACKAGE},
    typeClasses={AnnotatedPrimitiveType.class},
    trees={
      Tree.Kind.NEW_CLASS,
      Tree.Kind.NEW_ARRAY,
      Tree.Kind.PLUS,
      // All literals except NULL_LITERAL:
      Tree.Kind.BOOLEAN_LITERAL, Tree.Kind.CHAR_LITERAL, Tree.Kind.DOUBLE_LITERAL, Tree.Kind.FLOAT_LITERAL,
      Tree.Kind.INT_LITERAL, Tree.Kind.LONG_LITERAL, Tree.Kind.STRING_LITERAL
    })
  @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
  public @interface NonNull {  }


  @TypeQualifier
  @SubtypeOf({})
  @ImplicitFor(trees={Tree.Kind.NULL_LITERAL})
  @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
  public @interface Nullable { }
</PRE><P>For more details, see the Javadoc for the <A HREF="doc/checkers/quals/ImplicitFor.html"><TT>ImplicitFor</TT></A>
annotation, and the Javadoc for the javac classes that are linked from
it. You only need to understand a small amount about the javac AST, such
as the
<A HREF="http://docs.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.Kind.html?is-external=true"><TT>Tree.Kind</TT></A>
and
<A HREF="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/type/TypeKind.html?is-external=true"><TT>TypeKind</TT></A>
enums. All the information you need is in the Javadoc, and
Section&#XA0;<A HREF="#javac-tips">22.9</A> can help you get started.</P><!--TOC subsection Procedurally specifying implicit annotations-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->22.4.2&#XA0;&#XA0;Procedurally specifying implicit annotations</H3><!--SEC END --><P>The Checker Framework provides a representation of annotated types,
<A HREF="doc/checkers/types/AnnotatedTypeMirror.html"><TT>AnnotatedTypeMirror</TT></A>, that extends the standard <TT>TypeMirror</TT>
interface but integrates a representation of the annotations into a
type representation. A checker&#X2019;s <EM>type factory</EM> class, given an AST
node, returns the annotated type of that expression. The Checker
Framework&#X2019;s abstract
<EM>base type factory</EM> class, <A HREF="doc/checkers/types/AnnotatedTypeFactory.html"><TT>AnnotatedTypeFactory</TT></A>,
supplies a uniform, Tree-API-based interface
for querying the annotations on a program element, regardless of
whether that element is declared in a source file or in a class file.
It also handles default annotations, and it optionally performs
flow-sensitive local type inference.</P><P><A HREF="doc/checkers/types/AnnotatedTypeFactory.html"><TT>AnnotatedTypeFactory</TT></A> inserts the qualifiers that the programmer
explicitly inserted in the code. Yet, certain constructs should be
treated as having a type qualifier even when the programmer has not
written one. The type system designer may subclass
<A HREF="doc/checkers/types/AnnotatedTypeFactory.html"><TT>AnnotatedTypeFactory</TT></A> and override
<TT>annotateImplicit(Tree,AnnotatedTypeMirror)</TT> and
<TT>annotateImplicit(Element,AnnotatedTypeMirror)</TT> to account for
such constructs.</P><!--TOC subsection Flow-sensitive type qualifier inference-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->22.4.3&#XA0;&#XA0;Flow-sensitive type qualifier inference</H3><!--SEC END --><P>The Checker Framework provides automatic type refinement as described
in Section&#XA0;<A HREF="#type-refinement">19.1.2</A>.</P><P>Class
<A HREF="doc/checkers/types/BasicAnnotatedTypeFactory.html"><TT>BasicAnnotatedTypeFactory</TT></A>
provides a 3 parameter constructor that allows subclasses to disable
flow inference.
By default the 2 parameter constructor performs flow inference.
To disable flow inference, call
<TT>super(checker, root, false);</TT>
in your subtype of
<A HREF="doc/checkers/types/BasicAnnotatedTypeFactory.html"><TT>BasicAnnotatedTypeFactory</TT></A>.</P><!--TOC section Visitor: Type rules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="extending-visitor">22.5</A>&#XA0;&#XA0;Visitor: Type rules</H2><!--SEC END --><P>A type system&#X2019;s rules define which operations on values of a
particular type are forbidden.
These rules must be defined procedurally, not declaratively.</P><P>The Checker Framework provides a <I>base visitor class</I>,
<A HREF="doc/checkers/basetype/BaseTypeVisitor.html"><TT>BaseTypeVisitor</TT></A>, that performs type-checking at each node of a
source file&#X2019;s AST. It uses the visitor design pattern to traverse
Java syntax trees as provided by Oracle&#X2019;s
<A HREF="http://docs.oracle.com/javase/7/docs/jdk/api/javac/tree/index.html">Tree
API</A>,
and it issues a warning whenever the type system is violated.</P><P>A checker&#X2019;s visitor overrides one method in the base visitor for each special
rule in the type qualifier system. Most type-checkers
override only a few methods in <A HREF="doc/checkers/basetype/BaseTypeVisitor.html"><TT>BaseTypeVisitor</TT></A>. For example, the
visitor for the Nullness type system of Chapter&#XA0;<A HREF="#nullness-checker">3</A>
contains a single 4-line method that warns if an expression of nullable type
is dereferenced, as in:
</P><PRE CLASS="verbatim">  myObject.hashCode();  // invalid dereference
</PRE><P>By default, <A HREF="doc/checkers/basetype/BaseTypeVisitor.html"><TT>BaseTypeVisitor</TT></A> performs subtyping checks that are
similar to Java subtype rules, but taking the type qualifiers into account.
<A HREF="doc/checkers/basetype/BaseTypeVisitor.html"><TT>BaseTypeVisitor</TT></A> issues these errors:</P><UL CLASS="itemize"><LI CLASS="li-itemize">invalid assignment (type.incompatible) for an assignment from
an expression type to an incompatible type. The assignment may be a
simple assignment, or pseudo-assignment like return expressions or
argument passing in a method invocation<P>In particular, in every assignment and pseudo-assignment, the
left-hand side of the assignment is a supertype of (or the same type
as) the right-hand side. For example, this assignment is not
permitted:</P><PRE CLASS="verbatim">    @Nullable Object myObject;
    @NonNull Object myNonNullObject;
    ...
    myNonNullObject = myObject;  // invalid assignment
  </PRE></LI><LI CLASS="li-itemize">invalid generic argument (generic.argument.invalid) when a type
is bound to an incompatible generic type variable</LI><LI CLASS="li-itemize">invalid method invocation (method.invocation.invalid) when a
method is invoked on an object whose type is incompatible with the
method receiver type</LI><LI CLASS="li-itemize">invalid overriding parameter type (override.parameter.invalid)
when a parameter in a method declaration is incompatible with that
parameter in the overridden method&#X2019;s declaration</LI><LI CLASS="li-itemize">invalid overriding return type (override.return.invalid) when a
parameter in a method declaration is incompatible with that
parameter in the overridden method&#X2019;s declaration</LI><LI CLASS="li-itemize">invalid overriding receiver type (override.receiver.invalid)
when a receiver in a method declaration is incompatible with that
receiver in the overridden method&#X2019;s declaration</LI></UL><!--TOC subsection AST traversal-->
<H3 CLASS="subsection"><A NAME="ast-traversal"><!--SEC ANCHOR -->22.5.1&#XA0;&#XA0;AST traversal</A></H3><!--SEC END --><P>The Checker Framework needs to do its own traversal of the AST even though
it operates as an ordinary annotation processor&#XA0;[<A HREF="#JSR269">Dar06</A>]. Annotation
processors can utilize a visitor for Java code, but that visitor only
visits the public elements of Java code, such as classes, fields, methods,
and method arguments &#X2014; it does not visit code bodies or various other
locations. The Checker Framework hardly uses the built-in visitor &#X2014; as
soon as the built-in visitor starts to visit a class, then the Checker
Framework&#X2019;s visitor takes over and visits all of the class&#X2019;s source code.</P><P>Because there is no standard API for the AST of Java code<SUP><A NAME="text1" HREF="#note1">1</A></SUP>, the Checker
Framework uses the javac implementation. This is why the Checker Framework
is not deeply integrated with Eclipse, but runs as an external tool (see
Section&#XA0;<A HREF="#eclipse">23.6</A>).</P><!--TOC subsection Avoid hardcoding-->
<H3 CLASS="subsection"><A NAME="avoid-hardcoding"><!--SEC ANCHOR -->22.5.2&#XA0;&#XA0;Avoid hardcoding</A></H3><!--SEC END --><P>It may be tempting to write a type-checking rule for method invocation,
where your rule checks the name of the method being called and then treats
the method in a special way. This is usually the wrong approach. It
is better to write annotations, in a stub file
(Chapter&#XA0;<A HREF="#annotating-libraries">21</A>), and leave the work to the standard
type-checking rules.</P><!--TOC section The checker class: Compiler interface-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="writing-compiler-interface">22.6</A>&#XA0;&#XA0;The checker class: Compiler interface</H2><!--SEC END --><P>A checker&#X2019;s entry point is a subclass of <A HREF="doc/checkers/basetype/BaseTypeChecker.html"><TT>BaseTypeChecker</TT></A>. This entry
point, which we call the checker class, serves two
roles: an interface to the compiler and a factory for constructing
type-system classes.</P><P>Because the Checker Framework provides reasonable defaults, oftentimes the
checker class has no work to do. Here are the complete definitions of the
checker classes for the Interning and Nullness checkers:</P><PRE CLASS="verbatim">  @TypeQualifiers({ Interned.class, PolyInterned.class })
  @SupportedLintOptions({"dotequals"})
  public final class InterningChecker extends BaseTypeChecker { }

  @TypeQualifiers({ Nullable.class, Raw.class, NonNull.class, PolyNull.class })
  @SupportedLintOptions({"flow", "cast", "cast:redundant"})
  public class NullnessChecker extends BaseTypeChecker { }
</PRE><P>The checker class must be annotated by
<TT>@</TT><A HREF="doc/checkers/quals/TypeQualifiers.html"><TT>TypeQualifiers</TT></A>, which lists the annotations
that make up the type hierarchy for this checker (including
polymorphic qualifiers), provided as an array of class literals. Each
one is a type qualifier whose definition bears the
<TT>@</TT><A HREF="doc/checkers/quals/TypeQualifier.html"><TT>TypeQualifier</TT></A> meta-annotation (or is
returned by the
<A HREF="http://types.cs.washington.edu/checker-framework/current/doc/checkers/basetype/BaseTypeChecker.html#getSupportedTypeQualifiers()"><TT>BaseTypeChecker.getSupportedTypeQualifiers</TT></A>
method).</P><P>The checker class bridges between the compiler and the rest of the checker. It
invokes the type-rule check visitor on every Java source file being
compiled, and provides a simple API, <A HREF="http://types.cs.washington.edu/checker-framework/current/doc/checkers/source/SourceChecker.html#report(checkers.source.Result,%20java.lang.Object)"><TT>report</TT></A>, to issue
errors using the compiler error reporting mechanism.</P><P>Also, the checker class follows the factory method pattern to
construct the concrete classes (e.g., visitor, factory) and annotation
hierarchy representation. It is a convention that, for
a type system named Foo, the compiler
interface (checker), the visitor, and the annotated type factory are
named as <TT>FooChecker</TT>, <TT>FooVisitor</TT>, and <TT>FooAnnotatedTypeFactory</TT>.
<A HREF="doc/checkers/basetype/BaseTypeChecker.html"><TT>BaseTypeChecker</TT></A> uses the convention to
reflectively construct the components. Otherwise, the checker writer
must specify the component classes for construction.</P><P>A checker can customize the default error messages through a
<A HREF="http://docs.oracle.com/javase/7/docs/api/java/util/Properties.html"><TT>Properties</TT></A>-loadable text file named
<TT>messages.properties</TT> that appears in the same directory as the checker class.
The property file keys are the strings passed to <A HREF="http://types.cs.washington.edu/checker-framework/current/doc/checkers/source/SourceChecker.html#report(checkers.source.Result,%20java.lang.Object)"><TT>report</TT></A>
(like <TT>type.incompatible</TT>) and the values are the strings to be
printed (<TT>"cannot assign ..."</TT>).
The <TT>messages.properties</TT> file only need to mention the new messages that
the checker defines.
It is also allowed to override messages defined in superclasses, but this
is rarely needed.
For more details about message keys, see Section&#XA0;<A HREF="#compiler-message-keys">20.2.1</A>.</P><!--TOC subsection Bundling multiple checkers-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->22.6.1&#XA0;&#XA0;Bundling multiple checkers</H3><!--SEC END --><P>To run a checker, a user supplies the <TT>-processor</TT> command-line option.
There are two ways to run multiple related checkers as a unit.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
A user can pass
multiple <TT>-processor</TT> command-line options, like:<PRE CLASS="verbatim">  javac -processor DistanceUnitChecker -processor SpeedUnitChecker ... files ...
</PRE><P>This is verbose, and it is also error-prone, since a user might omit one of
several related checkers that are designed to be run together.</P></LI><LI CLASS="li-enumerate">You can define an aggregate checker class that combines
multiple checkers. Extend <A HREF="doc/checkers/util/AggregateChecker.html"><TT>AggregateChecker</TT></A> and override
the <TT>getSupportedTypeCheckers</TT> method, like the following:<PRE CLASS="verbatim">  public class UnitCheckers extends AggregateChecker {
    protected Collection&lt;Class&lt;? extends SourceChecker&gt;&gt; getSupportedCheckers() {
      return Arrays.asList(DistanceUnitChecker.class, SpeedUnitChecker.class);
    }
  }
</PRE><P>Now, a user can pass a single <TT>-processor</TT> argument on the command line:</P><PRE CLASS="verbatim">  javac -processor UnitCheckers ... files ...
</PRE></LI></OL><!--TOC subsection Providing command-line options-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->22.6.2&#XA0;&#XA0;Providing command-line options</H3><!--SEC END --><P>A checker can provide two kinds of command-line options:
boolean flags and
named string values (the standard annotation processor
options).</P><!--TOC subsubsection Boolean flags-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Boolean flags</H4><!--SEC END --><P>To specify a simple boolean flag, add:</P><PRE CLASS="verbatim">@SupportedLintOptions({"flag"})
</PRE><P>to your checker subclass.
The value of the flag can be queried using</P><PRE CLASS="verbatim">checker.getLintOption("flag", false)
</PRE><P>The second argument sets the default value that should be returned.</P><P>To pass a flag on the command line, call javac as follows:</P><PRE CLASS="verbatim">javac -processor Mine -Alint=flag
</PRE><!--TOC subsubsection Named string values-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Named string values</H4><!--SEC END --><P>For more complicated options, one can use the standard annotation
processing <TT>SupportedOptions</TT> annotation on the checker, as in:</P><PRE CLASS="verbatim">@SupportedOptions({"info"})
</PRE><P>The value of the option can be queried using</P><PRE CLASS="verbatim">env.getOptions().get("info")
</PRE><P>where <TT>env</TT> is the current <TT>ProcessingEnvironment</TT>.</P><P>To pass an option on the command line, call javac as follows:</P><PRE CLASS="verbatim">javac -processor Mine -Ainfo=p1,p2
</PRE><P>The value is returned as a single string and you have to perform the
required parsing of the option.</P><!--TOC section Testing framework-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="testing-framework">22.7</A>&#XA0;&#XA0;Testing framework</H2><!--SEC END --><P>The Checker Framework comes with a testing framework that is used for
testing the distributed checkers.
It is easy to use this testing framework to ensure correctness of your
checker!</P><P>You first need to provide a subclass of
<TT>ParameterizedCheckerTest</TT>
that determines the checker to use and all command-line options that
should be provided.
This class can be run as a JUnit test runner.
Note that you always need to use the
<TT>-Anomsgtext</TT> option to suppress the substitution of message keys
by human-readable values.
See the test setup classes in directory <TT>tests/src/tests/</TT> for examples.</P><P>Locate all your test cases in a subdirectory of the <TT>tests</TT>
directory.
The individual test cases are normal Java files that use stylized
comments to indicate expected error messages.
For example, consider this test case from the Nullness checker:</P><PRE CLASS="verbatim">  //:: error: (dereference.of.nullable)
  s.toString();
</PRE><P>An expected error message is introduced by the <TT>//::</TT> comment.
The next token is either <TT>error:</TT> or <TT>warning:</TT>,
distinguishing what kind of message is expected.
Finally, the message key for the expected message is given.</P><P>Multiple expected messages can be given using the "//:: A :: B :: C"
syntax.</P><P>As an alternative, expected errors can be specified in a separate file
using the <TT>.out</TT> file extension.
These files are of the following format:</P><PRE CLASS="verbatim">:19: error: (dereference.of.nullable)
</PRE><P>The number between the colons is the line number of the expected error
message.
This format is a lot harder to maintain and we suggest using the
in-line comment format.</P><!--TOC section Debugging options-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="debugging-options">22.8</A>&#XA0;&#XA0;Debugging options</H2><!--SEC END --><P>The Checker Framework provides debugging options that can be helpful when
writing a checker. These are provided via the standard <TT>javac</TT> &#X201C;<TT>-A</TT>&#X201D;
switch, which is used to pass options to an annotation processor.</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>-Anomsgtext</TT>: use message keys (such as &#X201C;<TT>type.invalid</TT>&#X201D;)
rather than full message text when reporting errors or warnings</LI><LI CLASS="li-itemize"><TT>-Ashowchecks</TT>: print debugging information for each
pseudo-assignment check (as performed by <A HREF="doc/checkers/basetype/BaseTypeVisitor.html"><TT>BaseTypeVisitor</TT></A>; see Section
<A HREF="#extending-visitor">22.5</A> above)</LI><LI CLASS="li-itemize"><TT>-Afilenames</TT>: print the name of each file before type-checking it</LI><LI CLASS="li-itemize"><TT>-AprintErrorStack</TT>: print a stack trace together with
internal Checker Framework error messages</LI><LI CLASS="li-itemize"><TT>-AprintAllQualifiers</TT>: print all type qualifiers, including
qualifiers like <TT>@Unqualified</TT> which are usually not shown.
(Use the <TT>@InvisibleQualifier</TT> meta-annotation on a qualifier to hide it.)</LI><LI CLASS="li-itemize"><TT>-Aignorejdkastub</TT>: ignore the jdk.astub file in the checker
directory. Files passed through the <TT>-Astubs</TT> option are still processed. This is useful when
compiling the source code that is described by the stub file and experimenting with an
alternative stub file.</LI></UL><P>The following example demonstrates how these options are used:</P><PRE CLASS="verbatim">$ javac -processor checkers.interning.InterningChecker \
    examples/InternedExampleWithWarnings.java -Ashowchecks -Anomsgtext -Afilenames

[InterningChecker] InterningExampleWithWarnings.java
 success (line  18): STRING_LITERAL "foo"
     actual: DECLARED @checkers.interning.quals.Interned java.lang.String
   expected: DECLARED @checkers.interning.quals.Interned java.lang.String
 success (line  19): NEW_CLASS new String("bar")
     actual: DECLARED java.lang.String
   expected: DECLARED java.lang.String
examples/InterningExampleWithWarnings.java:21: (not.interned)
    if (foo == bar)
            ^
 success (line  22): STRING_LITERAL "foo == bar"
     actual: DECLARED @checkers.interning.quals.Interned java.lang.String
   expected: DECLARED java.lang.String
1 error
</PRE><P>You can use any standard debugger to observe the execution of your checker.
Set the execution main class to <TT>com.sun.tools.javac.Main</TT>, and insert
the JSR 308 javac.jar (resides in
<TT>.../jsr308-langtools/dist/lib/javac.jar</TT>). If using an IDE, it is
recommended that you add <TT>.../jsr308-langtools</TT> as a project, so you
can step into its source code if needed.</P><!--TOC section javac implementation survival guide-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="javac-tips">22.9</A>&#XA0;&#XA0;javac implementation survival guide</H2><!--SEC END --><P>A checker built using the Checker Framework makes use of a few interfaces
from the underlying compiler (Oracle&#X2019;s OpenJDK javac).
This section describes those interfaces.</P><!--TOC subsection Checker access to compiler information-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->22.9.1&#XA0;&#XA0;Checker access to compiler information</H3><!--SEC END --><P>The compiler uses and exposes three hierarchies to model the Java
source code and classfiles.</P><!--TOC subsubsection Types - Java Language Model API-->
<H4 CLASS="subsubsection"><A NAME="javac-types"><!--SEC ANCHOR -->Types - Java Language Model API</A></H4><!--SEC END --><P>A <A HREF="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/type/TypeMirror.html?is-external=true"><TT>TypeMirror</TT></A> represents a Java type.
</P><P>There is a <TT>TypeMirror</TT> interface to represent each type kind,
e.g., <TT>PrimitiveType</TT> for primitive types, <TT>ExecutableType</TT>
for method types, and <TT>NullType</TT> for the type of the <TT>null</TT> literal.</P><P><TT>TypeMirror</TT> does not represent annotated types though. Checkers
should use the Checker Framework types API,
<A HREF="doc/checkers/types/AnnotatedTypeMirror.html"><TT>AnnotatedTypeMirror</TT></A>, instead. <TT>AnnotatedTypeMirror</TT>
parallels the <TT>TypeMirror</TT> API, but also present the type annotations
associated with the type.</P><P>The Checker Framework and the checkers use the types API extensively.</P><!--TOC subsubsection Elements - Java Language Model API-->
<H4 CLASS="subsubsection"><A NAME="javac-elements"><!--SEC ANCHOR -->Elements - Java Language Model API</A></H4><!--SEC END --><P>An <A HREF="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/element/Element.html?is-external=true"><TT>Element</TT></A> represents a potentially-public
declaration that can be accessed from elsewhere: classes, interfaces, methods, constructors, and
fields. <TT>Element</TT> represents elements found in both source
code and bytecode.</P><P>There is an <TT>Element</TT> interface to represent each construct, e.g.,
<TT>TypeElement</TT> for class/interfaces, <TT>ExecutableElement</TT> for
methods/constructors, <TT>VariableElement</TT> for local variables and
method parameters.</P><P>If you need to operate on the declaration level, always use elements rather
than trees
(see below). This allows the code to work on
both source and bytecode elements.</P><P>Example: retrieve declaration annotations, check variable
modifiers (e.g., <TT>strictfp</TT>, <TT>synchronized</TT>)</P><!--TOC subsubsection Trees - Compiler Tree API-->
<H4 CLASS="subsubsection"><A NAME="javac-trees"><!--SEC ANCHOR -->Trees - Compiler Tree API</A></H4><!--SEC END --><P>A <A HREF="http://docs.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.html?is-external=true"><TT>Tree</TT></A> represents a syntactic unit in the source code,
like a method declaration, statement, block, <TT>for</TT> loop, etc. Trees only
represent source code to be compiled (or found in <TT>-sourcepath</TT>);
no tree is available for classes read from bytecode.</P><P>There is a Tree interface for each Java source structure, e.g.,
<TT>ClassTree</TT> for class declaration, <TT>MethodInvocationTree</TT>
for a method invocation, and <TT>ForEachTree</TT> for an enhanced-for-loop
statement.</P><P>You should limit your use of trees. Checkers use Trees mainly to
traverse the source code and retrieve the types/elements corresponding to
them. Then, the checker performs any needed checks on the types/elements instead.</P><!--TOC subsubsection Using the APIs-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Using the APIs</H4><!--SEC END --><P>The three APIs use some common idioms and conventions; knowing them will
help you to create your checker.</P><P><EM>Type-checking</EM>:
Do not use <TT>instanceof</TT> to determine the class of the object,
because you cannot necessarily predict the run-time type of the object that
implements an interface. Instead, use the <TT>getKind()</TT> method. The
method returns <A HREF="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/type/TypeKind.html?is-external=true"><TT>TypeKind</TT></A>,
<A HREF="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/element/ElementKind.html?is-external=true"><TT>ElementKind</TT></A>, and <A HREF="http://docs.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/Tree.Kind.html?is-external=true"><TT>Tree.Kind</TT></A>
for the three interfaces, respectively.</P><P><EM>Visitors and Scanners</EM>:
The compiler and the Checker Framework use the visitor pattern
extensively. For example, visitors are used to traverse the source tree
(<A HREF="doc/checkers/basetype/BaseTypeVisitor.html"><TT>BaseTypeVisitor</TT></A> extends
<A HREF="http://docs.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/util/TreePathScanner.html?is-external=true"><TT>TreePathScanner</TT></A>) and for type
checking (<A HREF="doc/checkers/types/TreeAnnotator.html"><TT>TreeAnnotator</TT></A> implements
<A HREF="http://docs.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/tree/TreeVisitor.html?is-external=true"><TT>TreeVisitor</TT></A>).</P><P><EM>Utility classes</EM>:
Some useful methods appear in a utility class. The Oracle convention is that
the utility class for a <TT>Foo</TT> hierarchy is <TT>Foos</TT> (e.g.,
<A HREF="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/util/Types.html?is-external=true"><TT>Types</TT></A>, <A HREF="http://docs.oracle.com/javase/7/docs/api/javax/lang/model/util/Elements.html?is-external=true"><TT>Elements</TT></A>, and
<A HREF="http://docs.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/util/Trees.html?is-external=true"><TT>Trees</TT></A>). The Checker Framework uses a common
<TT>Utils</TT> suffix instead (e.g., <A HREF="doc/checkers/util/TypesUtils.html"><TT>TypesUtils</TT></A>,
<A HREF="doc/checkers/util/TreeUtils.html"><TT>TreeUtils</TT></A>, <A HREF="doc/checkers/util/ElementUtils.html"><TT>ElementUtils</TT></A>), with one
notable exception: <A HREF="doc/checkers/types/AnnotatedTypes.html"><TT>AnnotatedTypes</TT></A>.</P><!--TOC subsection How a checker fits in the compiler as an annotation processor-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->22.9.2&#XA0;&#XA0;How a checker fits in the compiler as an annotation processor</H3><!--SEC END --><P>The Checker Framework builds on the Annotation Processing API
introduced in Java 6. A type annotation processor is one that extends
<A HREF="http://docs.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/util/AbstractTypeProcessor.html?is-external=true"><TT>AbstractTypeProcessor</TT></A>; these get run on each class
source file after the compiler confirms that the class is valid Java code.</P><P>The most important methods of <A HREF="http://docs.oracle.com/javase/7/docs/jdk/api/javac/tree/com/sun/source/util/AbstractTypeProcessor.html?is-external=true"><TT>AbstractTypeProcessor</TT></A>
are <TT>typeProcess</TT> and <TT>getSupportedSourceVersion</TT>. The former
class is where you would insert any sort of method call to walk the AST,
and the latter just returns a constant indicating that we are targeting
version 8 of the compiler. Implementing these two methods should be enough
for a basic plugin; see the Javadoc for the class for other methods that
you may find useful later on.</P><P>The Checker Framework uses Oracle&#X2019;s Tree API to access a program&#X2019;s AST.
The Tree API is specific to the Oracle OpenJDK, so the Checker Framework only
works with the OpenJDK javac, not with Eclipse&#X2019;s compiler ecj or with
<A HREF="http://gcc.gnu.org/java/">gcj</A>. This also limits the tightness of
the integration of the Checker Framework into other IDEs such as <A HREF="http://www.jetbrains.com/idea/">IntelliJ IDEA</A>.
An implementation-neutral API would be preferable.
In the future, the Checker Framework
can be migrated to use the Java Model AST of JSR 198 (Extension API for
Integrated Development Environments)&#XA0;[<A HREF="#JSR198">Cro06</A>], which gives access to
the source code of a method. But, at present no tools
implement JSR&#XA0;198. Also see Section&#XA0;<A HREF="#ast-traversal">22.5.1</A>.</P><!--TOC subsubsection Learning more about javac-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR -->Learning more about javac</H4><!--SEC END --><P>Sun&#X2019;s javac compiler interfaces can be daunting to a
newcomer, and its documentation is a bit sparse. The Checker Framework
aims to abstract a lot of these complexities.
You do not have to understand the implementation of javac to
build powerful and useful checkers.
Beyond this document, 
other useful resources include the Java Infrastructure
Developer&#X2019;s guide at
<A HREF="http://wiki.netbeans.org/Java_DevelopersGuide"><TT>http://wiki.netbeans.org/Java_DevelopersGuide</TT></A> and the compiler
mailing list archives at
<A HREF="http://news.gmane.org/gmane.comp.java.openjdk.compiler.devel"><TT>http://news.gmane.org/gmane.comp.java.openjdk.compiler.devel</TT></A>
(subscribe at
<A HREF="http://mail.openjdk.java.net/mailman/listinfo/compiler-dev"><TT>http://mail.openjdk.java.net/mailman/listinfo/compiler-dev</TT></A>).</P><HR><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes">Actually,
there is a standard API for Java ASTs &#X2014; JSR 198 (Extension API for
Integrated Development Environments)&#XA0;[<A HREF="#JSR198">Cro06</A>]. If tools were to
implement it
(which would just require writing wrappers or adapters), then the Checker
Framework and similar tools could be portable among different compilers and
IDEs.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Integration with external tools-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="external-tools">Chapter&#XA0;23</A>&#XA0;&#XA0;Integration with external tools</H1><!--SEC END --><P>This chapter discusses how to run a checker from your favorite IDE.</P><P>Or, if your favorite isn&#X2019;t here, you should customize how it runs the
javac command on your behalf. See the IDE documentation to learn how to
customize it, adapting the instructions for javac in Section&#XA0;<A HREF="#running">2.2</A>.
If you make another tool support running a checker, please
inform us via the
<A HREF="http://groups.google.com/group/checker-framework-discuss">mailing
list</A> or
<A HREF="http://code.google.com/p/checker-framework/issues/list">issue tracker</A> so
we can add it to this manual.</P><P>This chapter also discusses type inference tools (see
Section&#XA0;<A HREF="#type-inference-tools">23.8</A>).</P><!--TOC section Javac Compiler-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="javac-installation">23.1</A>&#XA0;&#XA0;Javac Compiler</H2><!--SEC END --><P>If you use <TT>javac</TT> compiler from the command line, then you can use
the Type annotations compiler (a variant of the OpenJDK <TT>javac</TT>) that
is bundled with the Checker Framework. The bundled <TT>javac</TT> recognizes
type annotations, and annotations in comments (see
Section&#XA0;<A HREF="#annotations-in-comments">20.3.1</A>). (Eventually, you will be able to
use any Java compiler, such as the OpenJDK compiler, but Oracle has been
slow to incorporate all the patches, so the bundled <TT>javac</TT> is
superior, for the purpose of pluggable type-checking, and is equivalent in
all other respects.)</P><P>This section describes how you can install and use the bundled
<TT>javac</TT>, using either Unix/Linux/MacOS (see
Section&#XA0;<A HREF="#unix-installation">23.1.1</A>) or Windows (see
Section&#XA0;<A HREF="#windows-installation">23.1.2</A>).
The instructions are identical to those of Section&#XA0;<A HREF="#installation">1.2</A>,
but are given as commands that you can cut and paste into your command shell.</P><!--TOC subsection Unix/Linux/MacOS installation-->
<H3 CLASS="subsection"><A NAME="unix-installation"><!--SEC ANCHOR -->23.1.1&#XA0;&#XA0;Unix/Linux/MacOS installation</A></H3><!--SEC END --><P>These instructions assume that you use the bash or sh shell. If you use a
different shell, you may need to slightly adjust the commands.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Download the latest Checker Framework distribution
and unzip it. You can put it anywhere you like by changing the
definition of environment variable <TT>JSR308</TT> below; a standard place
is in a
new directory named <TT>jsr308</TT>.<PRE CLASS="verbatim">  export JSR308=$HOME/jsr308
  mkdir -p ${JSR308}
  cd ${JSR308}
  # or:  wget http://types.cs.washington.edu/checker-framework/current/checkers.zip
  curl -O http://types.cs.washington.edu/checker-framework/current/checkers.zip
  unzip checkers.zip
  chmod +x checker-framework/checkers/binary/javac
  checker-framework/checkers/binary/javac -version
</PRE><P>The output of the last command should be:</P><PRE CLASS="verbatim">  javac 1.7.0-jsr308-1.2.6
</PRE></LI><LI CLASS="li-enumerate">Place the following commands in your <TT>.bashrc</TT> file:
<PRE CLASS="verbatim">  export JSR308=$HOME/jsr308
  export CHECKERS=$JSR308/checker-framework/checkers
  export PATH=$CHECKERS/binary:${PATH}
</PRE><P>Also execute them on the command line, or log out and back in. Then,
verify that the installation works. From the command line, run:</P><PRE CLASS="verbatim">  javac -version
</PRE><P>The output should be:</P><PRE CLASS="verbatim">  javac 1.7.0-jsr308-1.2.6
</PRE></LI></OL><P>That&#X2019;s all there is to it! Now you are ready to start using the checkers with
the new <TT>javac</TT> compiler.</P><!--TOC subsection Windows installation-->
<H3 CLASS="subsection"><A NAME="windows-installation"><!--SEC ANCHOR -->23.1.2&#XA0;&#XA0;Windows installation</A></H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Download the latest Checker Framework distribution
and unzip it to create a <TT>checkers</TT> directory. You can put it anywhere
you like; a standard place is in a new directory under <TT>C:</TT><TT>\</TT><TT>Program
Files</TT>.<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
Save the file
<A HREF="http://types.cs.washington.edu/checker-framework/current/checkers.zip"><TT>http://types.cs.washington.edu/checker-framework/current/checkers.zip</TT></A>
to your Desktop.
</LI><LI CLASS="li-enumerate">Double-click the <TT>checkers.zip</TT> file on your computer. Click on
the <TT>checkers</TT> directory, then Select <TT>Extract all files</TT>, and use
<TT>C:</TT><TT>\</TT><TT>Program Files</TT> as the destination. You will obtain a new
<TT>C:</TT><TT>\</TT><TT>Program Files</TT><TT>\</TT><TT>checker-framework</TT> folder.
</LI><LI CLASS="li-enumerate">Verify that the installation works. From a Windows command prompt, run
(all on one line, and don&#X2019;t forget to replace the <CODE>\Path\To\...</CODE>!):<PRE CLASS="verbatim">  set CHECKERS = C:\Program Files\checker-framework\checkers
  java -Xbootclasspath/p:%CHECKERS%\binary\jsr308-all.jar -jar C:%CHECKERS%\binary\jsr308-all.jar -version
</PRE><P>The output should be:</P><PRE CLASS="verbatim">  javac 1.7.0-jsr308-1.2.6
</PRE></LI></OL></LI><LI CLASS="li-enumerate">In order to use the updated compiler when you type <TT>javac</TT>, add the
directory <TT>C:</TT><TT>\</TT><TT>Program Files</TT><TT>\</TT><TT>checker-framework</TT><TT>\</TT><TT>checkers</TT><TT>\</TT><TT>binary</TT> to the
beginning of your path variable. Also set a CHECKERS variable.<P>To set an environment variable, you have two options: make the change
temporarily or permanently.
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
To make the change <B>temporarily</B>, type at the command shell prompt:<PRE>
path = <EM>newdir</EM>;%PATH%
</PRE><P>For example:</P><PRE CLASS="verbatim">set CHECKERS = C:\Program Files\checker-framework\checkers
path = %CHECKERS%\binary;%PATH%
</PRE><P>This is a temporary change that endures until the window is closed, and you
must re-do it every time you start a new command shell.</P></LI><LI CLASS="li-itemize">To make the change <B>permanently</B>,
Right-click the <TT>My Computer</TT> icon and
select <TT>Properties</TT>. Select the <TT>Advanced</TT> tab and click the
<TT>Environment Variables</TT> button. You can set the variable as a &#X201C;System
Variable&#X201D; (visible to all users) or as a &#X201C;User Variable&#X201D; (visible to
just this user). Both work; the instructions below show how to set as a
&#X201C;System Variable&#X201D;.
In the <TT>System Variables</TT> pane, select
<TT>Path</TT> from the list and click <TT>Edit</TT>. In the <TT>Edit System Variable</TT>
dialog box, move the cursor to the beginning of the string in the
<TT>Variable Value</TT> field and type the full directory name (not using the
<CODE>%CHECKERS%</CODE> environment variable) followed by a
semicolon (<TT>;</TT>).<P>Similarly, set the CHECKERS variable.</P><P>This is a permanent change that only needs to be done once ever.
</P></LI></UL><P>Now, verify that the installation works. From the command line, run:</P><PRE CLASS="verbatim">  javac -version
</PRE><P>The output should be:</P><PRE CLASS="verbatim">  javac 1.7.0-jsr308-1.2.6
</PRE></LI></OL><!--TOC section Ant task-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="ant-task">23.2</A>&#XA0;&#XA0;Ant task</H2><!--SEC END --><P>If you use the <A HREF="http://ant.apache.org/">Ant</A> build tool to compile
your software, then you can add an Ant task that runs a checker. We assume
that your Ant file already contains a compilation target that uses the
<TT>javac</TT> task.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Set the <TT>jsr308javac</TT> property:<PRE CLASS="verbatim">  &lt;property environment="env"/&gt;

  &lt;dirname property="checkers" file="${env.CHECKERS}" /&gt;

  &lt;presetdef name="jsr308.javac"&gt;
    &lt;javac fork="yes"&gt;
      &lt;!-- JSR308 related compiler arguments --&gt;
      &lt;compilerarg value="-version"/&gt;
      &lt;!-- optional, so .class files work with older JVMs: &lt;compilerarg line="-target 5"/&gt; --&gt;
      &lt;compilerarg value="-implicit:class"/&gt;
      &lt;!-- optional, to issue warnings instead of errors: &lt;compilerarg line="-Awarns -Xmaxwarns 10000"/&gt; --&gt;
      &lt;compilerarg value="-J-Xbootclasspath/p:${checkers}/binary/jsr308-all.jar"/&gt;

      &lt;classpath&gt;
        &lt;pathelement location="${checkers}/checkers.jar"/&gt;
      &lt;/classpath&gt;
    &lt;/javac&gt;
  &lt;/presetdef&gt;
</PRE></LI><LI CLASS="li-enumerate">Duplicate the compilation target, then modify it slightly as
indicated in this example:<PRE CLASS="verbatim">  &lt;target name="check-nullness"
          description="Check for null pointer dereferences"
          depends="clean,..."&gt;
    &lt;!-- use jsr308.javac instead of javac --&gt;
    &lt;jsr308.javac ... &gt;
      &lt;compilerarg line="-processor checkers.nullness.NullnessChecker"/&gt;
      &lt;compilerarg value="-Xbootclasspath/p:${checkers}/jdk/jdk.jar"/&gt;
      &lt;!-- optional, for implicit imports: &lt;compilerarg value="-J-Djsr308_imports=checkers.nullness.quals.*"/&gt; --&gt;
      &lt;!-- optional, to not check uses of library methods: &lt;compilerarg value="-AskipUses=^(java\.awt\.|javax\.swing\.)"/&gt; --&gt;
      ...
    &lt;/jsr308.javac&gt;
  &lt;/target&gt;
</PRE><P>Fill in each ellipsis (&#X2026;) from the original compilation target. But,
don&#X2019;t include any <TT>-source</TT> argument with value other than <TT>1.8</TT>
or <TT>8</TT>. Doing so will disable the annotations in
comments feature (see Section&#XA0;<A HREF="#annotations-in-comments">20.3.1</A>).</P><P>In the example, the target is named <TT>check-nullness</TT>, but you can
name it whatever you like.
</P></LI></OL><!--TOC subsection Explanation-->
<H3 CLASS="subsection"><A NAME="ant-task-explanation"><!--SEC ANCHOR -->23.2.1&#XA0;&#XA0;Explanation</A></H3><!--SEC END --><P>This section explains each part of the Ant task.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Definition of <TT>jsr308.javac</TT>:<P>The <TT>fork</TT> field of the <TT>javac</TT> task
ensures that an external javac program is called. Otherwise, Ant will run
javac via a Java method call, and there is no guarantee that it will get
the JSR 308 version that is distributed with the Checker Framework.</P><P>The <TT>-version</TT> compiler argument is just for debugging; you may omit
it.</P><P>The <TT>-target 5</TT> compiler argument is optional, if you use Java 5 in
ordinary compilation when not performing pluggable type-checking (see
Section&#XA0;<A HREF="#java5-class-files">20.3.4</A>).</P><P>The <TT>-implicit:class</TT> compiler argument causes annotation processing
to be performed on implicitly compiled files. (An implicitly compiled file
is one that was not specified on the command line, but for which the source
code is newer than the <TT>.class</TT> file.) This is the default, but
supplying the argument explicitly suppresses a compiler warning.</P><P>The <TT>-Awarns ...</TT> compiler argument is optional, and causes the checker to
treat errors as warnings so that compilation does not fail even if
pluggable type-checking fails; see Section&#XA0;<A HREF="#checker-options">2.2.1</A>.</P></LI><LI CLASS="li-enumerate">The <TT>check-nullness</TT> target:<P>The target assumes the existence of a <TT>clean</TT> target that removes all
<TT>.class</TT> files. That is necessary because Ant&#X2019;s <TT>javac</TT> target
doesn&#X2019;t re-compile <TT>.java</TT> files for which a <TT>.class</TT> file
already exists.</P><P>The <TT>-processor ...</TT> compiler argument indicates which checker to
run. You can supply additional arguments to the checker as well.</P></LI></OL><!--TOC section Maven plugin-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="maven-plugin">23.3</A>&#XA0;&#XA0;Maven plugin</H2><!--SEC END --><P>If you use the <A HREF="http://maven.apache.org/">Maven</A> project tool,
then you can specify the distributed checkers as part of your build
process.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">First, you need to add the repositories in your <TT>pom.xml</TT> file:<PRE CLASS="verbatim">    &lt;repositories&gt;
        &lt;repository&gt;
            &lt;id&gt;checker-framework-repo&lt;/id&gt;
            &lt;url&gt;http://types.cs.washington.edu/m2-repo&lt;/url&gt;
        &lt;/repository&gt;
    &lt;/repositories&gt;
    &lt;pluginRepositories&gt;
        &lt;pluginRepository&gt;
            &lt;id&gt;checker-framework-repo&lt;/id&gt;
            &lt;url&gt;http://types.cs.washington.edu/m2-repo&lt;/url&gt;
        &lt;/pluginRepository&gt;
    &lt;/pluginRepositories&gt;
</PRE></LI><LI CLASS="li-enumerate">Then, to use the annotations used by the distributed checkers, you&#X2019;ll
have to declared as a dependency:<PRE CLASS="verbatim">    &lt;dependencies&gt;
        &lt;!-- annotations for the standard checkers: nullness, interning, mutability --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;types.checkers&lt;/groupId&gt;
            &lt;artifactId&gt;checkers-quals&lt;/artifactId&gt;
            &lt;version&gt;1.1.1&lt;/version&gt;
        &lt;/dependency&gt;

        &lt;!-- other dependencies --&gt;
    &lt;/dependencies&gt;
</PRE></LI><LI CLASS="li-enumerate">And finally, you need to attach the plugin to your build lifecycle:<PRE CLASS="verbatim">    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;types.checkers&lt;/groupId&gt;
                &lt;artifactId&gt;checkersplugin&lt;/artifactId&gt;
                &lt;version&gt;0.1&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;!-- run the checkers after compilation; this can also be any later phase --&gt;
                        &lt;phase&gt;process-classes&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;check&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
                &lt;configuration&gt;
                    &lt;!-- required configuration options --&gt;
                    &lt;!-- a list of processors to run --&gt;
                    &lt;processors&gt;
                        &lt;processor&gt;checkers.nullness.NullnessChecker&lt;/processor&gt;
                        &lt;processor&gt;checkers.interning.InterningChecker&lt;/processor&gt;
                    &lt;/processors&gt;


                    &lt;!-- other optional configuration --&gt;
                    &lt;!-- full path to a java executable that should be used to create the forked JVM --&gt;
                    &lt;executable&gt;/opt/java1.6/bin/java&lt;/executable&gt;
                    &lt;!-- should an error reported by a checker cause a build failure, or only be logged as a warning; defaults to true --&gt;
                    &lt;failOnError&gt;true|false&lt;/failOnError&gt;
                    &lt;!-- a list of patterns to include, in the standard maven syntax; defaults to **/*.java --&gt;
                    &lt;includes&gt;
                        &lt;include&gt;org/company/important/**/*.java&lt;/include&gt;
                    &lt;/includes&gt;
                    &lt;!-- a list of patterns to exclude, in the standard maven syntax; defaults to an empty list --&gt;
                    &lt;excludes&gt;
                        &lt;exclude&gt;org/company/notimportant/**/*.java&lt;/exclude&gt;
                    &lt;/excludes&gt;
                    &lt;!-- additional parameters passed to the JSR308 java compiler --&gt;
                    &lt;javacParams&gt;-Alint&lt;/javacParams&gt;
                    &lt;!-- additional parameters to pass to the forked JVM --&gt;
                    &lt;javaParams&gt;-Xdebug&lt;/javaParams&gt;
                    &lt;!-- versions of checkers to use; defaults to the current newest version: 1.0.6 --&gt;
                    &lt;checkersVersion&gt;0.8.8&lt;/checkersVersion&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</PRE></LI></OL><P>The plugin was contributed by Adam Warski.
</P><!--TOC section Gradle-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="gradle">23.4</A>&#XA0;&#XA0;Gradle</H2><!--SEC END --><P><A HREF="http://gradle.org/">Gradle</A> lets you add command-line arguments to a
<TT>javac</TT> invocation by setting the compilerArgs property of the
compiler options. This is adequate for running the Checker Framework,
because it is run by specifying command-line arguments. See the
instructions elsewhere in this manual for a list of command-line arguments.</P><P>To specify command-line arguments, set
<TT>compile.options.compilerArgs</TT>. Here is a possible example:</P><PRE CLASS="verbatim">allprojects {
  tasks.withType(Compile).allTasks { Compile compile -&gt;
    compile.options.debug = true
    compile.options.compilerArgs = [
      '-version',
      '-implicit:class',
      '-J-Xbootclasspath/p:${env.CHECKERS}/binary/jsr308-all.jar',
      '-processor', 'checkers.nullness.NullnessChecker',
      '-Xbootclasspath/p:${env.CHECKERS}/jdk/jdk.jar']
  }
}
</PRE><P>You don&#X2019;t need to use a special version of <TT>javac</TT>; you only need to
give the <TT>-J-Xbootclasspath/p:...</TT> argument. If you choose to use a
special version of <TT>javac</TT> instead of supplying the command-line
argument, then you can do so in the following way:</P><PRE CLASS="verbatim">tasks.withType(Compile).allObjects { compile -&gt;
  compile.options.fork.executable = "$CHECKERS/binary/javac"
}
</PRE><!--TOC section IntelliJ IDEA-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="intellij">23.5</A>&#XA0;&#XA0;IntelliJ IDEA</H2><!--SEC END --><P>IntelliJ IDEA (Maia release)
<A HREF="http://blogs.jetbrains.com/idea/2009/07/type-annotations-jsr-308-support/">supports</A>
the Type Annotations (JSR-308) syntax.
See <A HREF="http://blogs.jetbrains.com/idea/2009/07/type-annotations-jsr-308-support/"><TT>http://blogs.jetbrains.com/idea/2009/07/type-annotations-jsr-308-support/</TT></A>.</P><!--TOC section Eclipse-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="eclipse">23.6</A>&#XA0;&#XA0;Eclipse</H2><!--SEC END --><P>There are two ways to run a checker from within the Eclipse IDE: via Ant
or using an Eclipse plug-in.</P><!--TOC paragraph Using an Ant task-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Using an Ant task</H5><!--SEC END --><P>Add an Ant target as described in Section&#XA0;<A HREF="#ant-task">23.2</A>. You can
run the Ant target by executing the following steps
(instructions copied from
<A HREF="http://www.eclipse.org/documentation/?topic=/org.eclipse.platform.doc.user/gettingStarted/qs-84_run_ant.htm"><TT>http://www.eclipse.org/documentation/?topic=/org.eclipse.platform.doc.user/gettingStarted/qs-84_run_ant.htm</TT></A>):</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">Select <TT>build.xml</TT> in one of the navigation views and choose
<B>Run As </B><B>&gt;</B><B> Ant Build...</B> from its context menu.</LI><LI CLASS="li-enumerate">A launch configuration dialog is opened on a launch configuration
for this Ant buildfile.</LI><LI CLASS="li-enumerate">In the <B>Targets</B> tab, select the new ant task (e.g., check-interning).</LI><LI CLASS="li-enumerate">Click <B>Run</B>.</LI><LI CLASS="li-enumerate">The Ant buildfile is run, and the output is sent to the Console view.</LI></OL><!--TOC paragraph Eclipse plug-in for the Checker Framework-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Eclipse plug-in for the Checker Framework</H5><!--SEC END --><P>The Checker Plugin is an Eclipse plugin that enables the use of the Checker
Framework.
Its website (<A HREF="http://types.cs.washington.edu/checker-framework/eclipse/"><TT>http://types.cs.washington.edu/checker-framework/eclipse/</TT></A>).
The website contains instructions for installing and using the plugin.
</P><!--TOC paragraph Eclipse plug-in for Type Annotations-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Eclipse plug-in for Type Annotations</H5><!--SEC END --><P>A prototype version of Type Annotations support for Eclipse is
available from the Eclipse project. The goal is to enable full support for
writing
type annotations outside of comments. You do not need this to run the
Checker Framework, whether or not you write your type annotations in comments.</P><P>(Update: this apparently needs a username and password, so it may not be
publicly available.)
Use the following information to check
out the CVS repository:
</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Host:</B></DT><DD CLASS="dd-description"> dev.eclipse.org
</DD><DT CLASS="dt-description"><B>Repository path:</B></DT><DD CLASS="dd-description"> /cvsroot/eclipse
</DD><DT CLASS="dt-description"><B>Module name:</B></DT><DD CLASS="dd-description"> org.eclipse.jdt.core
</DD><DT CLASS="dt-description"><B>Branch:</B></DT><DD CLASS="dd-description"> JSR_308
</DD></DL><!--TOC section tIDE-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="tide">23.7</A>&#XA0;&#XA0;tIDE</H2><!--SEC END --><P>tIDE, an open-source Java IDE, supports the Checker Framework. See its
documentation at <A HREF="http://tide.olympe-network.com/"><TT>http://tide.olympe-network.com/</TT></A>.</P><!--TOC section Type inference tools-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="type-inference-tools">23.8</A>&#XA0;&#XA0;Type inference tools</H2><!--SEC END --><!--TOC subsection Varieties of type inference-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->23.8.1&#XA0;&#XA0;Varieties of type inference</H3><!--SEC END --><P>There are two different tasks that are commonly called &#X201C;type inference&#X201D;.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Type inference during type checking (Section&#XA0;<A HREF="#type-refinement">19.1.2</A>):
During type checking, if certain variables have no type qualifier, the
type-checker determines whether there is some type qualifier that would
permit the program to type check. If so, the type checker uses that type
qualifier, but never tells the programmer what it was. Each time the
type checker runs, it re-infers the type qualifier for that variable. If
no type qualifier exists that permits the program to type-check, the
type-checker issues a type warning.<P>This variety of type inference is built into the Checker Framework. Every
checker can take advantage of it at no extra effort. However, it only
works within a method, not across method boundaries.</P><P>Advantages of this variety of type inference include:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
If the type qualifier is obvious to the programmer, then omitting it
can reduce annotation clutter in the program.
</LI><LI CLASS="li-itemize">The type inference can take advantage of only the code currently being
compiled, rather than having to be correct for all possible calls.
Additionally, if the code changes, then there is no old annotation to
update.
</LI></UL></LI><LI CLASS="li-enumerate">Type inference to annotate a program (Section&#XA0;<A HREF="#type-inference-to-annotate">23.8.2</A>):
As a separate step before type checking, a type inference tool takes the
program as input, and outputs a set of type qualifiers that would
type-check. These qualifiers are inserted into the source code or the
class file. They can be viewed and adjusted by the programmer, and can
be used by tools such as the type checker.<P>This variety of type inference must be provided by a separate tool. It
is not built into the Checker Framework.</P><P>Advantages of this variety of type inference include:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
The program contains documentation in the form of type qualifiers,
which can aid programmer understanding.
</LI><LI CLASS="li-itemize">Error messages may be more comprehensible. With type inference
during type checking, error messages can be obscure, because the
compiler has already inferred (possibly incorrect) types for a number
of variables.
</LI><LI CLASS="li-itemize">A minor advantage is speed: type-checking can be modular, which can be
faster than re-doing type inference every time the
program is type-checked.
</LI></UL></LI></OL><P>Advantages of both varieties of inference include:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Less work for the programmer.
</LI><LI CLASS="li-itemize">The tool chooses the most general type, whereas a programmer might
accidentally write a more specific, less generally-useful annotation.
</LI></UL><P>Each variety of type inference has its place. When using the Checker
Framework, type inference during type checking is performed only
<EM>within</EM> a method (Section&#XA0;<A HREF="#type-refinement">19.1.2</A>). Every method
signature (arguments and return values) and field must be explicitly annotated,
either by the programmer or by a separate type checking tool
(Section&#XA0;<A HREF="#type-inference-to-annotate">23.8.2</A>). This choice reduces programmer
effort (typically, a programmer does not have to write any qualifiers
inside the body of a method) while still retaining modular checking and
documentation benefits.</P><!--TOC subsection Type inference to annotate a program-->
<H3 CLASS="subsection"><A NAME="type-inference-to-annotate"><!--SEC ANCHOR -->23.8.2&#XA0;&#XA0;Type inference to annotate a program</A></H3><!--SEC END --><P>This section lists tools that take a program and output a set of
annotations for it.</P><P>Section&#XA0;<A HREF="#nullness-inference">3.3.4</A> lists several tools that infer
annotations for the Nullness Checker.</P><P>Section&#XA0;<A HREF="#javari-inference">6.2.2</A> lists a tool that infers
annotations for the Javari Checker, which detects mutation errors.</P><HR><!--TOC chapter Frequently Asked Questions (FAQs)-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="faq">Chapter&#XA0;24</A>&#XA0;&#XA0;Frequently Asked Questions (FAQs)</H1><!--SEC END --><P>These are some common questions about the Checker Framework and about
pluggable type-checking in general. Feel free to suggest improvements to
the answers, or other questions to include here.</P><P>There is a separate FAQ for the type annotations syntax
(<A HREF="http://types.cs.washington.edu/jsr308/jsr308-faq.html"><TT>http://types.cs.washington.edu/jsr308/jsr308-faq.html</TT></A>).</P><P><B>Contents:</B><BR>
<A HREF="#faq-ease-of-use">24.1</A>: Are type annotations easy to read and write?<BR>
<A HREF="#faq-code-clutter">24.2</A>: Will my code become cluttered with type annotations?<BR>
<A HREF="#never-make-type-errors">24.3</A>: I don&#X2019;t make type errors, so would pluggable type checking help me?<BR>
<A HREF="#faq-handling-warnings">24.4</A>: What should I do if a checker issues a warning about my code?<BR>
<A HREF="#faq-no-absolute-guarantee">24.5</A>: Can a pluggable type-checker give an absolute guarantee of correctness?<BR>
<A HREF="#faq-awarns">24.6</A>: How do I make compilation succeed even if a checker issues errors?<BR>
<A HREF="#faq-run-time-checking">24.7</A>: How can I do run-time monitoring of properties that were not statically checked?<BR>
<A HREF="#faq-annotate-existing-program">24.8</A>: How do I get started annotating an existing program?<BR>
<A HREF="#faq-shorten-command-line">24.9</A>: How do I shorten the command line when invoking a checker?<BR>
<A HREF="#faq-qualifiers-vs-subclasses">24.10</A>: When should I use type qualifiers, and when should I use subclasses?<BR>
<A HREF="#faq-create-a-checker">24.11</A>: How do I create a new checker?<BR>
<A HREF="#faq-declarative-syntax-for-type-rules">24.12</A>: Why is there no declarative syntax for writing type rules?<BR>
<A HREF="#faq-type-checking-vs-bug-detectors">24.13</A>: Why not just use a bug detector (like FindBugs)?<BR>
<A HREF="#faq-jml">24.14</A>: How does pluggable type-checking compare with JML?<BR>
<A HREF="#faq-no-annotation-on-types-and-declarations">24.15</A>: Why shouldn&#X2019;t a qualifier apply to both types and declarations?<BR>
<A HREF="#faq-array-syntax-meaning">24.16</A>: What is the meaning of array annotations such as <TT>@NonNull Object @Nullable []</TT>?<BR>
<A HREF="#faq-list-map-nonnull-typeargs">24.17</A>: Why are the type parameters to <TT>List</TT> and <TT>Map</TT> annotated as <TT>@NonNull</TT>?<BR>
<A HREF="#faq-checker-framework-part-of-java">24.18</A>: Is the Checker Framework an official part of Java?<BR>
</P><!--TOC section Are type annotations easy to read and write?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-ease-of-use">24.1</A>&#XA0;&#XA0;Are type annotations easy to read and write?</H2><!--SEC END --><P>The paper
<A HREF="http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008-abstract.html">&#X201C;Practical
pluggable types for Java&#X201D;</A>&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>] discusses case studies in
which programmers
found type annotations to be natural to read and write. The code
continued to feel like Java, and the type-checking errors were easy to
comprehend and often led to real bugs.</P><P>You don&#X2019;t have to take our word for it, though. You can try the
Checker Framework for yourself.</P><P>The difficulty of adding and verifying annotations depends on your program.
If your program is well-designed and -documented, then skimming the
existing documentation and writing type annotations is extremely easy.
Otherwise, you may find yourself spending a lot of time trying to
understand, reverse-engineer, or fix bugs in your program, and then just a
moment writing a type annotation that describes what you discovered. This
process inevitably improves your code. You must decide whether it is a
good use of your time. For code that is not causing trouble now and is
unlikely to do so in the future (the code is bug-free, and you do not
anticipate changing it or using it in new contexts), then the
effort of writing type annotations for it may not be justified.</P><!--TOC section Will my code become cluttered with type annotations?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-code-clutter">24.2</A>&#XA0;&#XA0;Will my code become cluttered with type annotations?</H2><!--SEC END --><P>As with any language feature, it is possible to write ugly code that
over-uses annotations. However, in normal use, very few annotations need
to be written. Figure 1 of the paper
<A HREF="http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008-abstract.html">Practical
pluggable types for Java</A>&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>] reports data for over
350,000 lines of type-annotated code:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
1 annotation per 62 lines for nullness annotations (<TT>@NonNull</TT>, <TT>@Nullable</TT>, etc.)
</LI><LI CLASS="li-itemize">1 annotation per 1736 lines for interning annotations (<TT>@Interned</TT>)
</LI><LI CLASS="li-itemize">1 annotation per 27 lines for immutability annotations (IGJ type system)
</LI></UL><P>These numbers are for annotating existing code. New code that
is written with the type annotation system in mind is cleaner and more
correct, so it requires even fewer annotations.</P><P>Each annotation that a programmer writes replaces a sentence or phrase of
English descriptive text that would otherwise have been written in the
Javadoc. So, use of annotations actually reduces the overall size of the
documentation, at the same time as making it less ambiguous and
machine-processable.</P><P>In summary: annotations do not clutter code; they are used much
less frequently than generic types, which Java programmers find acceptable;
and they reduce the overall volume of documentation that a codebase needs.</P><!--TOC section I don&#X2019;t make type errors, so would pluggable type checking help me?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="never-make-type-errors">24.3</A>&#XA0;&#XA0;I don&#X2019;t make type errors, so would pluggable type checking help me?</H2><!--SEC END --><P>Occasionally, a developer says that he makes no errors that typechecking
could catch, or that any such errors are unimportant because they have low
impact and are easy to fix. When I investigate the claim, I invariably
find that the developer is mistaken.</P><P>Very frequently, the developer has underestimated what typechecking can
discover. Not every type error leads to an exception being thrown; and
even if an exception is thrown, it may not seem related to classical types.
Remember that a type system can discover
null pointer dereferences,
incorrect side effects, 
security errors such as information leakage or SQL injection,
partially-initialized data,
wrong units of measurement,
and many other errors. Even where type-checking does not discover a
problem directly, it can indicate code with bad smells, thus revealing
problems, improving documentation, and making future maintenance easier.</P><P>There are other ways to discover errors, including extensive testing and
debugging. You should continue to use these.
But type-checking is a good complement to these. Type-checking is more
effective for some problems, and less effective for other problems. It can
reduce (but not eliminate) the time and effort that you spend on other
approaches. There are many important errors that type checking and other
automated approaches cannot find; pluggable typechecking gives you more
time to focus on those.</P><!--TOC section What should I do if a checker issues a warning about my code?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-handling-warnings">24.4</A>&#XA0;&#XA0;What should I do if a checker issues a warning about my code?</H2><!--SEC END --><P>For a discussion of this issue, see Section&#XA0;<A HREF="#handling-warnings">2.4.7</A>.</P><!--TOC section Can a pluggable type-checker give an absolute guarantee of correctness?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-no-absolute-guarantee">24.5</A>&#XA0;&#XA0;Can a pluggable type-checker give an absolute guarantee of correctness?</H2><!--SEC END --><P>Each checker looks for certain errors. You can use multiple checkers, but
even then your program might still contain other kinds of errors.</P><P>If you run a pluggable checker on only part of the code of a program, then
you do not get a guarantee that all parts of the program satisfy the type
system (that is, are error-free). An example is a framework that clients
are intended to extend. In this case, you should recommend that clients
run the pluggable checker. There is no way to force users to do so, so you
may want to retain dynamic checks or use other mechanisms to detect errors.</P><P>There are other circumstances in which a static type-checker may fail to
detect a possible type error. In Java, these include arrays, casts, raw
types, reflection, separate compilation (bytecodes from unverified sources),
native code, etc. (For details, see section&#XA0;<A HREF="#checker-guarantees">2.3</A>.)
Java uses dynamic checks for most of these, so that the
type error cannot cause a security vulnerability or a crash. The pluggable
type-checkers inherit many (not all) of these weaknesses of Java
type-checking, but do not currently have built-in dynamic checkers.
Writing dynamic checkers would be an interesting and valuable project.</P><P>Even if a tool such as a pluggable checker cannot give an ironclad
guarantee of correctness, it is still useful. It can finding errors, 
excluding certain types of possible problems (e.g., restricting the
possible class of problems), and increasing confidence in a piece of
software.</P><!--TOC section How do I make compilation succeed even if a checker issues errors?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-awarns">24.6</A>&#XA0;&#XA0;How do I make compilation succeed even if a checker issues errors?</H2><!--SEC END --><P>Section&#XA0;<A HREF="#running">2.2</A> describes the <TT>-Awarns</TT> command-line
option that turns checker errors into warnings, so type-checking errors
will not cause <TT>javac</TT> to exit with a failure status.</P><!--TOC section How can I do run-time monitoring of properties that were not statically checked?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-run-time-checking">24.7</A>&#XA0;&#XA0;How can I do run-time monitoring of properties that were not statically checked?</H2><!--SEC END --><P>Some properties are not checked statically (see
Chapter&#XA0;<A HREF="#warnings-and-legacy">20</A> for reasons that code might not be
statically checked). In such cases, it would be desirable to check the
property dynamically, at run time.
Currently, the Checker Framework has no support for adding code to perform
run-time checking.</P><P>Adding such support would be an interesting and valuable project.
An example would be an option that causes the Checker Framework to
automatically insert a run-time check anywhere that static checking is
suppressed.
If you
are able to add run-time verification functionality, we would gladly
welcome it as a contribution to the Checker Framework.</P><P>Some checkers have library methods that you can explicitly insert in your
source code.
Examples include the Nullness Checker&#X2019;s
<A HREF="doc/checkers/nullness/NullnessUtils.html#castNonNull(T)"><TT>NullnessUtils.castNonNull</TT></A> method (see
Section&#XA0;<A HREF="#suppressing-warnings-with-assertions">3.4.1</A>) and the Regex Checker&#X2019;s
<TT>RegexUtil</TT> class (see Section&#XA0;<A HREF="#regexutil-methods">11.2.3</A>).
But, it would be better to have more general support that does not require
the user to explicitly insert method calls.</P><!--TOC section How do I get started annotating an existing program?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-annotate-existing-program">24.8</A>&#XA0;&#XA0;How do I get started annotating an existing program?</H2><!--SEC END --><P>See Section&#XA0;<A HREF="#get-started-with-legacy-code">2.4.1</A>.</P><!--TOC section How do I shorten the command line when invoking a checker?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-shorten-command-line">24.9</A>&#XA0;&#XA0;How do I shorten the command line when invoking a checker?</H2><!--SEC END --><P>The compile options to javac can be a pain to type; for example,
<TT>javac -processor checkers.nullness.NullnessChecker ...</TT>.
See Section&#XA0;<A HREF="#checker-auto-discovery">2.2.2</A> for a way to avoid the need for
the <TT>-processor</TT> command-line option.</P><!--TOC section When should I use type qualifiers, and when should I use subclasses?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-qualifiers-vs-subclasses">24.10</A>&#XA0;&#XA0;When should I use type qualifiers, and when should I use subclasses?</H2><!--SEC END --><P>In brief, use subtypes when you can, and use type qualifiers when you cannot
use subtypes.
For more details, see section&#XA0;<A HREF="#when-to-use-type-qualifiers">2.4.6</A>.</P><!--TOC section How do I create a new checker?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-create-a-checker">24.11</A>&#XA0;&#XA0;How do I create a new checker?</H2><!--SEC END --><P>In addition to using the checkers that are distributed with the Checker
Framework, you can write your own checker to check specific properties that
you care about. Thus, you can find and prevent the bugs that are most
important to you.</P><P>Chapter&#XA0;<A HREF="#writing-a-checker">22</A> gives
complete details regarding how to write a checker. It also suggests places
to look for more help, such as the <A HREF="doc/">Checker Framework
API documentation (Javadoc)</A> and the source code of the distributed
checkers.</P><P>To whet your interest and demonstrate how easy it is to get started, here
is an example of a complete, useful type checker.</P><PRE CLASS="verbatim">  @TypeQualifier
  @SubtypeOf(Unqualified.class)
  @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
  public @interface Encrypted { }
</PRE><P>Section&#XA0;<A HREF="#basic-example">15.2</A> explains this checker and tells
you how to run it.</P><!--TOC section Why is there no declarative syntax for writing type rules?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-declarative-syntax-for-type-rules">24.12</A>&#XA0;&#XA0;Why is there no declarative syntax for writing type rules?</H2><!--SEC END --><P>A type system implementer can declaratively specify the type qualifier
hierarchy (Section&#XA0;<A HREF="#declarative-hierarchy">22.3.1</A>) and the type introduction rules
(Section&#XA0;<A HREF="#declarative-type-introduction">22.4.1</A>). However, the Checker
Framework uses a procedural syntax for specifying type-checking
rules (Section&#XA0;<A HREF="#extending-visitor">22.5</A>).
A declarative syntax might be more concise, more readable, and more
verifiable than a procedural syntax.</P><P>We have not found the procedural syntax to be the most important impediment
to writing a checker.</P><P>Previous attempts to devise a declarative syntax 
for realistic type systems have failed; see a technical
paper&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>] for a discussion. When an
adequate syntax exists, then the Checker Framework can be extended to
support it.</P><!--TOC section Why not just use a bug detector (like FindBugs)?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-type-checking-vs-bug-detectors">24.13</A>&#XA0;&#XA0;Why not just use a bug detector (like FindBugs)?</H2><!--SEC END --><P>Pluggable type-checking finds more bugs than a bug detector does, for any
given variety of bug.</P><P>A bug detector like <A HREF="http://findbugs.sourceforge.net/">FindBugs</A>&#XA0;[<A HREF="#HovemeyerP2004">HP04</A>, <A HREF="#HovemeyerSP2005">HSP05</A>],
<A HREF="http://artho.com/jlint/">JLint</A>&#XA0;[<A HREF="#Artho2001">Art01</A>], or
<A HREF="http://pmd.sourceforge.net/">PMD</A>&#XA0;[<A HREF="#Copeland2005">Cop05</A>] aims to find <EM>some</EM>
of the most obvious bugs in your program. It uses a lightweight analysis,
then uses heuristics to discard some of its warnings. Thus, even if the tool
prints no warnings, your code might still have errors &#X2014; maybe the
analysis was too weak to find them, or the tool&#X2019;s heuristics classified the
warnings as likely false positives and discarded them.</P><P>A type checker aims to find <EM>all</EM> the bugs (of certain varieties).
It requires you to write type qualifiers in your program, or to use a tool
that infers types. Thus, it requires more work from the programmer, and in
return it gives stronger guarantees.</P><P>Each tool is useful in different circumstances, depending on how important
your code is and your desired level of confidence in your code. For more
details on the comparison, see section&#XA0;<A HREF="#other-tools">25.5</A>. For a case study
that compared the nullness analysis of FindBugs, JLint, PMD, and the
Checker Framework, see section 6 of the paper
<A HREF="http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008.pdf">&#X201C;Practical pluggable types for Java&#X201D;</A>&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>].</P><!--TOC section How does pluggable type-checking compare with JML?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-jml">24.14</A>&#XA0;&#XA0;How does pluggable type-checking compare with JML?</H2><!--SEC END --><P><A HREF="http://www.cs.ucf.edu/~leavens/JML/">JML</A>, the Java Modeling
Language&#XA0;[<A HREF="#LeavensBR2006:JML">LBR06</A>], is a language for writing formal
specifications. JML aims to be more expressive than pluggable
type-checking. JML is not as practical as pluggable type-checking.</P><P>A programmer can write a JML specification that
describes arbitrary facts about program behavior. Then, the programmer can
use formal reasoning or a theorem-proving tool to verify that the code
meets the specification. Run-time checking is also possible.
By contrast, pluggable type-checking can express a more limited set of
properties about your program.</P><P>The JML toolset is less mature. For instance, if your code uses
generics or other features of Java 5, then you cannot use JML. 
However, JML has a run-time checker, which the Checker Framework currently
lacks.</P><!--TOC section Why shouldn&#X2019;t a qualifier apply to both types and declarations?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-no-annotation-on-types-and-declarations">24.15</A>&#XA0;&#XA0;Why shouldn&#X2019;t a qualifier apply to both types and declarations?</H2><!--SEC END --><P>It is bad style for an annotation to apply to both types and declarations.
In other words, every annotation should have a <TT>@Target</TT> meta-annotation,
and the <TT>@Target</TT> meta-annotation should list either only declaration
locations or only type annotations. (It&#X2019;s OK for an annotation to target
both <TT>ElementType.TYPE_PARAMETER</TT> and <TT>ElementType.TYPE_USE</TT>, but no
other declaration location along with <TT>ElementType.TYPE_USE</TT>.)</P><P>Sometimes, it may seem tempting for an annotation to apply to both type
uses and (say) method declarations. Here is a hypothetical example:</P><BLOCKQUOTE CLASS="quote">
&#X201C;Each <TT>Widget</TT> type may have a <TT>@Version</TT> annotation.
I wish to prove that versions of widgets don&#X2019;t get assigned to
incompatible variables, and that older code does not call newer code (to
avoid problems when backporting).<P>A <TT>@Version</TT> annotation could be written like so:</P><PRE CLASS="verbatim">  @Version("2.0") Widget createWidget(String value) { ... }
</PRE><P><TT>@Version("2.0")</TT> on the method could mean that the <TT>createWidget</TT> method
only appears in the 2.0 version. <TT>@Version("2.0")</TT> on the return type
could mean that the returned <TT>Widget</TT> should only be used by code that
uses the 2.0 API of <TT>Widget</TT>. It should be possible to specify these
independently, such as a 2.0 method that returns a value that allows the
1.0 API method invocations.&#X201D;
</P></BLOCKQUOTE><P>Both of these are type properties and should be specified with type
annotations. No method annotation is necessary or desirable. The best way
to require that the receiver has a certain property is to use a type
annotation on the receiver of the method. (Slightly more formally, the
property being checked is compatibility between the annotation on the type
of the formal parameter receiver and the annotation on the type of the
actual receiver.)</P><P>Another example of a type-and-declaration annotation that represents poor
design is JCIP&#X2019;s <TT>@GuardedBy</TT> annotation&#XA0;[<A HREF="#Goetz2006">GPB<SUP>+</SUP>06</A>]. As discussed
in Section&#XA0;<A HREF="#jcip-annotations">7.1.3</A>, it means two different things when
applied to a field or a method. To reduce confusion and increase
expressiveness, the Lock Checker (see Chapter&#XA0;<A HREF="#lock-checker">7</A>) uses the
<TT>@Holding</TT> annotation for one of these meanings, rather than overloading
<TT>@GuardedBy</TT> with two distinct meanings.</P><!--TOC section What is the meaning of array annotations such as <TT>@NonNull Object @Nullable []</TT>?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-array-syntax-meaning">24.16</A>&#XA0;&#XA0;What is the meaning of array annotations such as <TT>@NonNull Object @Nullable []</TT>?</H2><!--SEC END --><P>You should parse this as:
(<B><TT>@NonNull Object</TT></B>) (<B><TT>@Nullable []</TT></B>).
Each annotation precedes the component of the type that it qualifies.</P><P>Thus,
<TT>@NonNull Object @Nullable []</TT> is a possibly-null array of non-null
objects. Note that the first token in the type,
&#X201C;<TT>@NonNull</TT>&#X201D;, applies to the element
type <TT>Object</TT>, not to the array type as a whole. The annotation <TT>@Nullable</TT> applies to the
array (<TT>[]</TT>).</P><P>Similarly,
<TT>@Nullable Object @NonNull []</TT> is a non-null array of possibly-null
objects.</P><!--TOC section Why are the type parameters to <TT>List</TT> and <TT>Map</TT> annotated as <TT>@NonNull</TT>?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-list-map-nonnull-typeargs">24.17</A>&#XA0;&#XA0;Why are the type parameters to <TT>List</TT> and <TT>Map</TT> annotated as <TT>@NonNull</TT>?</H2><!--SEC END --><P>The annotation on <TT>java.util.Collection</TT> only allows non-null elements:</P><PRE CLASS="verbatim">  public interface Collection&lt;E extends @NonNull Object&gt; {
    ...
  }
</PRE><P>Thus, you will get a type error if you write code like
<TT>Collection&lt;@Nullable Object&gt;</TT>.
A nullable
type parameter is also forbidden for certain other collections, including
<TT>AbstractCollection</TT>, <TT>List</TT>, <TT>Map</TT>, and <TT>Queue</TT>.</P><P>The <TT>extends @NonNull Object</TT> bound is a direct consequence of the design
of the collections classes; it merely formalizes the Javadoc specification.
The Javadoc for <TT>Collection</TT> states:</P><BLOCKQUOTE CLASS="quote">
Some list implementations have restrictions on the elements that they may
contain. For example, some implementations prohibit null elements, &#X2026;</BLOCKQUOTE><P>Here are some consequences of the requirement to detect all nullness errors
at compile time. If even one subclass of a given collection class may
prohibit null, then the collection class and all its subclasses must
prohibit null. Conversely, if a collection class is specified to accept
null, then all its subclasses must honor that specification.</P><P>The Checker Framework&#X2019;s annotations make apparent a flaw in the JDK
design, and helps you to avoid problems that might be caused by that flaw.</P><!--TOC paragraph Justification from type theory-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Justification from type theory</H5><!--SEC END --><P>
Suppose <TT>B</TT> is a subtype of <TT>A</TT>.
Then an overriding method in <TT>B</TT> must have a stronger (or equal) signature
than the overridden method in&#XA0;<TT>A</TT>. In a stronger signature, the formal
parameter types may be supertypes, and the return type may be a subtype.
Here are examples:</P><PRE CLASS="verbatim">  class A           {  @NonNull Object Number m1( @NonNull Object arg) { ... } }
  class B extends A { @Nullable Object Number m1( @NonNull Object arg) { ... } } // error!
  class C extends A {  @NonNull Object Number m1(@Nullable Object arg) { ... } } // OK
  class D           { @Nullable Object Number m2(@Nullable Object arg) { ... } }
  class E extends D {  @NonNull Object Number m2(@Nullable Object arg) { ... } } // OK
  class F extends D { @Nullable Object Number m2( @NonNull Object arg) { ... } } // error!
</PRE><P>According to these rules, since some subclasses of <TT>Collection</TT> do not
permit nulls, then <TT>Collection</TT> cannot either:</P><PRE CLASS="verbatim">  // does not permit null elements
  class PriorityQueue&lt;E&gt; implements Collection&lt;E&gt; {
    boolean add(E);
    ...
  }
  // must not permit null elements, or PriorityQueue would not be a subtype of Collection
  interface Collection&lt;E&gt; {
    boolean add(E);    
    ...
  }
</PRE><!--TOC paragraph Justification from checker behavior-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Justification from checker behavior</H5><!--SEC END --><P>Suppose that you changed the bound in the <TT>Collection</TT> declaration to
<TT>extends @Nullable Object</TT>. Then, the checker would issue no warning for
this method:</P><PRE CLASS="verbatim">  static void addNull(Collection l) {
    l.add(null);
  }
</PRE><P>However, calling this method <EM>can</EM> result in a null pointer exception,
for instance caused by the following code:</P><PRE CLASS="verbatim">  addNull(new PriorityQueue());
</PRE><P>Therefore, the bound must remain as <TT>extends @NonNull Object</TT>.</P><P>By contrast, this code is OK because <TT>ArrayList</TT> is documented to support
null elements:</P><PRE CLASS="verbatim">  static void addNull(ArrayList l) {
    l.add(null);
  }
</PRE><P>Therefore, the upper bound in <TT>ArrayList</TT> is <TT>extends @Nullable Object</TT>.
Any subclass of <TT>ArrayList</TT> must also support null elements.</P><!--TOC paragraph Suppressing warnings-->
<H5 CLASS="paragraph"><!--SEC ANCHOR -->Suppressing warnings</H5><!--SEC END --><P>Suppose your program has a list variable, and you know that any list referenced
by that variable will definitely support null. Then, you can suppress the
warning:</P><PRE CLASS="verbatim">  @SuppressWarnings("nullness:generic.argument")
  static void addNull(List l) {
    l.add(null);
  }
</PRE><P>You need to use <TT>@SuppressWarnings("nullness:generic.argument")</TT>
whenever you use a collection that may contain <TT>null</TT> elements in
contradiction to its documentation. Fortunately, such uses are relatively
rare.</P><P>For more details on suppressing nullness warnings, see
Section&#XA0;<A HREF="#suppressing-warnings-nullness">3.4</A>.</P><!--TOC section Is the Checker Framework an official part of Java?-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="faq-checker-framework-part-of-java">24.18</A>&#XA0;&#XA0;Is the Checker Framework an official part of Java?</H2><!--SEC END --><P>The Checker Framework is not an official part of Java, though it relies on
type annotations, which are part of Java 8. See the
<A HREF="http://types.cs.washington.edu/jsr308/jsr308-faq.html#checkers-in-java">Type
Annotations (JSR 308) FAQ</A> for more details.</P><HR><!--TOC chapter Troubleshooting and getting help-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="troubleshooting">Chapter&#XA0;25</A>&#XA0;&#XA0;Troubleshooting and getting help</H1><!--SEC END --><P>Please read the entire manual, including this chapter and the FAQ
(Chapter&#XA0;<A HREF="#faq">24</A>), because the manual might already answer your question.
If not, you can use the mailing list,
<TT>checker-framework-discuss@googlegroups.com</TT>, to ask other users for
help. For archives and to subscribe, see <A HREF="http://groups.google.com/group/checker-framework-discuss"><TT>http://groups.google.com/group/checker-framework-discuss</TT></A>.
To report bugs, use the issue tracker at
<A HREF="http://code.google.com/p/checker-framework/issues/list"><TT>http://code.google.com/p/checker-framework/issues/list</TT></A>.
If you want to help out, you can choose a bug and fix it, or select a
project from the ideas list at
<A HREF="http://code.google.com/p/checker-framework/wiki/Ideas"><TT>http://code.google.com/p/checker-framework/wiki/Ideas</TT></A>.</P><!--TOC section Common problems and solutions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="common-problems">25.1</A>&#XA0;&#XA0;Common problems and solutions</H2><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
To verify that you are using the compiler you think you are, you can add
<TT>-version</TT> to the command line. For instance, instead of running
<TT>javac -g MyFile.java</TT>, you can run <TT>javac </TT><TT><U>-version</U></TT><TT> -g
MyFile.java</TT>. Then, javac will print out its version number in addition
to doing its normal processing.</LI></UL><!--TOC subsection Unable to run the checker, or checker crashes-->
<H3 CLASS="subsection"><A NAME="common-problems-running"><!--SEC ANCHOR -->25.1.1&#XA0;&#XA0;Unable to run the checker, or checker crashes</A></H3><!--SEC END --><P>If you are unable to run the checker, or if the checker or the compiler
crashes, then the problem may be a problem with your environment.
This section describes some possible problems and solutions.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
If you get the error<PRE CLASS="verbatim">com.sun.tools.javac.code.Symbol$CompletionFailure: class file for com.sun.source.tree.Tree not found
</PRE><P>then you are using the source installation and file <TT>tools.jar</TT> is not
on your classpath. See the installation instructions
(Section&#XA0;<A HREF="#installation">1.2</A>).</P></LI><LI CLASS="li-itemize">If you get an error such as<PRE CLASS="verbatim">package checkers.nullness.quals does not exist
</PRE><P>despite no apparent use of <TT>import checkers.nullness.quals.*;</TT> in
the source code, then perhaps
<TT>jsr308_imports</TT> is set as a Java system property, a shell
environment variable, or a command-line option (see
Section&#XA0;<A HREF="#jsr308_imports">20.3.2</A>). You can solve this by unsetting the
variable/option, or by ensuring that the <TT>checkers.jar</TT> file is on
your classpath.</P><P>If the error is </P><PRE CLASS="verbatim">package 'checkers.nullness.quals does not exist
</PRE><P>(note the extra apostrophe!), then you have probably misused quoting when
supplying the <TT>jsr308_imports</TT> environment variable.</P></LI><LI CLASS="li-itemize">If you get an error like the following when using the Ant task
(Section&#XA0;<A HREF="#ant-task">23.2</A>),<PRE CLASS="verbatim">...\build.xml:59: Error running ${env.CHECKERS}\binary\javac.bat compiler
</PRE><P>then the problem may be that you have not set the CHECKERS environment
variable, as described in Section&#XA0;<A HREF="#windows-installation">23.1.2</A>. Or, maybe
you made it a user variable instead of a system variable.</P></LI><LI CLASS="li-itemize">If you get one of these errors:<PRE>
The hierarchy of the type <EM>ClassName</EM> is inconsistent

The type com.sun.source.util.AbstractTypeProcessor cannot be resolved.
  It is indirectly referenced from required .class files", 
</PRE><P>then you are missing <TT>jsr308-all.jar</TT> from your classpath.</P></LI><LI CLASS="li-itemize">If you get the error<PRE CLASS="verbatim">  java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy
</PRE><P>then an annotation is not present at run time that was present at compile
time. For example, maybe when you compiled the code, the <TT>@Nullable</TT>
annotation was available, but it was not available at run time.
You can use JDK 8 at run time, or compile
with a Java 7 compiler that will ignore the annotations in comments.</P></LI><LI CLASS="li-itemize">A &#X201C;class file not found&#X201D; error may be due to a JDK version mismatch.
For instance, you might be using JDK 7, but you get an error that refers to a class that was in a
previous version of the JDK but has subsequently been removed, such as:<PRE CLASS="verbatim">  class file for java.io.File$LazyInitialization not found
  class file for java.util.Hashtable$EmptyIterator not found
  java.lang.NoClassDefFoundError: java/util/Hashtable$EmptyEnumerator
</PRE><P>Or, you might be using JDK 6, but you get an error that refers to a class
that has been introduced in a newer version of the JDK, such as:</P><PRE CLASS="verbatim">  class file for java.util.Vector$Itr not found
</PRE><P>This problem occurs when your classpath contains code that was compiled
with one version of the JDK and refers to its implementation details, but
your classpath does not contain that version of the JDK itself.</P><P>You can solve the problem by re-generating <TT>jdk/jdk.jar</TT> and
<TT>binary/jdk.jar</TT>. You can do this by running</P><PRE CLASS="verbatim">  cd checkers
  ant jdk.jar bindist
</PRE></LI><LI CLASS="li-itemize">If you get an error that contains lines like these:<PRE CLASS="verbatim">Caused by: java.util.zip.ZipException: error in opening zip file
 at java.util.zip.ZipFile.open(Native Method)
 at java.util.zip.ZipFile.&lt;init&gt;(ZipFile.java:131)
</PRE><P>then one possibility is that you have installed the Checker Framework in a
directory that contains special characters that Java&#X2019;s ZipFile
implementation cannot handle. For instance, if the directory name contains
&#X201C;<TT>+</TT>&#X201D;, then Java 1.6 throws a ZipException, and Java 1.7 throws a
FileNotFoundException and prints out the directory name with &#X201C;<TT>+</TT>&#X201D;
replaced by blanks.</P></LI></UL><!--TOC subsection Unexpected type-checking results-->
<H3 CLASS="subsection"><A NAME="common-problems-typechecking"><!--SEC ANCHOR -->25.1.2&#XA0;&#XA0;Unexpected type-checking results</A></H3><!--SEC END --><P>This section describes possible problems that can lead the type-checker to
give unexpected results.</P><UL CLASS="itemize"><LI CLASS="li-itemize">
If the Checker Framework is unable to verify a property that you know is
true, then it is helpful to formulate an argument about why the property
is true. Recall that the Checker Framework does modular verification,
one procedure at a time; it observes the specifications, but not the
implementations, of other methods.<P>If any aspects of your argument are not expressed as annotations, then
you may need to write more annotations. If any aspects of your argument
are not expressible as annotations, then you may need to extend the
type-checker.</P></LI><LI CLASS="li-itemize">If a checker seems to be ignoring the annotation on a method, then it is
possible that the checker is reading the method&#X2019;s signature from its
<TT>.class</TT> file, but the <TT>.class</TT> file was not created by the JSR
308 compiler. You can check whether the annotations actually appear in the
<TT>.class</TT> file by using the <TT>javap</TT> tool.<P>If the annotations do not appear in the <TT>.class</TT> file, here are two
ways to solve the problem:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Re-compile the method&#X2019;s class with the Type Annotations compiler. This will
ensure that the type annotations are written to the class file, even if
no type-checking happens during that execution.
</LI><LI CLASS="li-itemize">Pass the method&#X2019;s file explicitly on the command line when type-checking,
so that the compiler reads its source code instead of its <TT>.class</TT>
file.
</LI></UL></LI><LI CLASS="li-itemize">If the compiler reports that it cannot find a method from the
JDK or another external library, then maybe the stub/skeleton file for that
class is incomplete. You can edit it to add the missing method. The
libraries appear, for example, at <TT>checkers/jdk/nullness/src/</TT> for the
Nullness checker.<P>The error might take one of these forms:</P><PRE CLASS="verbatim">method sleep in class Thread cannot be applied to given types
cannot find symbol: constructor StringBuffer(StringBuffer)
</PRE></LI></UL><!--TOC section How to report problems (bug reporting)-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="reporting-bugs">25.2</A>&#XA0;&#XA0;How to report problems (bug reporting)</H2><!--SEC END --><P>If you have a problem with any checker, or with the Checker Framework,
please file a bug at 
<A HREF="http://code.google.com/p/checker-framework/issues/list"><TT>http://code.google.com/p/checker-framework/issues/list</TT></A>.
(First, check whether there is an existing bug report for that issue.)</P><P>Alternately (especially if your communication is not a bug report), you can
send mail to checker-framework-dev@googlegroups.com.
We welcome suggestions, annotated libraries, bug fixes, new
features, new checker plugins, and other improvements.</P><P>Please ensure that your bug report is clear and that it is complete.
Otherwise, we may be unable to understand it or to reproduce it, either of
which would prevent us from fixing the bug. Your bug report will be most
helpful if you:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Add <TT>-version -verbose -AprintErrorStack -printAllQualifiers</TT> to the javac options. This causes the compiler to output
debugging information, including its version number.
</LI><LI CLASS="li-itemize">Indicate exactly what you did. Don&#X2019;t skip any steps, and don&#X2019;t merely
describe your actions in words. Show the exact commands by attaching a
file or using cut-and-paste from your command shell;
</LI><LI CLASS="li-itemize">Include all files that are necessary to reproduce the problem. This
includes every file that is used by any of the commands you reported, and
possibly other files as well.
</LI><LI CLASS="li-itemize">Indicate exactly what the result was by attaching a file or using
cut-and-paste from your command shell (don&#X2019;t merely describe it in
words). Also indicate what you expected the result to be &#X2014; remember, a
bug is a difference between desired and actual outcomes.
</LI></UL><P>A particularly useful format for a test case is as a new file, or a diff to
an existing file, for the existing Checker Framework test suite. For
instance, for the Nullness
Checker, see directory <TT>checker-framework/checkers/tests/nullness/</TT>.
But, please report your bug even if you do not report it in this format.</P><!--TOC section Building from source-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="build-source">25.3</A>&#XA0;&#XA0;Building from source</H2><!--SEC END --><P>The Checker Framework release (Section&#XA0;<A HREF="#installation">1.2</A>) contains
everything that most users need, both to use the distributed checkers and
to write your own checkers. This section describes how to compile its
binaries from source. You will be using the latest development version of
the Checker Framework, rather than an official release.</P><!--TOC subsection Obtain the source-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->25.3.1&#XA0;&#XA0;Obtain the source</H3><!--SEC END --><P>Obtain the latest source code from the version control repository:</P><PRE CLASS="verbatim">export JSR308=$HOME/jsr308
mkdir -p $JSR308
cd $JSR308
hg clone https://code.google.com/p/jsr308-langtools/ jsr308-langtools
hg clone https://code.google.com/p/checker-framework/ checker-framework
hg clone https://code.google.com/p/annotation-tools/ annotation-tools
</PRE><P>(Alternately, you could use the version of the source code that is packaged
in the Checker Framework release.)</P><!--TOC subsection Build the Type Annotations compiler-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->25.3.2&#XA0;&#XA0;Build the Type Annotations compiler</H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Set the <TT>JAVA_HOME</TT> environment variable to the location of your JDK 6 or
7 installation (not the JRE installation). This needs to be an Oracle JDK.
(The <TT>JAVA_HOME</TT> environment
variable might already be set, because it is needed for Ant to work.)</LI><LI CLASS="li-enumerate">Compile the Type Annotations javac compiler and the javap tool:<PRE CLASS="verbatim">  cd $JSR308/jsr308-langtools/make
  ant clean build-javac build-javap
</PRE></LI><LI CLASS="li-enumerate">Add the <TT>jsr308-langtools/dist/bin</TT> directory to the front of your PATH environment variable.
Example command:<PRE CLASS="verbatim">  export PATH=$JSR308/jsr308-langtools/dist/bin:${PATH}
</PRE></LI></OL><!--TOC subsection Build the Annotation File Utilities-->
<H3 CLASS="subsection"><A NAME="afu-building"><!--SEC ANCHOR -->25.3.3&#XA0;&#XA0;Build the Annotation File Utilities</A></H3><!--SEC END --><P>This is simply done by:</P><PRE CLASS="verbatim">  cd $JSR308/annotation-tools
  ant
</PRE><P>You do not need to add the Annotation File Utilities to the path, as
the Checker Framework build finds it using relative paths.</P><!--TOC subsection Build the Checker Framework-->
<H3 CLASS="subsection"><A NAME="building"><!--SEC ANCHOR -->25.3.4&#XA0;&#XA0;Build the Checker Framework</A></H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Run <TT>ant</TT> to create <TT>checkers.jar</TT>:<PRE CLASS="verbatim">  cd $JSR308/checker-framework/checkers
  ant
</PRE></LI><LI CLASS="li-enumerate">Add <TT>tools.jar</TT> and <TT>checkers.jar</TT> to your classpath.
(If you do not do this, you will have to supply the <TT>-cp</TT> option
whenever you run <TT>javac</TT> and use a checker plugin.)
Example command:<PRE CLASS="verbatim">  export CLASSPATH=${CLASSPATH}:$JAVA_HOME/lib/tools.jar:$JSR308/checker-framework/checkers/checkers.jar
</PRE></LI><LI CLASS="li-enumerate">Test that everything works:<UL CLASS="itemize"><LI CLASS="li-itemize">Run <TT>ant all-tests</TT> in the <TT>checkers</TT> directory:
<PRE CLASS="verbatim">  cd $JSR308/checker-framework/checkers
  ant all-tests
</PRE></LI><LI CLASS="li-itemize">Run the Nullness checker examples (see
Section&#XA0;<A HREF="#nullness-example">3.8</A>).</LI></UL></LI></OL><!--TOC subsection Build the Checker Framework manual (this document)-->
<H3 CLASS="subsection"><!--SEC ANCHOR -->25.3.5&#XA0;&#XA0;Build the Checker Framework manual (this document)</H3><!--SEC END --><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
To build the manual you will need plume-bib (<A HREF="http://code.google.com/p/plume-bib/"><TT>http://code.google.com/p/plume-bib/</TT></A>) and H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A (<A HREF="http://hevea.inria.fr/"><TT>http://hevea.inria.fr/</TT></A>) installed.</LI><LI CLASS="li-enumerate">Run <TT>make</TT> in the <TT>checkers/manual</TT> directory to build both the PDF and HTML versions of the manual.
</LI></OL><!--TOC section Learning more-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="learning-more">25.4</A>&#XA0;&#XA0;Learning more</H2><!--SEC END --><P>The technical paper &#X201C;Practical pluggable types for Java&#X201D;&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>]
(<A HREF="http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008.pdf"><TT>http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008.pdf</TT></A>)
gives more technical detail about many
aspects of the Checker Framework and its implementation.
The technical
paper also describes case
studies in which each of the checkers found
previously-unknown errors in real software.</P><P>The paper &#X201C;Building and using pluggable type-checkers&#X201D;&#XA0;[<A HREF="#DietlDEMS2011">DDE<SUP>+</SUP>11</A>]
(<A HREF="http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-icse2011.pdf"><TT>http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-icse2011.pdf</TT></A>)
discusses further experience with the Checker Framework, increasing the
number of lines of verified code to 3 million.</P><P>In addition to these papers that discuss use the Checker Framework
directly, other academic papers use the Checker Framework in their
implementation or evaluation. Most educational use of the Checker
Framework is never published, and most commercial use of the Checker
Framework is never discussed publicly.</P><!--TOC section Comparison to other tools-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="other-tools">25.5</A>&#XA0;&#XA0;Comparison to other tools</H2><!--SEC END --><P>A pluggable type-checker, such as those created by the Checker Framework,
aims to help you prevent or detect all errors of a given variety. An
alternate approach is to use a bug detector such as
<A HREF="http://findbugs.sourceforge.net/">FindBugs</A>,
<A HREF="http://artho.com/jlint/">JLint</A>, or
<A HREF="http://pmd.sourceforge.net/">PMD</A>.</P><P>A pluggable type-checker
differs from a bug detector in several ways:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
A type-checker aims to find <EM>all</EM> errors. Thus, it can verify the
<EM>absence</EM> of errors: if the type checker says there are no null
pointer errors in your code, then there are none. (This guarantee only
holds for the code it checks, of course; see
Section&#XA0;<A HREF="#checker-guarantees">2.3</A>.)<P>A bug detector aims to find <EM>some</EM> of the most obvious errors. Even
if it reports no errors, then there may still be errors in your code.</P><P>Both types of tools may issue false positive warnings; see
Section&#XA0;<A HREF="#suppressing-warnings">20.2</A>.</P></LI><LI CLASS="li-itemize">A type-checker requires you to annotate your code with type qualifiers,
or to run an inference tool that does so for you. A bug detector may not
require annotations. This means that it may be easier to get started
running a bug detector.</LI><LI CLASS="li-itemize">A type-checker may use a more sophisticated and complete analysis.
A bug detector typically does a more lightweight analysis, coupled with
heuristics to suppress false positives.<P>As one example, a type-checker can take advantage of annotations on
generic type parameters, such as <TT>List&lt;@NonNull String&gt;</TT>, permitting
it to be much more precise for code that uses generics.</P></LI></UL><P>A case study&#XA0;[<A HREF="#PapiACPE2008">PAC<SUP>+</SUP>08</A>, &#XA7;6] compared the Checker Framework&#X2019;s nullness
checker with those of FindBugs, JLint, and PMD. The case study was on a
well-tested program in daily use. The Checker Framework tool found 8
nullness errors (that is, null pointer dereferences). None of the other
tools found any errors.</P><P>Also see the
<A HREF="http://types.cs.washington.edu/jsr308/">JSR 308</A>&#XA0;[<A HREF="#JSR308-2008-09-12">Ern08</A>]
documentation for a detailed discussion of related work.</P><!--TOC section Credits and changelog-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="credits">25.6</A>&#XA0;&#XA0;Credits and changelog</H2><!--SEC END --><P>The key developers of the Checker Framework are Mahmood Ali, Telmo Correa,
Werner M. Dietl, Michael D. Ernst, and Matthew M. Papi.
Many other developers have also contributed, for example by writing
the checkers that are distributed with the Checker Framework.
Many, many users to list have provided valuable feedback, for which we are
grateful.</P><P>Differences from previous versions of the checkers and framework can be found
in the <TT>changelog-checkers.txt</TT> file. This file is included in the
Checker Framework distribution and is also available on the web at
<A HREF="http://types.cs.washington.edu/checker-framework/current/changelog-checkers.txt"><TT>http://types.cs.washington.edu/checker-framework/current/changelog-checkers.txt</TT></A>.</P><HR><!--TOC chapter References-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->References</H1><!--SEC END --><DL CLASS="thebibliography"><DT CLASS="dt-thebibliography">
<A NAME="Artho2001"><FONT COLOR=purple>[Art01]</FONT></A></DT><DD CLASS="dd-thebibliography">
Cyrille Artho.
Finding faults in multi-threaded programs.
Master&#X2019;s thesis, Swiss Federal Institute of Technology, March&#XA0;15,
2001.</DD><DT CLASS="dt-thebibliography"><A NAME="Copeland2005"><FONT COLOR=purple>[Cop05]</FONT></A></DT><DD CLASS="dd-thebibliography">
Tom Copeland.
<EM>PMD Applied</EM>.
Centennial Books, November 2005.</DD><DT CLASS="dt-thebibliography"><A NAME="JSR198"><FONT COLOR=purple>[Cro06]</FONT></A></DT><DD CLASS="dd-thebibliography">
Jose Cronembold.
JSR 198: A standard extension API for Integrated Development
Environments.
<A HREF="http://jcp.org/en/jsr/detail?id=198"><TT>http://jcp.org/en/jsr/detail?id=198</TT></A>, May&#XA0;8, 2006.</DD><DT CLASS="dt-thebibliography"><A NAME="JSR269"><FONT COLOR=purple>[Dar06]</FONT></A></DT><DD CLASS="dd-thebibliography">
Joe Darcy.
JSR 269: Pluggable annotation processing API.
<A HREF="http://jcp.org/en/jsr/detail?id=269"><TT>http://jcp.org/en/jsr/detail?id=269</TT></A>, May&#XA0;17, 2006.
Public review version.</DD><DT CLASS="dt-thebibliography"><A NAME="DietlDEMS2011"><FONT COLOR=purple>[DDE</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>11]</FONT></A></DT><DD CLASS="dd-thebibliography">
Werner Dietl, Stephanie Dietzel, Michael&#XA0;D. Ernst, Kivan&#XE7; Mu&#X15F;lu,
and Todd Schiller.
Building and using pluggable type-checkers.
In <EM>ICSE&#X2019;11, Proceedings of the 33rd International Conference on
Software Engineering</EM>, pages 681&#X2013;690, Waikiki, Hawaii, USA, May&#XA0;25&#X2013;27,
2011.</DD><DT CLASS="dt-thebibliography"><A NAME="JSR308-2008-09-12"><FONT COLOR=purple>[Ern08]</FONT></A></DT><DD CLASS="dd-thebibliography">
Michael&#XA0;D. Ernst.
Type Annotations specification (JSR 308).
<A HREF="http://types.cs.washington.edu/jsr308/"><TT>http://types.cs.washington.edu/jsr308/</TT></A>, September&#XA0;12, 2008.</DD><DT CLASS="dt-thebibliography"><A NAME="Evans96"><FONT COLOR=purple>[Eva96]</FONT></A></DT><DD CLASS="dd-thebibliography">
David Evans.
Static detection of dynamic memory errors.
In <EM>PLDI 1996, Proceedings of the SIGPLAN &#X2019;96 Conference on
Programming Language Design and Implementation</EM>, pages 44&#X2013;53, Philadelphia,
PA, USA, May&#XA0;21&#X2013;24, 1996.</DD><DT CLASS="dt-thebibliography"><A NAME="FahndrichL2003"><FONT COLOR=purple>[FL03]</FONT></A></DT><DD CLASS="dd-thebibliography">
Manuel F&#XE4;hndrich and K.&#XA0;Rustan&#XA0;M. Leino.
Declaring and checking non-null types in an object-oriented language.
In <EM>Object-Oriented Programming Systems, Languages, and
Applications (OOPSLA 2003)</EM>, pages 302&#X2013;312, Anaheim, CA, USA, November&#XA0;6&#X2013;8,
2003.</DD><DT CLASS="dt-thebibliography"><A NAME="FlanaganLLNSS02"><FONT COLOR=purple>[FLL</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>02]</FONT></A></DT><DD CLASS="dd-thebibliography">
Cormac Flanagan, K.&#XA0;Rustan&#XA0;M. Leino, Mark Lillibridge, Greg Nelson, James&#XA0;B.
Saxe, and Raymie Stata.
Extended static checking for Java.
In <EM>PLDI 2002, Proceedings of the </EM><EM>ACM</EM><EM> </EM><EM>SIGPLAN</EM><EM> 2002 Conference
on Programming Language Design and Implementation</EM>, pages 234&#X2013;245, Berlin,
Germany, June&#XA0;17&#X2013;19, 2002.</DD><DT CLASS="dt-thebibliography"><A NAME="Goetz2006:typedef"><FONT COLOR=purple>[Goe06]</FONT></A></DT><DD CLASS="dd-thebibliography">
Brian Goetz.
The pseudo-typedef antipattern: Extension is not type definition.
<A HREF="http://www.ibm.com/developerworks/java/library/j-jtp02216/"><TT>http://www.ibm.com/developerworks/java/library/j-jtp02216/</TT></A>,
February&#XA0;21, 2006.</DD><DT CLASS="dt-thebibliography"><A NAME="Goetz2006"><FONT COLOR=purple>[GPB</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>06]</FONT></A></DT><DD CLASS="dd-thebibliography">
Brian Goetz, Tim Peierls, Joshua Bloch, Joseph Bowbeer, David Holmes, and Doug
Lea.
<EM>Java Concurrency in Practice</EM>.
Addison-Wesley, 2006.</DD><DT CLASS="dt-thebibliography"><A NAME="HovemeyerP2004"><FONT COLOR=purple>[HP04]</FONT></A></DT><DD CLASS="dd-thebibliography">
David Hovemeyer and William Pugh.
Finding bugs is easy.
In <EM>Companion to Object-Oriented Programming Systems, Languages,
and Applications (OOPSLA 2004)</EM>, pages 132&#X2013;136, Vancouver, BC, Canada,
October&#XA0;26&#X2013;28, 2004.</DD><DT CLASS="dt-thebibliography"><A NAME="HovemeyerSP2005"><FONT COLOR=purple>[HSP05]</FONT></A></DT><DD CLASS="dd-thebibliography">
David Hovemeyer, Jaime Spacco, and William Pugh.
Evaluating and tuning a static analysis to find null pointer bugs.
In <EM>ACM SIGPLAN/SIGSOFT Workshop on Program Analysis for Software
Tools and Engineering (PASTE 2005)</EM>, pages 13&#X2013;19, Lisbon, Portugal,
September&#XA0;5&#X2013;6, 2005.</DD><DT CLASS="dt-thebibliography"><A NAME="LeavensBR2006:JML"><FONT COLOR=purple>[LBR06]</FONT></A></DT><DD CLASS="dd-thebibliography">
Gary&#XA0;T. Leavens, Albert&#XA0;L. Baker, and Clyde Ruby.
Preliminary design of JML: A behavioral interface specification
language for Java.
<EM>ACM SIGSOFT Software Engineering Notes</EM>, 31(3), March 2006.</DD><DT CLASS="dt-thebibliography"><A NAME="PapiACPE2008"><FONT COLOR=purple>[PAC</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>08]</FONT></A></DT><DD CLASS="dd-thebibliography">
Matthew&#XA0;M. Papi, Mahmood Ali, Telmo&#XA0;Luis Correa&#XA0;Jr., Jeff&#XA0;H. Perkins, and
Michael&#XA0;D. Ernst.
Practical pluggable types for Java.
In <EM>ISSTA 2008, Proceedings of the 2008 International Symposium
on Software Testing and Analysis</EM>, pages 201&#X2013;212, Seattle, WA, USA,
July&#XA0;22&#X2013;24, 2008.</DD><DT CLASS="dt-thebibliography"><A NAME="QuinonezTE2008"><FONT COLOR=purple>[QTE08]</FONT></A></DT><DD CLASS="dd-thebibliography">
Jaime Quinonez, Matthew&#XA0;S. Tschantz, and Michael&#XA0;D. Ernst.
Inference of reference immutability.
In <EM>ECOOP 2008 &#X2014; Object-Oriented Programming, 22nd European
Conference</EM>, pages 616&#X2013;641, Paphos, Cyprus, July&#XA0;9&#X2013;11, 2008.</DD><DT CLASS="dt-thebibliography"><A NAME="TschantzE2005"><FONT COLOR=purple>[TE05]</FONT></A></DT><DD CLASS="dd-thebibliography">
Matthew&#XA0;S. Tschantz and Michael&#XA0;D. Ernst.
Javari: Adding reference immutability to Java.
In <EM>Object-Oriented Programming Systems, Languages, and
Applications (OOPSLA 2005)</EM>, pages 211&#X2013;230, San Diego, CA, USA,
October&#XA0;18&#X2013;20, 2005.</DD><DT CLASS="dt-thebibliography"><A NAME="ZibinPAAKE2007"><FONT COLOR=purple>[ZPA</FONT><SUP><FONT COLOR=purple>+</FONT></SUP><FONT COLOR=purple>07]</FONT></A></DT><DD CLASS="dd-thebibliography">
Yoav Zibin, Alex Potanin, Mahmood Ali, Shay Artzi, Adam Kie&#X17C;un, and
Michael&#XA0;D. Ernst.
Object and reference immutability using Java generics.
In <EM>ESEC/FSE 2007: Proceedings of the 11th European Software
Engineering Conference and the 15th </EM><EM>ACM</EM><EM> </EM><EM>SIGSOFT</EM><EM> Symposium on the
Foundations of Software Engineering</EM>, pages 75&#X2013;84, Dubrovnik, Croatia,
September&#XA0;5&#X2013;7, 2007.</DD></DL><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
</BODY>
</HTML>
